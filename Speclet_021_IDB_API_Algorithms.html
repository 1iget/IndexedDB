<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graff", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" },
              { name: "Jeremy Orlow", url: "mailto:jorlow@google.com",
                company: "Google" },
              { name: "Joshua Bell", url: "mailto:jsbell@google.com",
                company: "Google" }
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",

          noIDLSectionTitle: true,
      };
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      .example .example .example-title {
          display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>

    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>


      <!-- begin-content -->
      <section class="section" id="algorithms">
        <h3>Algorithms</h3>
        <section class="section" id="opening">
          <h4>Opening a database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are defined in the following steps. The algorithm in these steps
            takes four arguments:
            the <var>origin</var> which requested the <a>database</a> to be opened,
            a database <var>name</var>,
            a database <var>version</var>,
            and a <var>request</var>.

            <!-- The algorithm also takes two optional
            arguments, a <var>request</var> which represents a <a>request</a> used when opening the database is done by using
            an asynchronous API or a <var>upgrade callback</var> which represents the callback used when opening the database
            is done by using the synchronous API.
            -->
          </p>

          <ol>
            <li>
              If these steps fail for any reason, return an error with the appropriate type and abort
              this algorithm.
            </li>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <!--<li>
              If <var>db</var> was found in the previous step, and it has a <a>version</a> higher than
              <var>version</var>, then abort these steps and return a <a><code>VERSION_ERR</code></a> error.
              Likewise, if at any point while running these steps, these steps are also running with the same
              <var>origin</var> and <var>name</var>, but with a higher <var>version</var>, abort these steps and
              return a <a><code>VERSION_ERR</code></a> error.
              <p class="note">
                <p>This can happen in for example the following four situations:</p>
                <ul>
                  <li>
                    The database already has a version higher than the version requested to be opened.
                  </li>
                  <li>
                    Another call to <code>open</code> with a higher version is already in progress, but is
                    waiting for other connections to be closed before being able to fire the
                    <code>upgradeneeded</code> event.
                  </li>
                  <li>
                    While this call is waiting for other connections to be closed before being able to firing
                    the <code>upgradeneeded</code> event, another call to <code>open</code> is made with a
                    higher version.
                  </li>
                  <li>
                    Two calls to open happen at the same time with different version numbers.
                  </li>
                </ul>
              </p>
            </li>-->
            <li>
              If <var>db</var> was found in previous step, wait until the following conditions are all fulfilled:
              <ul>
                <li>
                  No already existing <a title="connection">connections</a> to <var>db</var>, have
                  non-<a title="transaction finish">finished</a> <code>"versionchange"</code> <a>transaction</a>.
                </li>
                <li>
                  If <var>db</var> has its <a>delete pending</a> flag set, wait until <var>db</var> has
                  been deleted.
                </li>
                <li>
                  These steps are not run for any other <a title="connection">connections</a> with the same <var>origin</var>
                  and <var>name</var> but with a higher <var>version</var>.
                </li>
              </ul>
              <p class="note">
                If several connections with the same origin, name and version are opened at the same time,
                and that version is a higher version that the database's current version, then once any of
                those connections can proceed to the next step in this algorithm it will immediately start
                a <code>"versionchange"</code> transaction. This prevents the other connections from proceeding until that
                <code>"versionchange"</code> transaction is finished.
              </p>
              <p class="note">
                This means that if two databases with the same name and origin, but with different versions, are
                being opened at the same time, the one with the highest version will attempt to be opened first.
                If it is able to successfully open, then the one with the lower version will receive an error.
              </p>
            </li>
            <li>
              If no database with the given name from the origin <var>origin</var> was found, or if it was
              deleted during the previous step, then create a <a>database</a> with name <var>name</var>,
              with <code>0</code> as <a>version</a>, and with no <a title="object store">object stores</a>. Let <var>db</var>
              be the new database.
            </li>
            <li>
                If <var>version</var> is <code>undefined</code>, then let <var>version</var> be <code>1</code>
                if <var>db</var> was created in the previous step, or the current <a>version</a> of <var>db</var> otherwise.
            </li>
            <li>
              If the <a>version</a> of <var>db</var> is higher than <var>version</var>, abort these steps and return
              a <code>DOMError</code> of type <a>VersionError</a>.
            </li>
            <li>
              Create a new <a>connection</a> to <var>db</var> and let <var>connection</var> represent it.
            </li>
            <li>
              If the <a>version</a> of <var>db</var> is lower than <var>version</var>, then run the
              <a>steps for running a <code>"versionchange"</code> transaction</a> using <var>connection</var>,
              <var>version</var> and <var>request</var> <!--and <var>upgrade callback</var>-->.
            </li>
            <li>
              If the previous step resulted in an error, then return that error and abort these steps.
              If the <code>"versionchange"</code> transaction in the previous step was aborted, or if
              <var>connection</var> is <a title="database close">closed</a>, return a
              <code>DOMError</code> of type <a>AbortError</a> and abort these steps.
              In either of these cases, ensure that <var>connection</var> is <a title="database close">closed</a>
              by running the <a>steps for closing a database connection</a> before these steps are aborted.
            </li>
            <li>
              Return <var>connection</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Transaction Creation steps</h4>
          <p>
            When the user agent is to <dfn>create a <a>transaction</a></dfn>
            it MUST run the following steps. This algorithm takes three arguments:
            a <a><var>connection</var></a>,
            a <a><var>mode</var></a>,
            and the list <var>storeNames</var> naming the <a title="object store">object stores</a> to be included in the <a>scope</a> of the transaction.
            <!--, a
            <var>timeout</var> for the transaction <a title="transaction start">starting</a>,
            and a <var>callback</var> parameter for synchronously created transactions. -->
          </p>
          <ol>
            <!--
            <li>
              If these steps are already running synchronously (a <a>transaction</a> was created within a
              <a>transaction</a> callback),
              throw a <code>DOMException</code> of type <a><code>InvalidStateError</code></a>.
            </li>
              -->
            <li>
              If <var>storeNames</var> is of type <code>sequence&lt;DOMString&gt;</code> then let
              <var>scope</var> be the set of unique strings in the sequence. Otherwise, <var>storeNames</var>
              must be a <code>DOMString</code>; let <var>scope</var> be a set containing one string equal to <var>storeNames</var>.

              If any of the strings in <var>scope</var> identifies an <a>object store</a> which doesn't exist,
              throw a <code>DOMException</code> of type <a><code>NotFoundError</code></a>.

              If <var>scope</var> is an empty set
              throw a <code>DOMException</code> of type <a><code>InvalidAccessError</code></a>.
            </li>
            <li>
              If the <a>closePending</a> flag is set on <var>connection</var> then
              throw a <code>DOMException</code> of type <a><code>InvalidStateError</code></a>.
            </li>
            <li>
              <a title="transaction create">Create</a> a <a>transaction</a> using <var>connection</var> as
              <a>connection</a>, <var>mode</var> as <a>mode</a>, and the <a title="object store">object stores</a> identified in
              <var>scope</var> as <a>scope</a>.
            </li>
            <li>
              <!-- If these steps are running asynchronously, -->
              Return the created <a>transaction</a> and queue up the remaining steps.
              When control is returned to the event loop, the implementation MUST set the <a>active</a> flag to false.
            </li>
            <li>
              Wait until the <a>transaction</a> can be <a title="transaction start">started</a> according to the
              <a>transaction lifetime</a> rules.
              <!--
              If this takes longer than the specified <var>timeout</var> then
              throw a <code>DOMException</code> of type <a><code>TimeoutError</code></a>.
              <p class="note">
                Because the asynchronous API always passes in a <var>timeout</var> of infinite, only the synchronous
                API will ever time out.
              </p>
              -->
            </li>
            <!--
            <li>
              If these steps are running synchronously, the implementation MUST synchronously call <var>callback</var>
              with a single parameter which is the <a>transaction</a>. If an exception is thrown and not caught within the
              scope of the callback, the implementation MUST abort the <a>transaction</a> by following the <a>steps for
              aborting a transaction</a> using the <code>name</code> of the exception that was thrown as the <var>error</var>
              parameter, abort this algorithm without taking any further steps, and re-throw the exception.
            </li>
            <li>
              If these steps are running synchronously, the implementation MUST commit the transaction synchronously.
            </li>
            -->
          </ol>
        </section>
        <section class="section">
          <h4>Steps for committing a transaction</h4>
          <p>
            When taking the <dfn>steps for committing a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes one argument, the <var>transaction</var> to commit.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> by the <a>transaction</a> are written to the <a>database</a>.
            </li>
            <li>
              If an error occurs while writing the changes to the <a>database</a>, abort the transaction by following
              the <a>steps for aborting a transaction</a> with the <var>transaction</var> parameter set to <var>transaction</var>
              and the <var>error</var> parameter set to a value appropriate for the error, for example <code>QuotaExceededError</code>
              or <code>UnknownError</code>.
            </li>
            <li>
              Queue up an operation to dispatch an event at <a>transaction</a>.
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"complete"</code>.
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
              <p class="note">
                Even if an exception is thrown from one of the event handlers of this event, the transaction is still
                committed since writing the database changes happens before the event takes places. Only after the transaction
                has been successfully written is the <code>"complete"</code> event fired.
              </p>
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for aborting a transaction</h4>
          <p>
            When taking the <dfn>steps for aborting a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes two arguments:
            the <var>transaction</var> to abort,
            and an <var>error</var> name.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> by the <a>transaction</a> are reverted. For <code>"versionchange"</code>
              transactions this includes changes to the set of <a title="object store">object stores</a> and <a title="index">indexes</a>, as well
              as the change to the <a>version</a>. Also run the <a>steps for aborting a <code>"versionchange"</code> transaction</a>
              which reverts changes to all <a>IDBDatabase</a> and <a>IDBObjectStore</a> instances.
            </li>
            <li>
              Unless <var>error</var> was set to <code>null</code>, create a <code>DOMError</code> object and set its <code>name</code>
              to <var>error</var>. Set <var>transaction</var>'s <code>error</code> property to this newly created <code>DOMError</code>.
            </li>
            <li>
              If the transaction's <a>request list</a> contain any <a title="request">requests</a> whose <a title="request done">done</a> flag
              is still false, abort the <a>steps for asynchronously executing a request</a> for each such request and queue
              a task to perform the following steps:
              <ol>
                <li>
                  Set the <a title="request done">done</a> flag on the <a>request</a> to true, set
                  <a title="request result">result</a> of the <a>request</a> to <code>undefined</code>
                  and set the request's <a>error attribute</a> to a <code>DOMError</code> with a type of <a>AbortError</a>.
                </li>
                <li>
                  Dispatch an event at <var>request</var>. The event must use
                  the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"error"</code>.
                  The event bubbles and is cancelable. The
                  <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
                  then <var>transaction</var> and finally the <a>request</a>. There is no <a>default action</a> for the event.
                </li>
              </ol>
              <p class="note">
                This does not always result in any <code>error</code> events being fired. For example if a transaction is aborted
                due to an error while <a title="transaction commit">committing</a> the transaction, or if it was the last remaining request
                that failed.
              </p>
            </li>
            <li>
              Queue up an operation to dispatch an event at <var>transaction</var>.
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"abort"</code>.
              The event does bubble but is not cancelable.
              The <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for asynchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
            perform on a database.
          </p>
          <p>
            These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
            to is <a title="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with <var>source</var>.
            </li>
            <li>
              If <var>transaction</var> is not <a>active</a>
              throw a <code>DOMException</code> of type <a><code>TransactionInactiveError</code></a>.
            </li>
            <li>
              Create an <a>IDBRequest</a> object and set <var>request</var> to this object. Set <var>request</var>'s
              <a title="request source">source</a> to <var>source</var> and add <var>request</var> to the end of the
              <a title="request list">list</a> of <a title="request">requests</a> in <var>transaction</var>.
              Return this object and queue up the execution of the remaining steps in this algorithm.
              <p class="note">
                Cursors override this step to reuse an existing <a>IDBRequest</a>. However they still put the
                <a>IDBRequest</a> at the end of the list of <a title="request">requests</a> in <var>transaction</var>.
              </p>
            </li>
            <li>
              Wait until all previously added <a title="request">requests</a> in <var>transaction</var> have their
              <a title="request done">done</a> flag set to true.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then set the <a title="request done">done</a> flag
              on the <var>request</var> to true, set <a title="request result">result</a> of the <var>request</var>
              to the result of the request and set the <a>error attribute</a> of the <var>request</var> to <code>undefined</code>.
			  Finally <a>fire a success event</a> at <var>request</var>.
            </li>
            <li>
              If performing <var>operation</var> failed then revert all changes made by <var>operation</var>,
              set the <a title="request done">done</a> flag on the <var>request</var> to true,
              set <a title="request result">result</a> of the <var>request</var>
              to <code>undefined</code> and set the <a>error attribute</a> on the <var>request</var>
              to a <code>DOMError</code> with the same error type as the <var>operation</var> that failed.
              Finally <a>fire an error event</a> at <var>request</var>.
              <p class="note">
                This only reverts the changes done by this request, not any other changes made by the transaction.
              </p>
            </li>
          </ol>
        </section>
        <!--
        <section class="section">
          <h4>Steps for synchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for synchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
            perform on a database.
          </p>
          <ol>
            <li>
              If the <a>transaction</a> associated with <var>source</var> is not <a>active</a>
              throw a <code>DOMException</code> of type <a>TransactionInactiveError</a>.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then return the result of the operation.
            </li>
            <li>
              If performing <var>operation</var> failed, then throw a <code>DOMException</code> with the type
              of error from the <var>operation</var>.
            </li>
          </ol>
        </section>
        -->
        <section class="section">
          <h4>Steps for extracting a key from a value using a <a>key path</a></h4>
          <p>
            When taking the <dfn>steps for extracting a key from a value using a key path</dfn>, the implementation
            MUST run the following algorithm. The algorithm takes a <a>key path</a> named <var>keyPath</var> and a
            <a>value</a> named <var>value</var> and in some cases returns a <a>key</a> which may or may not be a
            <a>valid key</a>.
          </p>
          <ol>
            <li>
              If <var>keyPath</var> is a <code>sequence&lt;DOMString&gt;</code>, then let <var>result</var> be newly constructed empty
              <code>Array</code>. For each item in the <var>keyPath</var> sequence, perform the following
              substeps:
              <ol>
                <li>
                  Evaluate the <a>steps for extracting a key from a value using a key path</a> using the
                  item from the <var>keyPath</var> sequence as <var>keyPath</var> and <var>value</var> as <var>value</var>.
                </li>
                <li>
                  If the result of the previous step was not a valid <a>key</a>, then abort the overall algorithm
                  and no value is returned.
                </li>
                <li>
                  Add the result of the first sub-step to end of the <var>result</var> array.
                </li>
              </ol>
              Return <var>result</var> as result of this algorithm and perform no additional steps.
              <p class="note">
                This will only ever "recurse" one level since <a>key path</a> sequences can't ever be nested.
              </p>
            </li>
            <li>
              If <var>keyPath</var> is the empty string, return <var>value</var> and skip the remaining steps.
            </li>
            <li>
              Let <var>remainingKeyPath</var> be <var>keyPath</var> and <var>object</var> be <var>value</var>.
            </li>
            <li>
              If <var>remainingKeyPath</var> has a period in it, assign <var>identifier</var> to be everything before the
              first period and assign <var>remainingKeyPath</var> to be everything after that first period. Otherwise, assign <var>identifier</var>
              to be <var>remainingKeyPath</var> and assign <var>remainingKeyPath</var> to be null.
            </li>
            <li>
              If <var>object</var> does not have an property named <var>identifier</var>, then skip the rest of
              these steps and no value is returned.
            </li>
            <li>
              Assign <var>object</var> to be the value of the property named <var>identifier</var> on <var>object</var>.
            </li>
            <li>
              If <var>remainingKeyPath</var> is not null, go to step 4.
            </li>
            <li>
              Return <var>object</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4><code>"versionchange"</code> transaction steps</h4>
          <p>
            The <dfn>steps for running a <code>"versionchange"</code> transaction</dfn> are
            as follows. This algorithm takes three arguments:
            a <var>connection</var> object which is used to update the <a>database</a>,
            a new <var>version</var> to be set for the <a>database</a>,
            and a <var>request</var>.
            <!--
            The algorithm also takes two optional arguments: a <var>request</var> which represents a <a>request</a>
            used when the asynchronous API is used, or a <var>upgrade callback</var> which
            represents the callback used when the synchronous API is used.
              -->
          </p>
          <ol>
            <li>
              Let <var>openDatabases</var> be the set of all <a>IDBDatabase</a> 
              <!-- and <a>IDBDatabaseSync</a> -->
              objects, except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a>IDBVersionChangeEvent</a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <var>version</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just the <a>IDBDatabase</a>
                object itself.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If
                <!-- running asynchronously and -->
                any of the <a title="connection">connections</a> in <var>openDatabases</var> are still not closed,
                queue up a <code>blocked</code> event for the <var>request</var>. The event MUST use the
                <a>IDBVersionChangeEvent</a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <var>version</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just <var>request</var>.
              </p>
            </li>
            <li id="version-change-close-block">
              Wait until all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">If .close() is called immediately but a <a>transaction</a> associated with the <var>connection</var>
              keeps running for a "long time", should we also fire a <code>blocked</code> event?</p>
              <p class="issue">If, while we're waiting here, someone calls open with a version number higher than <var>version</var>,
              we should probably let that upgrade run first and bail here if it was successful</p>
            </li>
            <li>
              Create a new <a>transaction</a> with <a>mode</a> set to <code>"versionchange"</code> and <var>connection</var> used as <a>connection</a>.
              The <a>scope</a> of the transaction includes every <a>object store</a> in <var>connection</var>. Set its
              <a>active</a> flag to false. Let <var>transaction</var> represent this transaction.
            </li>
            <li>
              Start <var>transaction</var>. Note that until this <a>transaction</a> is finished,
              no other <a title="connection">connections</a> can be opened to the same <a>database</a>.
            </li>
            <li>
              Let <var>old version</var> be <var>database</var>'s <a>version</a>.
            </li>
            <li>
              Set the version of <var>database</var> to <var>version</var>. This change is considered part of the
              <a>transaction</a>, and so if the transaction is <a title="transaction abort">abort</a>ed, this change is reverted.
            </li>
            <li>
              <!-- If running asynchronously, -->
              Schedule a task to run the following steps:
              <ol>
                <li>
                  Set the <a title="request result"><code>result</code></a> property of <var>request</var> to <var>connection</var>.
                </li>
                <li>
                  Set the <code>transaction</code> property of <var>request</var> to <var>transaction</var>.
                </li>
                <li>
                  Fire a <dfn><code>upgradeneeded</code></dfn> event targeted at <var>request</var>. The event MUST use the
                  <a>IDBVersionChangeEvent</a> interface and have the
                  <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>old version</var>
                  and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                  property set to <var>version</var>.
                  The <a title="request done">done</a> flag on the <a>request</a> is set to true.
                </li>
                <li>
                  If an exception was propagated out from any event handler while dispatching the event in the previous step, abort
                  the transaction by following the <a>steps for aborting a transaction</a> with the <var>error</var> property set to
                  <code>AbortError</code>.
                </li>
                <li>
                	If for any reason the <code>"versionchange"</code> transaction is aborted the <a>IDBDatabase</a>
                	instance which represents <var>connection</var> will remain unchanged.
                	I.e., its <code>name</code>, <code>version</code>, and <code>objectStoreNames</code> properties
                	will remain the value they were before the transaction was aborted.
               		The default attributes for the <a>IDBDatabase</a> are:
                		<table>
			          		<tr>
			          			<th>Attribute</th>
			          			<th>Value</th>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-name"><code>name</code></a></td>
			          			<td>the <var>name</var> provided to <a href="#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version"><code>IDBFactory.open</code></a></td>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-version"><code>version</code></a></td>
			          			<td> <code>0</code> (zero)</td>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-objectStoreNames"><code>objectStoresNames</code></a></td>
			          			<td>null</td>
			          		</tr>
                		</table>
                </li>
              </ol>
            </li>
            <!--
            <li>
              If running synchronously, call <var>upgrade callback</var> and pass it <var>transaction</var> as the first argument
              and <var>old version</var> the second argument.
            </li>
            -->
            <li>
              Execute the transaction.
            </li>
            <li>
              When the transaction is finished, 
              <!-- if these steps are run asynchronously, -->
              immediately set <var>request</var>'s
              <code>transaction</code> property to <code>null</code>. This MUST be done in the same task as the task firing the
              <code>complete</code> or <code>abort</code> event, but after those events has been fired.
            </li>
          </ol>
        </section>
        <section class="section">
        	<h4>Steps for aborting a <code>"versionchange"</code> transaction</h4>
        	<p>
        		The <dfn>steps for aborting a <code>"versionchange"</code> transaction</dfn> are as follows.
        	</p>
        	<ol>
        		<li>
        			<a href="#widl-IDBDatabase-name"><code>IDBDatabase.name</code></a> is not modified at all.
        			Even if the <a>transaction</a> is used to create a new database, and thus there is no on-disk database,
        			<a href="#widl-IDBDatabase-name"><code>IDBDatabase.name</code></a> remains as it was.
        		</li>
        		<li>
        			Revert <a href="#widl-IDBDatabase-version"><code>IDBDatabase.version</code></a> to the version the on-disk database had before the transaction was started.
        			If the <code>"versionchange"</code> <a>transaction</a> was started because the database was newly created,
        			revert <a href="#widl-IDBDatabase-version"><code>IDBDatabase.version</code></a> to version 0;
        			if the <a>transaction</a> was started in response to a version upgrade,
        			revert to the version it had before the <a>transaction</a> was started.
        			Note that the only time that the <a href="#widl-IDBDatabase-version"><code>IDBDatabase.version</code></a> property ever changes value
        			is during a <code>"versionchange"</code> <a>transaction</a>.
        		</li>
        		<li>
        			Revert <a href="#widl-IDBDatabase-objectStoreNames"><code>IDBDatabase.objectStoreNames</code></a> to the list of names that it had before the transaction was started.
        			If the <code>"versionchange"</code> <a>transaction</a> was started because the database was newly created,
        			revert it to an empty list.
        			If the <code>"versionchange"</code> <a>transaction</a> was started in response to a version upgrade,
        			revert to the list of <a>object store</a> names it had before the <a>transaction</a> was started.
        		</li>
        		<li>
        			Revert <a href="#widl-IDBObjectStore-indexNames"><code>IDBObjectStore.indexNames</code></a> (for each <a>object store</a>)
        			to the list of names that <a href="#widl-IDBObjectStore-indexNames"><code>IDBObjectStore.indexNames</code></a> had before the <a>transaction</a> was started.
        			For any <a>object store</a> that was created by the <a>transaction</a>, revert the list to an empty list.
        			For any <a>object store</a> that existed before the <a>transaction</a> was started,
        			revert to the list of index names it had before the <a>transaction</a> was started.
        			For any <a>object store</a> that was deleted during the <a>transaction</a>,
        			revert the list of names to the list it had before the <a>transaction</a> was started, potentially a non-empty list.
        			<p class="note">
        				Although you cannot access <a title="object store">object stores</a> by using the
        				<a href="#widl-IDBTransaction-objectStore-IDBObjectStore-DOMString-name"><code>IDBTransaction.objectStore</code></a> function after a <a>transaction</a> is aborted,
        				the page may still have references to <a>object store</a> instances.
        				In that case <a href="#widl-IDBObjectStore-indexNames"><code>IDBObjectStore.indexNames</code></a> can still be accessed.
        			</p>
        		</li>
        	</ol>
        </section>
        <section class="section">
          <h4>Database closing steps</h4>
          <p>The <dfn>steps for closing a database connection</dfn> are as follows. These steps take one argument, a <var>connection</var> object.
          <ol>
            <li>
              Set the internal <a><code>closePending</code></a> flag of <var>connection</var> to true.
            </li>
            <li>
              Wait for all transactions <a title="transaction create">created</a> using <var>connection</var> to complete.
              Once they are complete, <var>connection</var> is <a title="database close">closed</a>.
            </li>
          </ol>
          <p class="note">
            Once the <a><code>closePending</code></a> flag has ben set to true no new transactions can be
            <a title="transaction create">created</a> using <var>connection</var>. All functions that
            <a title="transaction create">create</a> transactions first check the <a>closePending</a> flag first and
            throw an exception if it is true.
          </p>
          <p class="note">
            Once the <a>connection</a> is closed, this can unblock the <a>steps for running a <code>"versionchange"</code>
            transaction</a>, and the <a>steps for deleting a database</a>, which <a href="#delete-close-block">both</a>
            <a href="#version-change-close-block">wait</a> for <a title="connection">connections</a> to a given <a>database</a> to be closed
            before continuing.
          </p>
        </section>
        <section class="section">
          <h4>Database deletion steps</h4>
          <p>
            The <dfn>steps for deleting a <a>database</a></dfn> are as follows.
            The algorithm in these steps takes three arguments:
            the <var>origin</var> that requested the <a>database</a> to be deleted,
            a database <var>name</var>,
            and a <var>request</var>.
          </p>
          <ol>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <li>
              If no database was found, then these steps are considered successful. Abort these steps.
            </li>
            <li>
              Set <var>db</var>'s <a>delete pending</a> flag to true.
            </li>
            <li>
              Let <var>openDatabases</var> be the set of all <a>IDBDatabase</a> and <a>IDBDatabaseSync</a>
              objects connected to <var>db</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a>IDBVersionChangeEvent</a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If any of the <a title="connection">connections</a> in <var>openDatabases</var> are still not closed, and <var>request</var> was provided,
                fire a <code>blocked</code> event at <var>request</var>. The event MUST use the
                <a>IDBVersionChangeEvent</a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
            </li>
            <li id="delete-close-block">
              Wait until all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">Should we allow <code>blocked</code> to be fired here too, if waiting takes "too long"?</p>
            </li>
            <li>
              Delete <var>db</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire a success event</h4>
          <p>
            To <dfn>fire a success event</dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <a>request</a>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"success"</code>.
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is the <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> using <var>transaction</var> as
              <var>transaction</var> parameter, and <code>AbortError</code> as <var>error</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire an error event</h4>
          <p>
            To <dfn title="fire an error event">fire an error event</dfn> at a <a><var>request</var></a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <var>request</var>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"error"</code>.
              The event bubbles and is cancelable. The
              <a>propagation path</a> for the event is the <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>. The event's <a>default action</a> is to abort the
              <var>transaction</var> by running the <a>steps for aborting a transaction</a> using <var>transaction</var> as <var>transaction</var>
              and the <code>name</code> of <a>request</a>'s <code>error</code> property as <var>error</var>. However the <a>default action</a> is
              not taken if any of the event handlers threw an exception.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> using <var>transaction</var> as
              <var>transaction</var> parameter, and <code>AbortError</code> as <var>error</var>. This is done even if the error event is not
              canceled.
              <p class="note">
                This means that if an error event is fired and any of the event handlers throw an exception, the <code>error</code> property
                on the transaction is set to an <code>AbortError</code> rather than whatever <code>DOMError</code> the <code>error</code>
                property on the request was set to. Even if <code>preventDefault</code> is never called.
            </li>
          </ol>
        </section>
        <section class="section">
        	<h4>Steps to assign a key to a value using a key path</h4>
        	<p>
        		The <dfn>steps to assign a key to a value using a key path</dfn> are as follows:
        	</p>
        	<ol>
        		<li>
        			Let <var>remainingKeyPath</var> be <var>keyPath</var> and <var>object</var> be <var>value</var>.
        		</li>
        		<li>
        			If <var>object</var> is not an <code>Object</code> object or an <code>Array</code> object (see <a>structured clone algorithm</a>
        			[[!HTML5]]), then
                                throw a <code>DOMException</code> of type <a><code>DataError</code></a>.

        		</li>
        		<li>
        			If <var>remainingKeyPath</var> has a period in it, assign <var>identifier</var> to be everything before the first period,
                                and assign <var>remainingKeyPath</var> to be everything after that first period. Otherwise, go to step 7.
        		</li>
        		<li>
        			If <var>object</var> does not have a property named <var>identifier</var>, then set a property named <var>identifier</var>
                                on <var>object</var> with the value of a new <code>Object</code>.
        		</li>
        		<li>
        			Assign <var>object</var> to be the value of the property named <var>identifier</var> on <var>object</var>.
        		</li>
        		<li>
        			Go to step 2.
        		</li>
        		<li>
        			<p class="note">The steps leading here ensure that <var>remainingKeyPath</var> is a single <a>identifier</a> name
        			(that is, a string without periods) by this step. The steps also ensure that <var>object</var>
        			is an <code>Object</code> or an <code>Array</code>, and not a <code>Date</code>, <code>RegExp</code>, <code>Blob</code>,
        			or other nonsupported type.
					</p>
        		</li>
        		<li>
        			Let <var>identifier</var> be <var>remainingKeyPath</var>.
        		</li>
        		<li>
        			Set a property named <var>identifier</var> on <var>object</var> with the value <var>key</var>.
        		</li>
        	</ol>
        	<p class="note">
        		The intent is that these steps are only executed if evaluating the <a>key path</a> did not yield a value.
        		In other words, before you run these steps, first evaluate the <a>key path</a> against <var>value</var>,
        		and only if that does not yield a value (where <code>undefined</code> does count as a value) do you generate a key and
        		use these steps to modify <var>value</var> to contain the generated key.
        	</p>
        	<p class="note">
                  The <a>key path</a> used here is always a <code>DOMString</code> and never an <code>sequence&lt;DOMString&gt;</code> since it is not
                  possible to create a <a>object store</a> whose <a>multiEntry</a> flag is true and whose
                  <a title="object store key path">key path</a> is an <code>sequence&lt;DOMString&gt;</code>.
        	</p>
		</section>
      </section>
      <section class="section" id="database-operations">
        <h3>Database operations</h3>
        <p>
          This section describes various operations done on the data in <a title="object store">object stores</a> and <a title="index">indexes</a>
          in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a>.
          <!-- and the <a>steps for synchronously executing a request</a> -->
        </p>
        <section class="section">
          <h4>Object Store Storage Operation</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> are as follows.
            The algorithm run by these steps takes four arguments:
            an object store <var>store</var>,
            a <var>value</var>,
            an optional <var>key</var>,
            and a <var>no-overwrite flag</var>.
          </p>
          <ol>
            <li>
              If <var>store</var> does use <a>in-line keys</a> and <a title="evaluate key path">evaluting</a>
              <a title="object store key path"><var>store</var>'s key path</a> on <var>value</var> does yield
              a value, then set <var>key</var> to that result.
            </li>
            <li>
              If <var>store</var> uses a <a>key generator</a> and <var>key</var> is undefined, set
              <var>key</var> to the next generated key. If <var>store</var> also uses <a>in-line keys</a>,
              then set the property in <var>value</var> pointed to by <var>store</var>'s
              <a title="object store key path">key path</a> to the new value for <var>key</var>, as shown in the
              <a>steps to assign a key to a value using a key path</a>. If the current number of a <a>key generator</a>
              reaches above the value <code>2^53</code> (<code>9007199254740992</code>)
              any attempt to use the <a>key generator</a> to generate a new <a>key</a> fails with a <a><code>ConstraintError</code></a>.
            </li>
            <li>
              If <var>store</var> uses a <a>key generator</a>, this <a>key generator</a> was not used to generate a value
              for <var>key</var> in the previous step, <var>key</var> is defined to a <code>Number</code>
              and this number is larger than, or equal to, the next key that <var>store</var>'s
              <a>key generator</a> would generate, change <var>store</var>'s <a>key generator</a> such that the next
              key it generates is the lowest integer larger than <var>key</var>.
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and
              a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
              this operation failed with a <a><code>ConstraintError</code></a>. Abort this algorithm without taking
              any further steps.
            </li>
            <li>
              If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
              remove the <a>record</a> from <var>store</var> using the <a>steps for deleting records from an object store</a>.
            </li>
            <li>
              Store a record in <var>store</var> containing <var>key</var> as its key and <var>object</var> as its
              value. The record is stored in the object store's <a title="object store record list">list</a> such
              that the list is sorted according key of the records in ascending order.
            </li>
            <li>
              If there are any <a title="index">indexes</a> which <a title="referenced">reference</a> <var>store</var>, perform the
              following sub steps on each such index.
              <ol>
                <li>
                  Set <var>index</var> to the index.
                </li>
                <li>
                  <a title="evaluate key path">Evaluate</a> <var>index</var>'s <a title="index key path">key path</a>
                  on <var>value</var>. If this does not yield a value, take no further actions for this index.
                  Otherwise set the result to <var>index key</var>.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is false or if <var>index key</var> is not an <code>Array</code>,
                  and if <var>index key</var> is not a <a>valid key</a>, take no further actions for this index.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is true, and <var>index key</var> is an <code>Array</code>,
                  remove any elements from <var>index key</var> that are not <a title="valid key">valid keys</a> and remove any duplicate
                  elements from <var>index key</var> such that only one instance of the duplicate value remains.
                  <p class="note">
                    For example, the following value of <var>index key</var> <code>[10, 20, null, 30, 20]</code> is converted to
                    <code>[10, 20, 30]</code>.
                  </p>
                  <p class="note">
                    After this step <var>index key</var> is or contains only <a title="valid key">valid keys</a>.
                  </p>
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is false, or if <var>index key</var> is not an <code>Array</code>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
                  and <var>index</var> has its <a>unique</a> flag set to true, then this operation failed with a
                  <a><code>ConstraintError</code></a>. Abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is true and <var>index key</var> is an <code>Array</code>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> any of the
                  values in <var>index key</var>, and <var>index</var> has its <a>unique</a> flag set to true, then this operation
                  failed with a <a><code>ConstraintError</code></a>. Abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is false, or if <var>index key</var> is not an <code>Array</code>,
                  then store a record in <var>index</var> containig <var>index key</var> as its key and <var>key</var> as its
                  value. The record is stored in <var>index</var>'s <a title="index record list">list of records</a> such
                  that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
                  order.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is true and <var>index key</var> is an <code>Array</code>,
                  then for each item in <var>index key</var> store a record in <var>index</var> containig
                  the items value as its key and <var>key</var> as its value. The records are stored in <var>index</var>'s
                  <a title="index record list">list of records</a> such that the list is sorted primarily on the records keys,
                  and secondarily on the records values, in ascending order.
                  <p class="note">
                    Note that it is legal for the <code>Array</code> to have length 0, in this case no records are added to
                    the index.
                  </p>
                  <p class="note">
                    If any of the items in the <code>Array</code> are themselves an <code>Array</code>, then the inner
                    <code>Array</code> is used as a key for that entry. In other words, <code>Array</code>s are not recursively
                    "unpacked" to produce multiple rows. Only the outer-most <code>Array</code> is.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              The result of this algorithm is <var>key</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an object store</dfn> are
            as follows. These steps MUST be run with two parameters - the record
            <a>key</a> and the <a>object store</a>.
          </p>

          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then retreive the <a>record</a>
              with key <var>key</var> from <var>store</var>. If <var>key</var> is a <a>key range</a>, then
              retreive the first <a>record</a> from <var>store</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              The result of this algorithm is a new <a>structured clone</a> of the value in the found record.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Index Referenced Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a referenced value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record
            key and the <a>index</a>.
          </p>

          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              Otherwise, the result of the operation is a <a>structured clone</a> of the <a>referenced value</a> of the found record.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Index Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record
            key and the <a>index</a>.
          </p>

          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              If a record was found, the result of this algorithm is the <a>value</a> of the found <a>record</a>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Deletion Operation</h4>
          <p>
            The <dfn>steps for deleting records from an object store</dfn> are as follows.
            The algorithm run by these steps takes two parameters: an object store <var>store</var> and
            a <var>key</var>.
          </p>
          <ol>
            <li>
              If the <var>key</var> parameter is a <a>key range</a> then let <var>range</var> be that <a>key range</a>.
              Otherwise, let <var>range</var> be a <a>key range</a> which containing only <var>key</var>.
            </li>
            <li>
               Remove all records, if any, from <var>store</var> with key <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>
              In all <a title="index">indexes</a> which <a title="referenced">reference</a> <var>store</var>, remove all
              <a title="record">records</a> whose value is <a title="in a key range">in</a> <var>range</var>, if any such records exist.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Clear Operation</h4>
          <p>
            The <dfn>steps for clearing an object store</dfn> are as follows.
            The algorithm run by these steps takes one parameter: an object store <var>store</var>.
          </p>
          <ol>
            <li>
               Remove all records from <var>store</var>.
            </li>
            <li>
              In all <a title="index">indexes</a> which <a title="referenced">reference</a> <var>store</var>, remove all
              <a title="record">records</a>.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Cursor Iteration Operation</h4>
          <p>
            The <dfn>steps for iterating a cursor</dfn> are as follows.
            The algorithm run by these steps takes two parameters: a <var>cursor</var> and optional
            <var>key</var> to iterate to.
          </p>
          <ol>
            <li>
              Let <var>source</var> be <var>cursor</var>'s <a title="cursor source">source</a>, let
              <var>records</var> be list of <a title="record">records</a> in <var>source</var>, let <var>direction</var>
              be <var>cursor</var>'s <a>direction</a>, let <var>position</var> be <var>cursor</var>'s
              <a>position</a>, let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>
              and let <var>range</var> be <var>cursor</var>'s <a>range</a>.
              <p class="note">
                <var>source</var> is always an <a>object store</a> or an <a>index</a>.
              </p>
              <p class="note">
                <var>records</var> is always sorted in ascending <a>key</a> order. In the case of
                <var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
                <a>value</a> order (where the value in an <a>index</a> is the <a>key</a> of the <a>record</a> in the referenced <a>object store</a>).
              </p>
            </li>

            <li>
              <p>
                If <var>direction</var> is <code>"next"</code>, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                  key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
                  <var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"nextunique"</code>, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"prev"</code>, let <var>found record</var> be the last record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                  key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
                  <var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"prevunique"</code>, let <var>temp record</var> be the last record in
                <var>records</var> which satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
                whose key is <a>equal to</a> <var>temp record</var>'s key.
              </p>
            </li>
            <li>
              If <var>found record</var> is not defined, set <var>cursor</var>'s <a title="cursor key">key</a> to <code>undefined</code>.
              If <var>source</var> is an <a>index</a>, set <var>cursor</var>'s <a>object store position</a> to <code>undefined</code>.
              If <var>cursor</var> implements <a>IDBCursorWithValue</a> or <a>IDBCursorWithValueSync</a>, then set
              <var>cursor</var>'s <a title="cursor value">value</a> to <code>undefined</code>.
              The result of this algorithm is <code>null</code>. Abort these steps.
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a>position</a> to <var>found record</var>'s key. If <var>source</var> is an <a>index</a>,
                set <var>cursor</var>'s <a>object store position</a> to <var>found record</var>'s value.
              </p>
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a title="cursor key">key</a> to <var>found record</var>'s key.
              </p>
              <p>
                If <var>cursor</var> implements <a>IDBCursorWithValue</a> or <a>IDBCursorWithValueSync</a>, then set
                <var>cursor</var>'s <a title="cursor value">value</a> to a <a>structured clone</a> of <var>found record</var>
                <a>referenced value</a>.
              </p>
            </li>
            <li>
              Set <var>cursor</var>'s <a>got value</a> flag to true.
              <p class="note">
                Once data has been successfully read, schedule a task which when run will
                set the <a title="cursor">cursor's</a> value and <a>fire a success event</a>.
              </p>
            </li>
            <li>
              The result of the algorithm is <var>cursor</var>.
            </li>
          </ol>
        </section>
      </section>
      <!-- end-content -->
    </section>
  </body>
</html>
