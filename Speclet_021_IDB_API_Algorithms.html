<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.41 2010/03/24 17:58:17 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graff", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" }
              { name: "Jeremy Orlow", url: "mailto:jorlow@google.com",
                company: "Google" }
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }

      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });

        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'},
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'},
                       sn.element('pre', {'class': 'code'},
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      window.onload = function() {
        examples();
        codeblocks();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>

    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>


      <!-- begin-content -->
      <section class="section" id="algorithms">
        <h3>Algorithms</h3>
        <section class="section" id="opening">
          <h4>Opening a database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are defined in the following steps. The algorithm in these steps
            takes three required arguments: an <var>origin</var>, which requested the <a>database</a> to be opened,
            a database <var>name</var>, and a database <var>version</var>. The algorithm also takes two optional
            arguments, a <var>request</var> which represents a <a>request</a> used when opening the database is done by using
            an asynchronous API or a <var>upgrade callback</var> which represents the callback used when opening the database
            is done by using the synchronous API.
          </p>
          
          <ol>
            <li>
              If these steps fail for any reason, return an error with the appropriate type and abort
              this algorithm.
            </li>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <!--<li>
              If <var>db</var> was found in the previous step, and it has a <a>version</a> higher than
              <var>version</var>, then abort these steps and return a <a><code>VERSION_ERR</code></a> error.
              Likewise, if at any point while running these steps, these steps are also running with the same
              <var>origin</var> and <var>name</var>, but with a higher <var>version</var>, abort these steps and
              return a <a><code>VERSION_ERR</code></a> error.
              <div class="note">
                <p>This can happen in for example the following four situations:</p>
                <ul>
                  <li>
                    The database already has a version higher than the version requested to be opened.
                  </li>
                  <li>
                    Another call to <code>open</code> with a higher version is already in progress, but is
                    waiting for other connections to be closed before being able to fire the
                    <code>upgradeneeded</code> event.
                  </li>
                  <li>
                    While this call is waiting for other connections to be closed before being able to firing
                    the <code>upgradeneeded</code> event, another call to <code>open</code> is made with a
                    higher version.
                  </li>
                  <li>
                    Two calls to open happen at the same time with different version numbers.
                  </li>
                </ul>
              </div>
            </li>-->
            <li>
              If <var>db</var> was found in previous step, wait until the following conditions are all fulfilled:
              <ul>
                <li>
                  No already existing <a>connection</a>s to <var>db</var>, have
                  non-<a title="transaction finish">finished</a> <code>"versionchange"</code> <a>transaction</a>.
                </li>
                <li>
                  If <var>db</var> has its <a>delete pending</a> flag set, wait until <var>db</var> has
                  been deleted.
                </li>
                <li>
                  These steps are not run for any other <a>connection</a>s with the same <var>origin</var>
                  and <var>name</var> but with a higher <var>version</var>.
                </li>
              </ul>
              <p class="note">
                If several connections with the same origin, name and version are opened at the same time,
                and that version is a higher version that the database's current version, then once any of
                those connections can proceed to the next step in this algorithm it will immediately start
                a <code>"versionchange"</code> transaction. This prevents the other connections from proceeding until that
                <code>"versionchange"</code> transaction is finished.
              </p>
              <p class="note">
                This means that if two databases with the same name and origin, but with different versions, are
                being opened at the same time, the one with the highest version will attempt to be opened first.
                If it is able to successfully open, then the one with the lower version will receive an error.
              </p>
            </li>
            <li>
              If no database with the given name from the origin <var>origin</var> was found, or if it was
              deleted during the previous step, then create a <a>database</a> with name <var>name</var>,
              with <code>0</code> as <a>version</a>, and with no <a>object store</a>s. Let <var>db</var>
              be the new database.
            </li>
            <li>
              If the <a>version</a> of <var>db</var> is higher than <var>version</var>, abort these steps and return
              a <code>DOMError</code> of type <a>VersionError</a>.
            </li>
            <li>
              Create a new <a>connection</a> to <var>db</var> and let <var>connection</var> represent it.
            </li>
            <li>
              If the <a>version</a> of <var>db</var> is lower than <var>version</var>, then run the
              <a>steps for running a <code>"versionchange"</code> transaction</a> using <var>connection</var>,
              <var>version</var>, <var>request</var> and <var>upgrade callback</var>.
            </li>
            <li>
              If the previous step resulted in an error, then return that error and abort these steps.
              If the <code>"versionchange"</code> transaction in the previous step was aborted, or if
              <var>connection</var> is <a title="database close">closed</a>, return a
              <code>DOMError</code> of type <a>AbortError</a> and abort these steps.
              In either of these cases, ensure that <var>connection</var> is <a title="database close">closed</a>
              by running the <a>steps for closing a database connection</a> before these steps are aborted.
            </li>
            <li>
              Return <var>connection</var>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Transaction Creation steps</h4>
          <p>
            When the user agent is to <dfn>create a <a>transaction</a></dfn>
            it MUST run the following steps. This algorithm takes five parameters:
            A <a><var>connection</var></a>, a <a><var>mode</var></a>, a list of <var>storeNames</var> of
            <a>object store</a>s to be included in the <a>scope</a> of the transaction, a
            <var>timeout</var> for the transaction <a title="transaction start">starting</a>,
            and a <var>callback</var> parameter for synchronously created transactions.
          </p>
          <ol>
            <li>
              If these steps are already running synchronously (a <a>transaction</a> was created within a
              <a title="transaction-callback">transaction callback</a>), throw a <code>DOMException</code> of type <a>InvalidStateError</a>.
            </li>
            <li>
              If <var>storeNames</var> is of type <code>DOMStringList</code> or <code>Array</code> leave it as is. Otherwise,
              interpret it as an <code>Array</code> with one value, and that value is the <a>stringified</a> version of
              <var>storeNames</var>. If any of the strings in <var>storeNames</var> identifies an <a>object store</a> which doesn't
              exist, throw a <code>DOMException</code> of type <a>NotFoundError</a>. If <var>storeNames</var> is an empty list
              throw a <code>DOMException</code> of type <a>InvalidAccessError</a>.
            </li>
            <li>
              If the <a>closePending</a> flag is set on <var>connection</var> the throw a <code>DOMException</code> of type <a>InvalidStateError</a>.
            </li>
            <li>
              <a title="transaction create">Create</a> a <a>transaction</a> using <var>connection</var> as
              <a>connection</a>, <var>mode</var> as <a>mode</a>, and the <a>object store</a>s identified in
              <var>storeNames</var> as <a>scope</a>.
            </li>
            <li>
              If these steps are running asynchronously, return the created <a>transaction</a> and queue up the the remaining steps. 
              When control is returned to the event loop, the implementation MUST set the <a>active</a> flag to false.
            </li>
            <li>
              Wait until the <a>transaction</a> can be <a title="transaction start">started</a> according to the
              <a>transaction lifetime</a> rules. If this takes longer than the specified <var>timeout</var> then
              a <code>DOMException</code> of type <a>TimeoutError</a> should be thrown.
              <p class="note">
                Because the asynchronous API always passes in a <var>timeout</var> of infinite, only the synchronous
                API will ever time out.
              </p>
            </li>
            <li>
              If these steps are running synchronously, the implementation MUST synchronously call <var>callback</var>
              with a single parameter which is the <a>transaction</a>. If an exception is thrown and not caught within the
              scope of the callback, the implementation MUST abort the <a>transaction</a> by following the <a>steps for
              aborting a transaction</a> using the <code>name</code> of the exception that was thrown as the <var>error</var>
              parameter, abort this algorithm without taking any further steps, and re-throw the exception.
            </li>
            <li>
              If these steps are running synchronously, the implementation MUST commit the transaction synchrnously.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for committing a transaction</h4>
          <p>
            When taking the <dfn>steps for committing a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes one parameter, the <var>transaction</var> to commit.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> the transaction uses are written to the <a>database</a>.
            </li>
            <li>
              If an error occurs while writing the changes to the <a>database</a>, abort the transaction by following
              the <a>steps for aborting a transaction</a> with the the <var>transaction</var> parameter set to <var>transaction</var>
              and the <var>error</var> parameter set to a value appropriate for the error, for example <code>QuotaExceededError</code>
              or <code>UnknownError</code>.
            </li>
            <li>
              Queue up an operation to dispatch an event at <a>transaction</a>. 
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"complete"</code>.
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
              <p class="note">
                Note that even if an exception is thrown from one of the event handlers of this event, the transaction is still
                committed since writing the database changes happens before the event takes places. Only after the transaction
                has been successfully written is the <code>"complete"</code> event fired.
              </p>
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for aborting a transaction</h4>
          <p>
            When taking the <dfn>steps for aborting a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes two parameter, the <var>transaction</var> to abort
            and an <var>error</var> name.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> the transaction uses are reverted. For <code>"versionchange"</code>
              transactions this includes changes to the set of <a>object store</a>s and <a>index</a>es, as well
              as the change to the <a>version</a>.
            </li>
            <li>
              Unless <var>error</var> was set to <code>null</code>, create a <code>DOMError</code> object and set its <code>name</code>
              to <var>error</var>. Set <var>transaction</var>'s <code>error</code> property to this newly created <code>DOMError</code>.
            </li>
            <li>
              If the transaction's <a>request list</a> contain any <a>request</a>s whose <a title="request done">done</a> flag
              is still false, abort the <a>steps for asynchronously executing a request</a> for each such request and queue
              a task to perform the following steps:
              <ol>
                <li>
                  Set the <a title="request done">done</a> flag on the <a>request</a> to true, set
                  <a title="request result">result</a> of the <a>request</a> to <code>undefined</code>
                  and set the request's <code>error</code> attribute to a <code>DOMError</code> with a type of <a>AbortError</a>.
                </li>
                <li>
                  <a>Fire an error event</a> at the <a>request</a>. However when running these
                  steps, ignore any request to run the <a>steps for aborting a transaction</a> as those steps are already running.
                </li>
              </ol>
              <p class="note">
                This does not always result in any <code>error</code> events being fired. For example if a transaction is aborted
                due to an error while <a title="commit">committing</a> the transaction, or if it was the last remaining request
                that failed.
              </p>
            </li>
            <li>
              Queue up an operation to dispatch an event at <var>transaction</var>.  
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"abort"</code>.
              The event does bubble but is not cancelable. 
              The <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for asynchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
            perform on a database.
          </p>
          <p>
            These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
            to is <a title="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with <var>source</var>.
            </li>
            <li>
              If <var>transaction</var> is not <a>active</a> throw a <code>DOMException</code> of type <a>TransactionInactiveError</a>.
            </li>
            <li>
              Create an <a>IDBRequest</a> object and set <var>request</var> to this object. Set <var>request</var>'s
              <a title="request source">source</a> to <var>source</var> and add <var>request</var> to the end of the
              <a title="request list">list</a> of <a>request</a>s in <var>transaction</var>. 
              Return this object and queue up the execution of the remaining steps in this algorithm. 
              <p class="note">
                Cursors override this step to reuse an existing <a>IDBRequest</a>. However they still put the
                <a>IDBRequest</a> at the end of the list of <a>request</a>s in <var>transaction</var>.
              </p>
            </li>
            <li>
              Wait until all previously added <a>requests<a> in <var>transaction</var> have their
              <a title="request done">done</a> flag set to true.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then set the <a title="request done">done</a> flag
              on the <var>request</var> to true, set <a title="request result">result</a> of the <var>request</var>
              to the result of the request and set the <code>error</code> attribute of the <var>request</var> to <code>undefined</code>.
			  Finally <a>fire a success event</a> at <var>request</var>.
            </li>
            <li>
              If performing <var>operation</var> failed then revert all changes made by <var>operation</var>,
              set the <a title="request done">done</a> flag on the <var>request</var> to true,
              set <a title="request result">result</a> of the <var>request</var>
              to <code>undefined</code> and set the <code>error</code> attribute on the <var>request</var>
              to the a <code>DOMError</code> with the same error type of the <var>operation</var> that failed.
              Finally <a>fire an error event</a> at <var>request</var>.
              <div class="note">
                This only reverts the changes done by this request, not any other changes made by the transaction.
              </div>
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for synchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for synchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
            perform on a database.
          </p>
          <ol>
            <li>
              If the <a>transaction</a> associated with <var>source</var> is not <a>active</a> throw a
              <code>DOMException</code> of type <a>TransactionInactiveError</a>.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then return the result of the operation.
            </li>
            <li>
              If performing <var>operation</var> failed, then throw a <code>DOMException</code> with the type 
              of error from the <var>operation</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for extracting a key from a value using a <a>key path</a></h4>
          <p>
            When taking the <dfn>steps for extracting a key from a value using a key path</dfn>, the implementation
            MUST run the following algorithm. The algorithm takes a <a>key path</a> named <var>keyPath</var> and a
            <a>value</a> named <var>value</var> and in some cases returns a <a>key</a> which may or may not be a
            <a>valid key</a>.
          </p>
          <ol>
            <li>
              If <var>keyPath</var> is an <code>Array</code>, then let <var>result</var> be newly constructed empty
              <code>Array</code>. For each item in the <var>keyPath</var> <code>Array</code>, perform the following
              substeps:
              <ol>
                <li>
                  Evaluate the <a>steps for extracting a key from a value using a key path</a> using the
                  item from the <var>keyPath</var> array as <var>keyPath</var> and <var>value</var> as <var>value</var>.
                </li>
                <li>
                  If the result of the previous step was not a valid <a>key path</a>, then abort the overall algorithm
                  and no value is returned.
                </li>
                <li>
                  Add the result of the first sub-step to end of the <var>result</var> array.
                </li>
              </ol>
              Return <var>result</var> as result of this algorithm and perform no additional steps.
              <p class="note">
                This will only ever "recurse" one level since keyPath arrays can't ever be nested.
              </p>
            </li>
            <li>
              If <var>keyPath</var> is the empty string, return <var>value</var> and skip the remaining steps.
            </li>
            <li>
              Let <var>remainingKeypath</var> be <var>keyPath</var> and <var>object</var> be <var>value</var>.
            </li>
            <li>
              If <var>remainingKeypath</var> has a period in it, assign <var>remainingKeypath</var> to be
              everything after the first period and assign <var>attribute</var> to be everything before that
              first period. Otherwise, assign<var>attribute</var>
              to be <var>remainingKeypath</var> and assign <var>remainingKeypath</var> to be null.
            </li>
            <li>
              If <var>object</var> does not have an attribute named <var>attribute</var>, then skip the rest of
              these steps and no value is returned.
            </li>
            <li>
              Assign <var>object</var> to be the value of the attribute named <var>attribute</var> on <var>object</var>.
            </li>
            <li>
              If <var>remainingKeypath</var> is not null, go to step 3.
            </li>
            <li>
              Return <var>object</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4><code>"versionchange"</code> transaction steps</h4>
          <p>
            The <dfn>steps for running a <code>"versionchange"</code> transaction</dfn> are
            as follows. This algorithm takes two required parameters - a <var>connection</var> object which is used
            to update the <a>database</a> a new <var>version</var> to be set for the <a>database</a>.
            The algorithm also takes two optional arguments, a <var>request</var> which represents a <a>request</a>
            used when the asynchronous API is used, or a <var>upgrade callback</var> which
            represents the callback used when the synchronous API is used.
          </p>
          <ol>
            <li>
              Let <var>openDatabases</var> be the set of all <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
              objects, except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <var>version</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just the <a><code>IDBDatabase</code></a>
                object itself.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If running asynchronously and any of the <a>connection</a>s in <var>openDatabases</var> are still not closed, 
                queue up a <code>blocked</code> event for the <var>request</var>. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <var>version</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just <var>request</var>.
              </p>
            </li>
            <li id="version-change-close-block">
              Wait until either all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">If .close() is called immediately but a <a>transaction</a> associated with the <var>connection</var>
              keeps running for a "long time", should we also fire a <code>blocked</code> event?</p>
              <p class="issue">If, while we're waiting here, someone calls open with a version number higher than <var>version</var>,
              we should probably let that upgrade run first and bail here if it was successful</p>
            </li>
            <li>
              Create a new <a>transaction</a> with <a>mode</a> set to <code>"versionchange"</code> and <var>connection</var> used as <a>connection</a>.
              The <a>scope</a> of the transaction includes every <a>object store</a> in <var>connection</var>. Set its
              <a>active</a> flag to false. Let <var>transaction</var> represent this transaction.
            </li>
            <li>
              Start <var>transaction</var>. Note that until this <a>transaction</a> is finished,
              no other <a>connection</a>s can be opened to the same <a>database</a>.
            </li>
            <li>
              Let <var>old version</var> be <var>database</var>'s <a>version</a>.
            </li>
            <li>
              Set the version of <var>database</var> to <var>version</var>. This change is considered part of the
              <a>transaction</a>, and so if the transaction is <a>abort</a>ed, this change is reverted.
              If the <code>"versionchange"</code> <a>transaction</a> fails to commit set the <var>version</var> attribute on the database to <code>undefined</code>.  
            </li>
            <li>
              If running asynchronously, schedule a task to run the following steps:
              <ol>
                <li>
                  Set the <a><code>result</code></a> property of <var>request</var> to <var>connection</var>.
                </li>
                <li>
                  Set the <code>transaction</code> property of <var>request</var> to <var>transaction</var>.
                </li>
                <li>
                  Fire a <a><code>upgradeneeded</code></a> event targeted at <var>request</var>. The event MUST use the
                  <a><code>IDBVersionChangeEvent</code></a> interface and have the
                  <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>old version</var>
                  and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                  property set to <var>version</var>. 
                  The <a class="idlType" href="#widl-IDBRequest-readyState"><code>readyState</code></a> 
                  on the <a>request</a> is set to <code>"done"</code>.
                </li>
                <li>
                  If an exception was propagated out from any event handler while dispatching the event in the previous step, abort
                  the transaction by following the <a>steps for aborting a transaction</a> with the <var>error</var> property set to
                  <code>AbortError</code>.
                </li>
                <li>
                	If for any reason the <code>"versionchange"</code> transaction is aborted while in the
                        <a href="#widl-IDBOpenDBRequest-onupgradeneeded"><code>onupgradeneeded</code></a> event handler 
                	while the database is being created for the first time, the database will remain in the system with the default attributes.  
                	If the transaction is aborted and there is an existing database, the values remain unchanged.
               		The default attributes for the <a>IDBDatabase</a> are:
                		<table>
			          		<tr>
			          			<th>Attribute</th>
			          			<th>Value</th>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-name"><code>name</code></a></td>
			          			<td>the <var>name</var> provided to <a href="#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version"><code>IDBFactory.open</code></a></td>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-version"><code>version</code></a></td>
			          			<td> <code>0</code> (zero)</td>
			          		</tr>
			          		<tr>
			          			<td><a href="#widl-IDBDatabase-objectStoreNames"><code>objectStoresNames</code></a></td>
			          			<td>null</td>
			          		</tr>
                		</table>
                </li>
              </ol>
            </li>
            <li>
              If running synchronously, call <var>upgrade callback</var> and pass it <var>transaction</var> as the first argument
              and <var>old version</var> the second argument.
            </li>
            <li>
              Follow the normal steps for executing a <a><code>transaction</code></a> and let the <a><code>transaction</code></a>
              finish normally.
            </li>
            <li>
              When the transaction is finished, if these steps are run asynchronously, immediately set <var>request</var>'s
              <code>transaction</code> property to <code>null</code>. This MUST be done in the same task as the task firing the
              <code>complete</code> or <code>abort</code> event, but after those events has been fired.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Database closing steps</h4>
          <p>The <dfn>steps for closing a database connection</dfn> are as follows. These steps take one argument, a <var>connection</var> object.
          <ol>
            <li>
              Set the internal <a><code>closePending</code></a> flag of <var>connection</var> to true.
            </li>
            <li>
              Wait for all transactions <a title="transaction create">created</a> using <var>connection</var> to complete.
              Once they are complete, <var>connection</var> is <dfn title="database close">closed</dfn>.
            </li>
          </ol>
          <p class="note">
            Once the <a><code>closePending</code></a> flag has ben set to true no new transactions can be
            <a title="transaction create">created</a> using <var>connection</var>. All functions that
            <a title="transaction create">create</a> transactions first check the the <a>closePending</a> flag first and
            throw an exception if it is true.
          </p>
          <p class="note">
            Once the <a>connection</a> is closed, this can unblock the <a>steps for running a <code>"versionchange"</code>
            transaction</a>, and the <a>steps for deleting a database</a>, which <a href="#delete-close-block">both</a>
            <a href="#version-change-close-block">wait</a> for <a>connection</a>s to a given <a>database</a> to be closed
            before continuing.
          </p>
        </section>
        <section class="section">
          <h4>Database deletion steps</h4>
          <p>
            The <dfn>steps for deleting a <a>database</a></dfn> are as follows. The algorithm in these steps
            take three arguments. An <var>origin</var> which requested the <a>database</a> to be deleted,
            a database <var>name</var>. It also optionally takes a <var>request</var> which represents
            a <a>request</a> used when deleting the database is done using an asynchronous API.
          </p>
          <ol>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <li>
              If no database was found, then these steps are considered successful. Abort these steps.
            </li>
            <li>
              Set <var>db</var>'s <a>delete pending</a> flag to true.
            </li>
            <li>
              Let <var>openDatabases</var> be the set of all <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
              objects connected to <var>db</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If any of the <a>connection</a>s in <var>openDatabases</var> are still not closed, and <var>request</var> was provided,
                fire a <code>blocked</code> event at <var>request</var>. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> property set to <var>db</var>'s
                <a>version</a> and have the <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a>
                property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
            </li>
            <li id="delete-close-block">
              Wait until all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">Should we allow <code>blocked</code> to be fired here too, if waiting takes "too long"?</p>
            </li>
            <li>
              Delete <var>db</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire a success event</h4>
          <p>
            To <dfn>fire a success event</dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <a>request</a>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"success"</code>.
              The event does not bubble or be cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> using <var>transaction</var> as
              <var>transaction</var> parameter, and <code>AbortError</code> as <var>error</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire an error event</h4>
          <p>
            To <dfn title="fire an error event">fire an error event</dfn> at a <a><var>request</var></a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <var>request</var>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"error"</code>.
              The event does bubble and is cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>. The event's <a>default action</a> is to abort the
              <var>transaction</var> by running <a>steps for aborting a transaction</a> using <var>transaction</var> as <var>transaction</var>
              and the <code>name</code> of <a>request</a>'s <code>error</code> property as <var>error</var>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> using <var>transaction</var> as
              <var>transaction</var> parameter, and <code>AbortError</code> as <var>error</var>.
            </li>
          </ol>
        </section>
        <section class="section">
        	<h4>Steps to assign a key to a value using a key path</h4>
        	<p>
        		The <dfn>steps to assign a key to a value using a key path</dfn> are as follows:
        	</p>
        	<ol>
        		<li>
        			Let <var>remainingKeypath</var> be <var>keyPath</var> and <var>object</var> be <var>value</var>.
        		</li>
        		<li>
        			If <var>object</var> is not an <code>Object</code> object or an <code>Array</code> object (see <a>structured clone algorithm</a> 
        			[[!HTML5]]), then throw a <code>DOMException</code> of type <code>DataError</code>.

        		</li>
        		<li>
        			If <var>remainingKeypath</var> has a period in it, assign <var>remainingKeypath</var> to be everything after the first period, 
        			and assign <var>attribute</var> to be everything before that first period. Otherwise, go to step 7.
        		</li>
        		<li>
        			If <var>object</var> does not have an attribute named <var>attribute</var>, then create the attribute and assign it an empty object.
        		</li>
        		<li>
        			Assign <var>object</var> to be the value of the attribute named <var>attribute</var> on <var>object</var>.
        		</li>
        		<li>
        			Go to step 2.
        		</li>
        		<li>
        			<div class="note">The steps leading here ensure that <var>remainingKeyPath</var> is a single attribute name 
        			(that is, a string without periods) by this step. The steps also ensure that <var>object</var> 
        			is an <code>Object</code> or an <code>Array</code>, and not a <code>Date</code>, <code>RegExp</code>, <code>Blob</code>, 
        			or other nonsupported type.
					</div>
        		</li>
        		<li>
        			Let <var>attribute</var> be <var>remainingKeyPath</var>.
        		</li>
        		<li>
        			Set an attribute named <var>attribute</var> on <var>object</var> with the value <var>key</var>.
        		</li>
        	</ol>
        	<p class="note">
        		The intent is that these steps are only executed if evaluating the <a>key path</a> did not yield a value. 
        		In other words, before you run these steps, first evaluate the <a>key path</a> against <var>value</var>, 
        		and only if that does not yield a value (where 'undefined' does count as a value) do you generate a key and 
        		use these steps to modify <var>value</var> to contain the generated key.
        	</p>
		</section>        
      </section>
      <section class="section" id="database-operations">
        <h3>Database operations</h3>
        <p>
          This section describes various operations done on the data in <a>object store</a>s and <a>index</a>es
          in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a> and
          the <a>steps for synchronously executing a request</a>.
        </p>
        <section class="section">
          <h4>Object Store Storage Operation</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> are as follows. 
            The algorithm run by these steps takes four parameters: an object store <var>store</var>,
            a <var>value</var>, an optional <var>key</var>, and a <var>no-overwrite flag</var>.
          </p>
          <ol>
            <li>
              If <var>store</var> does use <a>in-line keys</a> and <a title="evaluate key path">evaluting</a>
              <a title="object store key path"><var>store</var>'s key path</a> on <var>value</var> does yield
              a value, then set <var>key</var> to that result.
            </li>
            <li>
              If <var>store</var> uses a <a>key generator</a> and <var>key</var> is undefined, set
              <var>key</var> to the next generated key. If <var>store</var> also uses <a>in-line keys</a>,
              then set the property in <var>value</var> pointed to by <var>store</var>'s
              <a title="object store key path">key path</a> to the new value for <var>key</var>, as shown in the 
              <a>steps to assign a key to a value using a key path</a>.
            </li>
            <li>
              If <var>store</var> uses a <a>key generator</a>, this <a>key generator</a> was not used to generate a value
              for <var>key</var> in the previous step, <var>key</var> is defined to a <code>long</code>
              or a <code>float</code> and this number is larger than, or equal to, the next key that <var>store</var>'s
              <a>key generator</a> would generate, change <var>store</var>'s <a>key generator</a> such that the next
              key it generates is the lowest integer larger than <var>key</var>.
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and 
              a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              terminate these steps and set the <code>error</code> attribute to
              a <code>DOMError</code> of type <a>ConstraintError</a> 
              and abort this algorithm without taking any further steps.
            </li>
            <li>
              If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              remove the <a>record</a> from <a>store</a> using the <a>steps for deleting records from an object store</a>.
            </li>
            <li>
              Store a record in <var>store</var> containing <var>key</var> as its key and <var>object</var> as its
              value. The record is stored in the the object store's <a title="objec store record list">list</a> such
              that the list is sorted according key of the records in ascending order.
            </li>
            <li>
              If there are any <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, perform the
              following sub steps on each such index.
              <ol>
                <li>
                  Set <var>index</var> to the index.
                </li>
                <li>
                  If <var>index</var>'s <a title="index key path">key path</a> is a string, then
                  <a title="evaluate key path">evaluate</a> it on
                  <var>value</var>. If this does not yield a value don't take any further actions for this index.
                  Otherwise set the result to <var>index key</var>.
                </li>
                <li>
                  If <var>index</var>'s <a title="index key path">key path</a> is an <code>Array</code>, then set
                  <var>index key</var> to a newly created empty <code>Array</code>. For each item in
                  <var>index</var>'s <a title="index key path">key path</a> <a title="evaluate key path">evaluate</a>
                  the item on <var>value</var>. If this does not yield a value don't take any further actions for this index.
                  Otherwise add the value to the end of the <var>index key</var> <code>Array</code>.
                </li>
                <li>
                  <div class="note">
                    The places invoking these steps ensures that <var>index key</var> is always a <a>valid key</a> by the time
                    we get to this step.
                  </div>
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is false, or if <var>index key</var> is not an <code>Array</code>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
                  and <var>index</var> has it's <a>unique</a> flag set to true, then 
                  set the <code>error</code> attribute to a <code>DOMError</code> of type <a>ConstraintError</a>
                  and abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is true and <var>index key</var> is an <code>Array</code>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> any of the
                  values in <var>index key</var>, and <var>index</var> has it's <a>unique</a> flag set to true, then set 
                  set the <code>error</code> attribute to a <code>DOMError</code> of type <a>ConstraintError</a>
                  and abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is false, or if <var>index key</var> is not an <code>Array</code>,
                  then store a record in <var>index</var> containig <var>index key</var> as its key and <var>key</var> as its
                  value. The record is stored in <var>index</var>'s <a title="index record list">list of records</a> such
                  that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
                  order.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry</a> flag is true and <var>index key</var> is an <code>Array</code>,
                  then for each item in <var>index key</var> store a record in <var>index</var> containig
                  the items value as its key and <var>key</var> as its value. The records are stored in <var>index</var>'s
                  <a title="index record list">list of records</a> such that the list is sorted primarily on the records keys,
                  and secondarily on the records values, in ascending order.
                  <div class="note">
                    Note that it is legal for the <code>Array</code> to have length 0, in this case no records are added to
                    the index.
                  </div>
                  <div class="note">
                    If any of the items in the <code>Array</code> are themselves an <code>Array</code>, then the inner
                    <code>Array</code> is used as a key for that entry. In other words, <code>Array</code>s are not recursively
                    "unpacked" to produce multiple rows. Only the outer-most <code>Array</code> is.
                  </div>
                </li>
              </ol>
            </li>
            <li>
              The result of this algorithm is <var>key</var>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an object store</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>object store</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then retreive the <a>record</a>
              with key <var>key</var> from <var>store</var>. If <var>key</var> is a <a>key range</a>, then
              retreive the first <a>record</a> from <var>store</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              The result of this algorithm is a new <a>structured clone</a> of the value in the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Referenced Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a referenced value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              Otherwise, the result of the operation is a <a>structured clone</a> of the <a>referenced value</a> of the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              If a record was found, the result of this algorithm is the <a>value</a> of the found <a>record</a>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Deletion Operation</h4>
          <p>
            The <dfn>steps for deleting records from an object store</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: an object store <var>store</var> and
            a <var>key</var>.
          </p>
          <ol>
            <li>
              If the <var>key</var> parameter is a <a>key range</a> then let <var>range</var> be that <a>key range</a>.
              Otherwise, let <var>range</var> be a <a>key range</a> which containing only <var>key</var>.
            </li>
            <li>
               Remove all records, if any, from <var>store</var> with key <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>
              In all <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, remove all
              <a>records</a> whose value is <a title="in a key range">in</a> <var>range</var>, if any such records exist.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Clear Operation</h4>
          <p>
            The <dfn>steps for clearing an object store</dfn> are as follows. 
            The algorithm run by these steps takes one parameter: an object store <var>store</var>.
          </p>
          <ol>
            <li>
               Remove all records from <var>store</var>.
            </li>
            <li>
              In all <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, remove all
              <a>records</a>.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Cursor Iteration Operation</h4>
          <p>
            The <dfn>steps for iterating a cursor</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: a <var>cursor</var> and optional
            <var>key</var> to iterate to.
          </p>
          <ol>
            <li>
              Let <var>source</var> be <var>cursor</var>'s <a title="cursor source">source</a>, let
              <var>records</var> be list of <a>records</a> in <var>source</var>, let <var>direction</var>
              be <var>cursor</var>'s <a>direction</a>, let <var>position</var> be <var>cursor</var>'s
              <a>position</a>, let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>
              and let <var>range</var> be <var>cursor</var>'s <a>range</a>.
              <p class="note">
                <var>source</var> is always an <a>object store</a> or an <a>index</a>.
              </p>
              <p class="note">
                <var>records</var> is always sorted in ascending <a>key</a> order. In the case of
                <var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
                <a>value</a> order.
              </p>
            </li>

            <li>
              <p>
                If <var>direction</var> is <code>"next"</code>, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                  key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
                  <var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"nextunique"</code>, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"prev"</code>, let <var>found record</var> be the last record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                  key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
                  <var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is <code>"prevunique"</code>, let <var>temp record</var> be the last record in
                <var>records</var> which satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
                whose key is <a>equal to</a> <var>temp record</var>'s key.
              </p>
            </li>
            <li>
              If <var>found record</var> is not defined, set <var>cursor</var>'s <a title="cursor key">key</a> and <a>primary key</a> to
              <code>undefined</code>.
              If <var>cursor</var> implements <a>IDBCursorWithValue</a> or <a>IDBCursorWithValueSync</a>, then set
              <var>cursor</var>'s <a title="cursor value">value</a> to <code>undefined</code>.
              The result of this algorithm is <code>null</code>. Abort these steps.
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a>position</a> to <var>found record</var>'s key. If <var>source</var> is an <a>index</a>,
                set <var>cursor</var>'s <a>object store position</a> to <var>found record</var>'s value.
              </p>
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a title="cursor key">key</a> to <var>found record</var>'s key.
              </p>
              <p>
                If <var>cursor</var> implements <a>IDBCursorWithValue</a> or <a>IDBCursorWithValueSync</a>, then set
                <var>cursor</var>'s <a title="cursor value">value</a> to a <a>structured clone</a> of <var>found record</var>
                <a>referenced value</a>.
              </p>
            </li>
            <li>
              Set <var>cursor</var>'s <a>got value</a> flag to true.
              <p class="note">
                Once data has been successfully read, schedule a task which when run will 
                set the <a title="cursor">cursor's</a> value and <a>fire a success event</a>.
              </p>
            </li>
            <li>
              The result of the algorithm is <var>cursor</var>.
            </li>
          </ol>
        </section>
      </section>
      <!-- end-content -->
    </section>
  </body>
</html>
