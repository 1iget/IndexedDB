<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.41 2010/03/24 17:58:17 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graff", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" }
              { name: "Jeremy Orlow", url: "mailto:jorlow@google.com",
                company: "Google" }
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }

      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });

        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'},
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'},
                       sn.element('pre', {'class': 'code'},
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      window.onload = function() {
        examples();
        codeblocks();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>

    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>


      <!-- begin-content -->
      <section class="section" id="algorithms">
        <h3>Algorithms</h3>
        <section class="section" id="opening">
          <h4>Opening the database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are as follows. The algorithm in these steps
            take two arguments. A <var>origin</var> which requested the <a>database</a> to be opened,
            a database <var>name</var>. It also optionally takes a <var>request</var> which represents
            a <a>request</a> used when opening the database is done using an asynchronous API.
          </p>
          
          <ol>
            <li>
              If these steps fail for any reason, return a error with the appropriate code and abort
              this algorithm.
            </li>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <li>
              If <var>db</var> was found in the previous step, wait until no already existing
              <a>connection</a>s to <var>db</var>, have non-<a title="transaction finish">finished</a>
              VERSION_CHANGE <a>transaction</a>s. If <var>db</var> has its <a>delete pending</a> flag set, wait
              until <var>db</var> has been deleted.
              <p class="note">
                There can potentially be several <a>connection</a>s waiting for a VERSION_CHANGE transaction
                to finish. Once that transaction <a title="transaction finish">finishes</a> another <a>connection</a>
                could be created and a new VERSION_CHANGE transaction could be started before these steps has
                a chance to continue. In that case the implementation MUST keep waiting at this step. Similarly,
                at any point while waiting for VERSION_CHANTE transactions to finish, the <a>delete pending</a> flag
                could be set. In that case the implementation MUST keep waiting at this step until <var>db</var> has
                been deleted.
              </p>
            </li>
            <li>
              If no database with the given name from the origin <var>origin</var> was found, or if it was
              deleted during the previous step, then create a <a>database</a> with name <var>name</var>,
              with the empty string as <a>version</a>, and with no <a>object store</a>s. Let <var>db</var>
              be the new database.
            </li>
            <li>
              Create a <a>connection</a> to <var>db</var> and return it.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Transaction Creation steps</h4>
          <p>
            When the user agent is to <dfn>create a <a>transaction</a></dfn>
            it MUST run the following steps. This algorithm takes four parameters:
            A <a><var>connection</var></a>, a <a><var>mode</var></a>, a list of <var>names</var> of
            <a>object store</a>s to be included in the <a>scope</a> of the transaction, and a
            <var>timeout</var> for the transaction <a title="transaction start">starting</a>.
          </p>
          
          <ol>
            <li>
              If any of the strings in <var>names</var> identifies an <a>object store</a> which doesn't
              exist, throw a NOT_FOUND_ERR exception. If the <a>closePending</a>
              flag is set on <var>connection</var> the throw a NOT_ALLOWED_ERR.
            </li>
            <li>
              <a title="transaction create">Create</a> a <a>transaction</a> using <var>connection</var> as
              <a>connection</a>, <var>mode</var> as <a>mode</a>, and the <a>object store</a>s identified in
              <var>names</var> as <a>scope</a>.
            </li>
            <li>
              If these steps are running asynchronously, return the created <a>transaction</a> and run the
              remaining steps asynchronously. When control is returned to the event loop, the implementation
              MUST set the <a>active</a> flag to false.
            </li>
            <li>
              Wait until the <a>transaction</a> can be <a title="transaction start">started</a> according to the
              <a>transaction lifetime</a> rules. If this takes longer than the specified <var>timeout</var> then
              a TIMEOUT_ERR exception error should be thrown.
              <p class="note">
                Because the asynchronous API always passes in a <var>timeout</var> of infinite, only the synchronous
                API will ever time out.
              </p>
            </li>
            <li>
              If these steps are running synchronously, return the created <a>transaction</a>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for committing a transaction</h4>
          <p>
            When taking the <dfn>steps for committing a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes one parameter, the <var>transaction</var> to commit.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> the transaction uses are written to the <a>database</a>.
            </li>
            <li>
              Asynchronously dispatch an event at <var>transaction</var>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"commit"</code>.
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for aborting a transaction</h4>
          <p>
            When taking the <dfn>steps for aborting a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes two parameter, the <var>transaction</var> to abort
            and a <var>code</var>.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> the transaction uses are reverted. For VERSION_CHANGE
              transactions this includes changes to the set of <a>object store</a>s and <a>index</a>es, as well
              as the change to the <a>version</a>.
            </li>
            <li>
              If the transaction's <a>request list</a> contain any <a>request</a>s whose <a title="request done">done</a> flag
              is still false, abort the <a>steps for asynchronously executing a request</a> for each such transaction and queue
              a task to perform the following steps:
              <ol>
                <li>
                  Set the <a title="request done">done</a> flag on the <a>request</a> to true, set
                  <a title="request result">result</a> of the <a>request</a> to <code>undefined</code>
                  and set <a title="request errorCode">errorCode</a> of the <a>request</a> to <code>ABORT_ERR</code>.
                </li>
                <li>
                  <a>Fire an error event</a> at the <a>request</a>.
                </li>
              </ol>
            </li>
            <li>
              Asynchronously dispatch an event at <var>transaction</var>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"abort"</code>.
              The event does bubble but is not cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for asynchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and a <var>operation</var> to
            perform on a database.
          </p>
          <p>
            These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
            to is <a title="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with <var>source</var>.
            </li>
            <li>
              If <var>transaction</var> is not <a>active</a> throw a TRANSACTION_INACTIVE_ERR exception.
            </li>
            <li>
              Create a <a>IDBRequest</a> object and set <var>request</var> to this object. Set <var>request</var>'s
              <a title="request source">source</a> to <var>source</var> and add <var>request</var> to the end of the
              <a title="request list">list</a> of <a>request</a>s in <var>transaction</var>. Return
              this object and run the remaining steps in this algorithm asynchronously.
              <p class="note">
                Cursors override this step to reuse an existing <a>IDBRequest</a>. However they still put the
                <a>IDBRequest</a> at the end of the list of <a>request</a>s in <var>transaction</var>.
              </p>
            </li>
            <li>
              Wait until all previously added <a>requests<a> in <var>transaction</var> have their
              <a title="request done">done</a> flag set to true.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then set the <a title="request done">done</a> flag
              on the <var>request</var> to true, set <a title="request result">result</a> of the <var>request</var>
              to the result of the request and set <a title="request errorCode">errorCode</a> of the <var>request</var>
              to <var>NO_ERR</var>. Finally <a>fire a success event</a> at <var>request</var>.
            </li>
            <li>
              If performing <var>operation</var> failed then revert all changes made by <var>operation</var>,
              set the <a title="request done">done</a> flag on the <var>request</var> to true,
              set <a title="request result">result</a> of the <var>request</var>
              to <code>undefined</code> and set <a title="request errorCode">errorCode</a> of the <var>request</var>
              to the code of the error from <var>operation</var>. Finally <a>fire an error event</a> at <var>request</var>.
              <div class="note">
                This only reverts the changes done by this request, not any other changes made by the transaction.
              </div>
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for synchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for synchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and a <var>operation</var> to
            perform on a database.
          </p>
          <ol>
            <li>
              If the <a>transaction</a> associated with <var>source</var> is not <a>active</a> throw a
              TRANSACTION_INACTIVE_ERR exception.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then return the result of the operation.
            </li>
            <li>
              If performing <var>operation</var> failed then throw a IDBDatabaseException with the code
              of the error from <var>operation</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>VERSION_CHANGE transaction steps</h4>
          <p>
            The <dfn>steps for running a <code>VERSION_CHANGE</code> transaction</dfn> are
            as follows. This algorithm takes two parameters - a <var>connection</var> object which is used
            to update the <a>database</a> and a new <var>version number</var> to be set for the <a>database</a>.
          </p>
          <ol>
            <li>
              Create a new <a>transaction</a> with <a>mode</a> set to VERSION_CHANGE and <var>connection</var> used as <a>connection</a>.
              The <a>scope</a> of the transaction includes every <a>object store</a> in <var>connection</var>. Set its
              <a>active</a> flag to false.
            </li>
            <li>
              If running asynchronously, create a new <a>request</a> which uses the <a>IDBVersionChangeRequest</a> interface, return it, and
              run the remaining steps in this algorithm asynchronously.
            </li>
            <li>
              Let <var>openDatabases</var> be the set of all <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
              objects, except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <var>version number</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just the <a><code>IDBDatabase</code></a>
                object itself.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If running asynchronously and any of the <a>connection</a>s in <var>openDatabases</var> are still not closed, fire a
                <code>blocked</code> event at <var>request</var>. The event MUST use the <a><code>IDBVersionChangeEvent</code></a> interface
                and have the <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <var>version number</var>.
                This event MUST NOT bubble or be cancelable. The propagation path for the event is just <var>request</var>.
              </p>
            </li>
            <li id="VERSION_CHANGE-close-block">
              Wait until either all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a> or <var>connection</var> has its
              <a><code>closePending</code></a> flag set to <code>true</code>.
              <p class="issue">If .close() is called immediately but a <a>transaction</a> associated with the <var>connection</var>
              keeps running for a "long time", should we also fire a <code>blocked</code> event?</p>
            </li>
            <li>
              If <var>connection</var> has its <a><code>closePending</code></a> flag set to <code>true</code>, 
              abort the transaction by following the <a>steps for aborting a transaction</a> and abort this algorithm without taking
              any further steps.
            </li>
            <li>
              Start the <a>transaction</a> that will be used during the version change. Note that until this <a>transaction</a> is finished, no other <a>connection</a>s
              can be opened to the same <a>database</a>.
            </li>
            <li>
              Set the version of <var>database</var> to the given <var>version number</var>. This change is considered part of the
              <a><code>transaction</code></a>, and so if the transaction is <a>abort</a>ed, this change is reverted.
            </li>
            <li>
              If running asynchronously, fire a <a><code>success</code></a> event targeted at the <var>request</var> object. The <a><code>result</code></a>
              propety of the event should be set to a new <a><code>IDBTransaction</code></a> object representing the
              <a><code>VERSION_CHANGE</code></a> transaction created in step 4. If running synchronously, return the <a><code>IDBTransactionSync</code></a> 
              created in step 4 to the caller.
            </li>
            <li>
              Follow the normal steps for executing a <a><code>transaction</code></a> and let the <a><code>transaction</code></a>
              finish normally.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Database closing steps</h4>
          <p>The <dfn>steps for closing a database connection</dfn> are as follows. These steps take one argument, a <var>connection</var> object.
          <ol>
            <li>
              Set the internal <a><code>closePending</code></a> flag of <var>connection</var> to true.
            </li>
            <li>
              Wait for all transactions <a title="transaction create">created</a> using <var>connection</var> to complete.
              Once they are complete, <var>connection</var> is <dfn title="database close">closed</dfn>.
            </li>
          </ol>
          <p class="note">
            Once the <a><code>closePending</code></a> flag has ben set to true no new transactions can be
            <a title="transaction create">created</a> using <var>connection</var>. All functions that
            <a title="transaction create">create</a> transactions first check the the <a>closePending</a> flag first and
            throw an exception if it is true.
          </p>
          <p class="note">
            Once the <a>connection</a> is closed, this can unblock the <a>steps for running a <code>VERSION_CHANGE</code>
            transaction</a>, and the <a>steps for deleting a database</a>, which <a href="#delete-close-block">both</a>
            <a href="#VERSION_CHANGE-close-block">wait</a> for <a>connection</a>s to a given <a>database</a> to be closed
            before continuing.
          </p>
        </section>
        <section class="section">
          <h4>Database deletion steps</h4>
          <p>
            The <dfn>steps for deleting a <a>database</a></dfn> are as follows. The algorithm in these steps
            take three arguments. A <var>origin</var> which requested the <a>database</a> to be deleted,
            a database <var>name</var>. It also optionally takes a <var>request</var> which represents
            a <a>request</a> used when deleting the database is done using an asynchronous API.
          </p>
          <ol>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <li>
              If no database was found, then these steps are considered successful. Abort these steps.
            </li>
            <li>
              Set <var>db</var>'s <a>delete pending</a> flag to true.
            </li>
            <li>
              Let <var>openDatabases</var> be the set of all <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
              objects connected to <var>db</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If any of the <a>connection</a>s in <var>openDatabases</var> are still not closed, and <var>request</var> was provided,
                fire a <code>blocked</code> event at <var>request</var>. The event MUST use the <a><code>IDBVersionChangeEvent</code></a>
                interface and have the <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <code>null</code>.
                This event MUST NOT bubble or be cancelable.
              </p>
            </li>
            <li id="delete-close-block">
              Wait until all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">Should we allow <code>blocked</code> to be fired here too, if waiting takes "too long"?</p>
            </li>
            <li>
              Delete <var>db</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire a success event</h4>
          <p>
            To <dfn>fire a success event</dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <a>request</a>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"success"</code>.
              The event does not bubble or be cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>. However if <var>transaction</var> is null, then the
              <a>propagation path</a> is simply <var>request</var>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire an error event</h4>
          <p>
            To <dfn title="fire a error event">fire a error event at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch an event at <a>request</a>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to <code>"error"</code>.
              The event does bubble and is cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>. The event's <a>default action</a> is to abort the
              <var>transaction</var> by running <a>steps for aborting a transaction</a>. However if <var>transaction</var>
              is null, then the <a>propagation path</a> is simply <var>request</var>, there is no <a>default action</a> and
              is not cancelable.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a>.
            </li>
          </ol>
          <p class="issue">
            TODO: need to define more error handling here.
          </p>
        </section>
      </section>
      <section class="section" id="database operations">
        <h3>Database operations</h3>
        <p>
          This section describes various operations done on the data in <a>object store</a>s and <a>index</a>es
          in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a> and
          the <a>steps for synchronously executing a request</a>.
        </p>
        <section class="section">
          <h4>Object Store Storage Operation</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> are as follows. 
            The algorithm run by these steps takes four parameters: a object store <var>store</var>,
            a <var>value</var>, an optional <var>key</var>, and a <var>no-overwrite flag</var>.
          </p>
          <ol>
            <li>
              If <var>store</var> uses a <a>key generator</a> set and <var>key</var> is undefined, set
              <var>key</var> to the next generated key. If <var>store</var> also uses <a>in-line keys</a>,
              then set the property in <var>value</var> pointed to by <var>store</var>'s
              <a title="object store key path">key path</a> to the new value for <var>key</var>
            </li>
            <li>
              If <var>store</var> does not use a <a>key generator</a> but does use <a>in-line keys</a>, then set
              <var>key</var> to the the result of <a title="evaluate key path">evaluting</a>
              <a title="object store key path"><var>store</var>'s key path</a> on <var>value</var>.
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and 
              a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              terminate these steps and set error code to
              <a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a>
              and abort this algorithm without taking any further steps.
            </li>
            <li>
              If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              remove the <a>record</a> from <a>store</a> using the <a>steps for deleting a record from an object store</a>.
            </li>
            <li>
              Store a record in <var>store</var> containing <var>key</var> as its key and <var>object</var> as its
              value. The record is stored in the the object store's <a title="objec store record list">list</a> such
              that the list is sorted according key of the records in ascending order.
            </li>
            <li>
              If there are any <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, perform the
              following sub steps on each such index.
              <ol>
                <li>
                  Set <var>index</var> to the index.
                </li>
                <li>
                  <a title="evaluate key path">Evaluate</a> <var>index</var>'s <a title="index key path">key path</a> on
                  <var>value</var>. If this does not yield a value don't take any further actions for this index.
                  Otherwise set the result to <var>index key</var>.
                  <div class="note">
                    The places invoking these steps ensures that <var>index key</var> is always a <a>valid key</a> at this
                    point.
                </li>
                <li>
                  If <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
                  and <var>index</var> has it's <a>unique</a> flag set to true, then set error code to CONSTRAINT_ERR and
                  abort this algorithm without taking any further steps.
                </li>
                <li>
                  Store a record in <var>index</var> containig <var>index key</var> as its key and <var>key</var> as its
                  value. The record is stored in <var>index</var>'s <a title="index record list">list of records</a> such
                  that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
                  order.
                </li>
              </ol>
            </li>
            <li>
              The result of this algorithm is <var>key</var>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an object store</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>object store</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then retreive the <a>record</a>
              with key <var>key</var> from <var>store</var>. If <var>key</var> is a <a>key range</a>, then
              retreive the first <a>record</a> from <var>store</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              The result of this algorithm is a new <a>structured clone</a> of the value in the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Referenced Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a referenced value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              Otherwise, the result of the operation is a <a>structured clone</a> of the <a>referenced value</a> of the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found, the result of this algorithm is <code>undefined</code>.
            </li>
            <li>
              If a record was found, the result of this algorithm is the <a>value</a> of the found <a>record</a>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Deletion Operation</h4>
          <p>
            The <dfn>steps for deleting a record from an object store</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: a object store <var>store</var> and
            a <var>key</var>.
          </p>
          <ol>
            <li>
              If no <a>record</a> exists with key <var>key</var> in <var>store</var>,
              then the result of this algorithm is <code>false</code> and no more steps in this
              algorithm are executed.
            </li>
            <li>
               Remove the record from <var>store</var> with key <var>key</var>.
            </li>
            <li>
              In all <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, remove all
              <a>records</a> with value <var>key</var>.
            </li>
            <li>
              The result of this algorithm is <code>true</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Clear Operation</h4>
          <p>
            The <dfn>steps for clearing an object store</dfn> are as follows. 
            The algorithm run by these steps takes one parameter: a object store <var>store</var>.
          </p>
          <ol>
            <li>
               Remove all records from <var>store</var>.
            </li>
            <li>
              In all <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, remove all
              <a>records</a>.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Cursor Iteration Operation</h4>
          <p>
            The <dfn>steps for iterating a cursor</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: a <var>cursor</var> and optional
            <var>key</var> to iterate to.
          </p>
          <ol>
            <li>
              Let <var>source</var> be <var>cursor</var>'s <a title="cursor source">source</a>, let
              <var>records</var> be list of <a>records</a> in <var>source</var>, let <var>direction</var>
              be <var>cursor</var>'s <a>direction</a>, let <var>position</var> be <var>cursor</var>'s
              <a>position</a>, let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>
              and let <var>range</var> be <var>cursor</var>'s <a>range</a>.
              <p class="note">
                <var>source</var> is always a <a>object store</a> or a <a>index</a>.
              </p>
              <p class="note">
                <var>records</var> is always sorted in ascending <a>key</a> order. In the case of
                <var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
                <a>value</a> order.
              </p>
            </li>

            <li>
              <p>
                If <var>direction</var> is NEXT, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is a <a>object store</a>, the record's
                  key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
                  <var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is NEXT_NO_DUPLICATE, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is PREV, let <var>found record</var> be the last record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is a <a>object store</a>, the record's
                  key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
                  <var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is PREV_NO_DUPLICATE, let <var>temp record</var> be the last record in
                <var>records</var> which satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
                whose key is <a>equal to</a> <var>temp record</var>'s key.
              </p>
            </li>
            <li>
              If <var>found record</var> is not defined, the result of this algorithm is <code>undefined</code>. Abort these steps.
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a>position</a> to <var>found record</var>'s key. If <var>source</var> is a <a>index</a>,
                set <var>cursor</var>'s <a>object store position</a> to <var>found record</var>'s value.
              </p>
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a title="cursor key">key</a> to <var>found record</var>'s key.
              </p>
              <p>
                If <var>cursor</var> was created using <a href="#widl-IDBIndex-openCursor"><code>IDBIndex.openCursor</code></a> or
                <a href="#widl-IDBIndexSync-openCursor"><code>IDBIndexSync.openCursor</code></a>, then set
                <var>cursor</var>'s <a title="cursor value">value</a> to a <a>structured clone</a> of <var>found record</var>
                <a>referenced value</a>. Otherwise, set <var>cursor</var>'s <a title="cursor value">value</a> to the value of <var>found record</var>.
              </p>
            </li>
            <li>
              Set <var>cursor</var>'s <a>got value</a> flag to true.
              <p class="issue">
                This should only be done right before firing the success event. Not asynchronously before. Not sure
                how/where to express that.
              </p>
            </li>
            <li>
              The result of the algorithm is <var>cursor</var>.
            </li>
          </ol>
        </section>
      </section>
      <!-- end-content -->
    </section>
  </body>
</html>
