<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.41 2010/03/24 17:58:17 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graf", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" },
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }

      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });

        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'},
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'},
                       sn.element('pre', {'class': 'code'},
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      window.onload = function() {
        examples();
        codeblocks();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>

	    <section id='introduction' class='section informative'>
      <h2>Introduction</h2>

	
      <p>
        User agents need to store large numbers of objects locally in
        order to satisfy off-line data requirements of Web applications.
        [[WEBSTORAGE]] is useful for
        storing pairs of keys and their corresponding values. However, it does 
        not provide in-order retrieval of keys, efficient searching over
        values, or storage of duplicate values for a key. 
      </p>
      
      <p>
        This specification provides a concrete API to perform advanced key-value data management
        that is at the heart of most sophisticated query processors. It does
        so by using transactional databases to store keys and their 
        corresponding values (one or more per key), and providing a means
        of traversing keys in a deterministic order. This is often implemented
        through the use of persistent B-tree data structures that are considered
        efficient for insertion and deletion as well as in-order traversal of
        very large numbers of data records.
      </p>
      
      <div class="example">
        <p>
          A script can efficiently find records in an object store that come 
          closest to the required value provided the value is stored in either 
          a primary or a secondary key.
          In the following example, the 'books' object store holds data about
          books which are stored by their 'isbn' attribute. Additionally, 
          an index is maintained on the 'author' attribute of the objects
          stored in the object store. This index can be used to look up books
          for a given author. If an exact match is not found, the operation
          raises an exception.
        </p>
        <codeblock>var db = indexedDB.open('books', 'Book store', false);
if (db.version !== '1.0') {
  var olddb = indexedDB.open('books', 'Book store');
  olddb.createObjectStore('books', 'isbn');
  olddb.createIndex('BookAuthor', 'books', 'author', false);
  olddb.setVersion("1.0");  
}
// db.version === "1.0";  
var index = db.openIndex('BookAuthor');
var matching = index.get('fred');
if (matching)
  report(matching.isbn, matching.name, matching.author);
else
  report(null);</codeblock>
        <p>
        The next example performs the exact same logic as above asynchronously.
        </p>
        <codeblock>
  function findFred() {
    var store = db.objectStore('books');
    var index = store.index('BookAuthor');
    var req = index.get('fred');
    req.onsuccess = function(event) {
      var matching = event.result;
      report(matching.isbn, matching.name, matching.author);
    }
    req.onerror = function(event) {
      report(null);
    }
  }

  var db;
  var dbRequest = indexedDB.open('books', 'Book store');
  dbRequest.onsuccess = function(event) {
    db = event.result;
    if (db.version != "1.0") {
      var versionRequest = db.setVersion("1.0");
      versionRequest.ontimeout = function(event) {
        throw new Error("timeout trying to set version to 1.0");
      }
      versionRequest.onsuccess = function(event) {
        var store = db.createObjectStore('books', 'isbn');
        store.createIndex('BookAuthor', 'books', 'author', false);
        event.transaction.onabort = function(event) {
          throw new Error("error while trying to set version to 1.0");
        }
        event.transaction.oncomplete = function(event) {
          findFred(db);
        }
      }
    } else {
      findFred(db);
    }
  }
   
        </codeblock>
        <!--p>
        Here is an example of a script using this API. First, a function
        <code>prepareDatabase()</code> is defined. This function tries to create 
        the database if necessary, giving it one object store called "docids" with
        the primary key "id". If it is successful, or if the table
        doesn't need creating, it calls the function that does the
        actual work, in this case <code>showDocCount()</code>.
        </p>
        <codeblock>
var request = null;
function prepareDatabase(ready, error) {
  request = new <a>IDBDatabaseRequest</a>();
  request.<a>onsuccess</a> = ready;
  request.<a>onerror</a> = error;
  var upgrade = 
    function(changes, db) {
      changes.<a>createObjectStore</a>('docids', 'id');
      // now db.<a>version</a> === '1.0'
    };
  request.<a>open</a>('documents', '1.0', 'Offline document storage', upgrade);
}

function showDocCount(db, span) {
  var storeRequest = new <a>IDBObjectStoreRequest</a>(db);
  storeRequest.<a>onsuccess</a> = 
    function() {
      var store = storeRequest.<a>store</a>, total = 0;
      var cursorRequest = new <a>IDBCursorRequest</a>(store);
      cursorRequest.<a>onsuccess</a> = 
        function() {
          span.textContent = total;
        };
      cursorRequest.<a>open</a>(function(record, cursor) { 
          total += cursor.<a>count</a>; 
        }, <a>IDBCursor</a>.<a>NEXT_NO_DUPLICATE</a>);
    };
  storeRequest.<a>open</a>('docids', true);
};

prepareDatabase(function(evt) {
  // got database
  var span = document.getElementById('doc-count');
  showDocCount(request.<a>database</a>, span);
  }, function (evt) {
  // error getting database
  var error = request.error;
  alert(error.message);
});</codeblock-->
      </div>
    </section>

    <section id='conformance' class='section'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt><dfn id='dfn-conforming-user-agent'>Conforming user agent</dfn></dt>
        <dd>
          <p>
            A user agent MUST behave as described in this specification
            in order to be considered conformant.
          </p>
          
          <p>
            User agents MAY implement algorithms given in this
            specification in any way desired, so long as the end result is
            indistinguishable from the result that would be obtained by the
            specification's algorithms.
          </p>
          
          <p>
            A conforming Indexed Database API user agent MUST also be a
            <em>conforming implementation</em> of the IDL fragments
            of this specification, as described in the
            “Web IDL” specification. [[!WEBIDL]]
          </p>
          
          <div class="note">
            This specification uses both the terms "conforming user agent(s)" 
            and "user agent(s)" to refer to this product class.
          </div>
        </dd>
      </dl>        
      
      <section class="section" id="dependencies">
        <h3>Dependencies</h3>
        <p>
          This specification relies on several other underlying specifications. 
        </p>
        <dl>
          <dt>HTML5</dt>
          <dd>The terms and algorithms <dfn id="document-base-url">document base URL</dfn>,
            <dfn id="event-handler-attributes">event handler attributes</dfn>, 
            <dfn id="event-handler-event-type">event handler event type</dfn>,
            <dfn title="Function"><code>Function</code></dfn>,
            <dfn>origin</dfn>, <dfn>same origin</dfn>, <dfn>structured clone</dfn>,
            <dfn>structured clone algorithm</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>, 
            and <dfn title="queue-a-task">queue a task</dfn> are defined by the HTML 5 
            specification [[!HTML5]].
          </dd>
          <dt>WebWorkers</dt>
          <dd>The term <dfn title="Worker"><a class="externalDFN"><code>Worker</code></a></dfn> is defined by
          the WebWorkers specification [[!WEBWORKERS]].</dd>
        </dl>
      </section>
    </section>


    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>
	        <section id="constructs" class="section">
      <h3>Constructs</h3>
       <section id="database-concept" class="section">
          <h4>Database</h4>
          <p>
            Each <a>origin</a> has an associated set of 
            <a title="database">databases</a>. A <dfn>database</dfn> comprises
            one or more <a title="object store">object stores</a> which hold the data stored
            in the database.
          </p>
          <p>
            Every <a>database</a> has a <dfn title="database name">name</dfn> which identifies it
            within a specific <a>origin</a>. The name can be any string value, including the empty string, and
            stays constant for the lifetime of the database. Each <a>database</a> also has a current
            <dfn>version</dfn>. When a database is first created, its <a>version</a> is the empty string.
          </p>
          <p class="note">
            Implementations MUST support all names. If a implementation
            uses a storage mechanism which can't handle arbitrary database names,
            the implementation must use an escaping mechanism or something similar
            to map the provided name to a name that it can handle.
          </p>
          <div class="note">
            Each <a>database</a> has one version at a time; a <a>database</a> 
            can't exist in multiple versions at once. The only way to change the version is using a VERSION_CHANGE
            <a>transaction</a>.
          </div>
          <p>
            The act of opening a <a>database</a> creates a <dfn>connection</dfn>. There MAY be multiple 
            <a>connection</a>s to a given <a>database</a> at any given time. Each connection has a
            <dfn>closePending</dfn> flag which initially is set to false.
          </p>
          <p>
            When a <a>connection</a> is initially created it is in <var>opened</var> state. The connection
            can be <dfn title="database close">closed</dfn> through several means. If the connection is GCed
            or execution context where the <a>connection</a> is created is destroyed (for example due to the
            user navigating away from that page), the connection is closed. The connection can also be closed
            explicitly using the <a>steps for closing a database connection</a>. When the connection is closed
            the <a>closePending</a> flag is always set to true if it hasn't already been.
          </p>
          <p>
            The <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
            interfaces represent a <a>connection</a> to a <a>database</a>. 
          </p>
        </section>  <!-- IDBDatabase -->

        <section class="section" id="object-store-concept">  
          <h4>Object Store</h4>
          <p>
            An <dfn>object store</dfn> is the primary storage mechanism for storing data in a
            <a>database</a>.
          </p>
          <p>
            Each database contain a set of <a>object store</a>s. The set of <a>object store</a>s
            can be changed, but can only be changed using a VERSION_CHANGE transactions. When a new database is
            created it doesn't contain any <a>object store</a>s and has the empty string as <a>version</a>.
          </p>
          <p>
            The object store has a <a title="object store record list">list of records</a> which hold the
            data stored in the object store. Each <dfn>record</dfn> consists of a <dfn>key</dfn> and a <dfn>value</dfn>.
            The list is sorted according to key in ascending order. There can never be multiple records in a given object
            store with the same key.
          </p>
          <p>
            Every <a>object store</a> has a <dfn title="object store name">name</dfn>.
            The name is unique within the <a>database</a> to which it belongs. Every object store also optionally has a
            <a>key generator</a> and a optional <dfn title="object store key path">key path</dfn>.
            If the object store has a key path it is said to use <dfn>in-line keys</dfn>. Otherwise it is said to
            use <dfn>out-of-line</dfn> keys.
          </p>
          <p>
            The object store can derive the <a>key</a> from one of three sources. Which source is used is determined
            when the object store is created. The three sources are:
          </p>
          <ol>
            <li>
              A <dfn>key generator</dfn>. A key generator generates a monotonically increasing numbers every time
              a key is needed.
              <p class="issue">
                specify that generators are not shared between stores.
              </p>
            </li>
            <li>
              A <dfn>key path</dfn>. A key path points to a property in a given <a>value</a>. When a object store uses a
              <a>key path</a> to generate keys, the key is the property in the stored <a>value</a> pointed to by the
              <a>key path</a>.
              <p class="issue">
                Need to specify how a key path is parsed and how a "evaluated" against a value. Including the requirement
                that the value needs to be a object and that the property must be enumerated.
              </p>
            </li>
            <li>
              Keys can also be explicitly specified when a <a>value</a> is stored in the object store.
            </li>
          </p>
          <!--div class="ednote">
            The detached reading behavior MAY need more explanation.
            What is detached reading?
          </div-->
          <p>
            The <a><code>IDBObjectStore</code></a> and <a><code>IDBObjectStoreSync</code></a>
            interfaces represent a <a>object store</a>. Note however that multiple instances of those
            interfaces representing the same <a>object store</a> can exist.
          </p>
        </section> <!-- Object store -->

        <section id="key-construct" class="section">
          <h4>Keys</h4>
          <p>
            In order to efficiently retrieve <a>record</a>s stored in an indexed database,
            each <a>record</a> is organized according to its key. A value is said to be a <dfn>valid key</dfn>
            if it is one of the following types: IDL data types
            <code>DOMString</code>, <code>long</code>, and <code>float</code> [[!WEBIDL]]; the
            <code>Date</code> JavaScript object [[!ECMA-262]]; as well as the value <code>null</code>.
            Additionally, if the value os of type <code>float</code>, it is only a <a>valid key</a> if it is not NaN.
            <a>Conforming user agents</a> MUST support all <a>valid key</a>s as keys.
          </p>
          <p class="note">
            Inifinite <code>float</code> values are <a>valid key</a>s.
          </p>
          <p>
            For purposes of comparison, all <code>DOMString</code> values are evaluated as greater than 
            <code>long</code>, <code>float</code>, and <code>Date</code> values; <code>Date</code> values are evaluated as greater than <code>long</code> 
            and <code>float</code> values; and <code>long</code> and <code>float</code> values are evaluated by their numeric 
            value with no need to separate them by type. Moreover, <code>null</code> always evaluates 
            less than any other key value that is a non-null value.
          </p>
          <p>
            The terms <dfn>greater than</dfn>, <dfn>less than</dfn> and <dfn>equal to</dfn> is defined in the terms of
            the above comparisons.
          </p>
          <p class="note">
            Only data types with natural ordering can be used as keys. 
            The ECMAScript <code>undefined</code> MUST NOT be used as a key.
          </p>
        </section>
        
        <section id="value-construct" class="section">
          <h4>Values</h4>
          <p>
            Each record is associated with a <dfn>value</dfn>. <a>Conforming user agents</a> MUST support
            any value supported by the <a>structured clone algorithm</a> 
            [[!HTML5]]. This includes simple types such as <code>DOMString</code>
            and <code>Date</code> as well as <code>Object</code> and <code>Array</code>
            instances.
          </p>
        </section>
        
        <section id="index-concept" class="section">
          <h4>Index</h4>
          <p>
            It is sometimes useful to retreive <a>records</a> in a <a>object store</a> through other means
            than their <a>key</a>. A <dfn>index</dfn> allows looking up <a>record</a>s in a <a>object store</a>
            using properties of the <a>value</a>s in the <a>object store</a>s <a>record</a>s.
          </p>
          <p>
            An index is a specialized persistent key-value storage and has a <dfn>referenced</dfn> <a>object store</a>.
            The index has a <dfn title="index record list">list of records</dfn> which hold the
            data stored in the index. The records in an index are automatically populated whenever records in the
            <a>referenced</a> object store are inserted, updated or deleted. There can be several <a>index</a>es
            referencing the same <a>object store</a>, in which changes to the object store cause all such indexes
            to get updated.
          </p>
          <p>
            The values in the index's <a>record</a>s are always values of <a>keys</a> in the index's <a>referenced</a>
            object store. The keys are derived from the referenced object store's <a>value</a>s using a <dfn title="index key path"><a>key path</a></dfn>.
            If a given <a>record</a> with key <var>X</var> in the object store referenced by the index has the value <var>A</var>, and
            <a title="evaluate key path">evaluting</a> the <a title="index key path">index's key path</a> on <var>A</var> yields the result
            <var>Y</var>, then the index will contain a record with key <var>Y</var> and value <var>X</var>.
          </p>
          <p>
            Records in an index are said to have a <dfn>referenced value</dfn>. This is the value of the record in the index's referenced
            object store which has a key equal to the index's record's value. So in the example above,
            the record in the index whose key is <var>Y</var> and value is <var>X</var> has a <a>referenced value</a> of <var>A</var>.
          </p>
          <p class="note">
            Each record in an index reference one and only one record in the index's <a>referenced</a> object store. However there can be
            multiple records in an index which reference the same record in the object store. And there can also be no records in an index
            which reference a given record in an object store.
          </p>
          <p class="issue">
            Some of the statements in the note are only true once we've implemented decisions made at TPAC.
          </p>
          <p>
            The <a>record</a>s in an index are always sorted according to the <a>record</a>s key. However unlike object stores,
            a given index can contain multiple records with the same key. Such records are additionally sorted according to
            the records value.
          </p>
          <p>
            A index contains a <dfn>unique</dfn> flag. When this flag is set to true, the index enforces that no two <a>record</a>s
            in the index has the same key. If a <a>record</a> in the index's referenced object store is attempted to be inserted or
            modified such that evaluating the index's key path on the records new value yields a result which already exists in the
            index, then the attempted modification to the object store fails.
          </p>
          <p>
            The <a><code>IDBIndex</code></a> and <a><code>IDBIndexSync</code></a> interfaces
            provide access to the metadata of an <a>index</a>. Note however that multiple instances of those
            interfaces representing the same <a>index</a> can exist.
          </p>
        </section> <!-- IDBIndex -->
        
        <section id="transaction-concept" class="section">
          <h4>Transaction</h4>
          <p>
            A <dfn>transaction</dfn> is used to interact with the data in a <a>database</a>.
            Whenever data is read or written to the database this is done using a <a>transaction</a>.
          </p>
          <p>
            All transactions are created using a <a>connection</a>.
            The transaction has a <a>mode</a> which determines which types of interactions can be performed
            using the transaction. The <a>mode</a> is set when the transaction is created and remains
            constant for the lifetime of the transaction. The transaction also has a <dfn>scope</dfn> which
            determines which <a>object store</a>s the transaction can interact with. Finally, transactions
            have a <dfn>active</dfn> flag, which determines if new <a>request</a>s can currently be placed
            against the transaction. Finally, transactions also contain a <dfn>request list<dfn> of
            <a>request</a>s which have been placed against the transaction.
          </p>
          <p>
            Transactions are either static or dynamic which determines if the <a>scope</a> of the transaction
            can change during the lifetime of the transaction. <dfn>Static</dfn> transactions have a constant
            scope which is determined when the transaction is created and remains contant for the lifetime of
            the transaction. <dfn>Dynamic</dfn> transactions scope can change during the lifetime of the
            transaction.
          </p>
          <p class="issue">TODO: decide what happens when dynamic transactions need to lock a database
            object that is already exclusively locked by another transaction.
          </p>
          <p>
            <a title="transaction">Transactions</a> offer some protection from 
            application and system failures. A <a>transaction</a> may be used to
            store multiple data records or to conditionally modify certain data 
            records. A <a>transaction</a> represents an atomic and durable set 
            of data access and mutation operations. 
          </p>
          <p>
            <a title="transaction">Transactions</a> are expected to be short lived. This is encouraged
            using the automatically committing functionality described below. Authors can still cause
            transactions to run for a long time, however this is generally not a usage pattern which
            is recommended and can lead to bad user experience in some implementations.
          </p>
          <p>
            The <dfn title="transaction lifetime">lifetime</dfn> of a <a>transaction</a> is as follows:
          </p>
          <ol>
            <li>
              A transaction is <dfn title="transaction create">created</dfn> using of one of the available explicit
              APIs, for example <a class="idlType" href="#widl-IDBDatabase-transaction">IDBDatabase.transaction</a>.
              Which constructor is used, and the arguments passed to that constructor, determines if the transaction
              is <a>static</a> or <a>dynamic</a>, as well as which <a>mode</a> the transaction uses. If the transaction
              is <a>static</a>, the constructor arguments also determine what the <a>scope</a> of the transaction is.
              When a transaction is created its <a>active</a> flag is initially set to true.
            </li>
            <li>
              The implementation MUST allow <a>request</a>s to be <a title="place request">placed</a> against the transaction
              whenever the <a>active</a> flag is true. This is the case even if the transaction has not yet been
              <a title="transaction start">started</a>. Until the transaction is <a title="transaction start">started</a>
              the implementation MUST NOT execute these requests, but the implementation MUST still keep track of the
              <a>request</a>s and their order. Requests may only be placed against the transaction while the transaction
              is <a>active</a>. If a request is attempted to be placed against a transaction when it is not
              <a>active</a>, the implementation MUST reject the attempt by throwing a TRANSACTION_INACTIVE_ERR exception.
            </li>
            <li>
              Once an implementation is able to enforce the constraints defined for the <a>mode</a> of
              the transaction, defined below, the implementation MUST asynchronously
              <dfn title="transaction start">start</dfn> the transaction. When this happens is affected
              by the <a>mode</a> in which the transaction is opened, and which <a>object store</a>s are
              included in <a>scope</a> of the transaction.
            </li>
            <li class="issue">
              <p>
                Should we also define that if an implementation can't run two transactions at the same time,
                it MUST <a title="transaction start">start</a> them in the order they were
                <a title="transaction create">created</a>. Maybe only specify this if they have any overlapping
                <a>scope</a>. If we don't do this then starting two write transactions at the same time could
                result in the second one that's created running before the first one that is created.
              </p>
              <p>
                At least we need to ensure that a READ_ONLY transaction which is created after a READ_WRITE
                transaction has started sees the data that the READ_WRITE transaction wrote, and not a snapshot
                of what the object store looked like before the READ_WRITE transaction was started.
              </p>
              <p>
                Might be best to define this as part of the <a>mode</a> restrictions.
              </p>
            </li>
            <li>
              Once the transaction has been <a title="transaction start">started</a> the implementation can
              start executing the <a>request</a>s placed against the transaction. Unless otherwise defined requests
              MUST be executed in the order they are placed against the transaction. Likewise, their result MUST
              be returned in the order the request was placed against a specific transaction.
              There is no guarentee about the order that results from requests in different transactions are returned.
              Similarly, the isolation <a>mode</a> ensure that it doesn't matter which order requests placed against
              different transactions are executed.
            </li>
            <li>
              At any time a transaction can be <dfn>abort</dfn>ed, even if the transaction isn't currently
              <a>active</a>. When a transaction is aborted the implementation MUST undo (roll back) any changes
              made to the <a>database</a> using the transaction. This includes both changes to the contents of
              <a>object store</a>s as well as additions and removals of <a>object store</a>s and <a>index</a>es.
              <p class="note">
                A transaction can be aborted at any time before it is <a title="transaction finish">finished</a>.
                Including if it isn't <a>active</a> or hasn't yet
                <a title="transaction start">started</a>.
            </li>
            <li>
              Once a transaction no longer can become <a>active</a>, and if the transaction
              hasn't been <a>abort</a>ed, the implementation MUST automatically attempt to
              <dfn title="commit">commit</dfn> it. This usually happens after all requests placed against the
              transaction has been executed and their returned results handled, but no new requests has been placed
              against the transaction. When a transaction is committed implementation MUST atomically write
              any changes to the <a>database</a> made by requests placed against the transaction. That is, either all
              of the changes MUST be written, or if an error occurs, such as a disk write error, the implementation
              MUST NOT write any of the changes to the database. If such an error occurs the implementation MUST
              <a>abort</a> the transaction.
            </li>
            <li>
              When a transaction is <a>commit</a>ted or <a>abort</a>ed, it is said to be
              <def title="transaction finish">finished</def>. If a transaction can't be finished, for example
              due to the implementation crashing or the user taking some explicit action to cancel it, the
              implementation MUST <a>abort</a> the transaction.
            </li>
          </ol>
          <p>
            Transactions are opened in one of three <dfn title="mode">modes</dfn>. The mode
            determine how concurrent access to <a>object store</a>s in the transaction is isolated.
          </p>
          <ol>
            <li><code><dfn>READ_ONLY</dfn></code></li>
            <li><code><dfn>READ_WRITE</dfn></code></li>
            <li><code><dfn>VERSION_CHANGE</dfn></code></li>
          </ol>

          <p>
            The transaction <a>mode</a> determines both which operations are allowed to be performed
            during the transaction, as well whether two transactions can run concurrently or not.
            Which operations are allowed be be performed are defined in detail below, but in general
            transactions opened in <code><a>READ_ONLY</a></code> mode are only allowed to perform
            reading operations which does not change data. READ_WRITE transactions are allowed to
            perform reading and writing transactions to existing <a>object store</a>s, where as
            VERSION_CHANGE transactions are allowed to perform any operations, including ones that
            delete and create <a>object store</a>s and <a>index</a>es.
          </p>
          
          <p>
            A VERSION_CHANGE transaction can never run concurrently with other transactions. When
            a VERSION_CHANGE transaction is created, the implementation MUST wait to
            <a title="transaction start">start</a> the VERSION_CHANGE transaction until no other transactions
            against the same <a>database</a> are running. As long as the VERSION_CHANGE transaction, the implementation
            MUST wait with <a title="transaction start">starting</a> any other transactions against the same <a>database</a>
            until the VERSION_CHANGE transaction is finished.
          </p>
          <p>
            Any number of transactions opened in <a>READ_ONLY</a> mode are allowed to run concurrently,
            even if the transaction's <a>scope</a> overlap and include the same <a>object store</a>s.
            As long as a READ_ONLY transaction is running, the data that the implementation returns
            through <a>request</a>s created with that transaction MUST remain
            constant. That is, two requests to read the same piece of data MUST yield the same result
            both for the case when data is found and the result is that data, and for the case when data
            is not found and a lack of data is indicated.
          </p>
          <p>
            There are a number of ways that an implementation ensure this. It can prevent
            READ_WRITE transactions whose scope overlap the scope of the READ_ONLY transaction from
            starting until the READ_ONLY transaction is finished. Or it can allow the READ_ONLY
            transaction to see a snapshot of contents of the <a>object store</a>s which is taken when
            the READ_ONLY transaction is started.
          </p>
          <p>
            Similarly, implementations MUST ensure that a READ_WRITE transaction is only affected by
            changes to <a>object store</a>s that are made using the transaction itself. I.e. the
            implementation MUST ensure that another transaction does not modify the contents of
            <a>object store</a>s in the READ_WRITE transactions <a>scope</a>. The implementation
            MUST also ensure that if the READ_WRITE transaction completes successfully, that the
            changes written to <a>object store</a>s using the transaction can be comitted to the
            <a>database</a> without merge conflicts. An implementation MUST NOT abort a transaction
            due to merge conflicts.
          </p>
          <p>
            A result of these requirements is that an implementation MUST NOT allow two READ_WRITE
            transactions access the same <a>object store</a> at the same time. Even to perform just
            read operations. One implementation strategy is to never start a READ_WRITE transaction
            until all other READ_WRITE transactions with overlapping <a>scope</a>s have finished.
          </p>
          <p class="issue">
            TODO: This requirement could be tightened further. Currently two READ_WRITE transactions
            with <b>partially</b> overlapping scopes can run in paralell, until both (or "the second") of
            them touch object stores in the overlapping scope.
          </p>
          <p>
            User agents MUST ensure a reasonable level of fairness across transactions to prevent
            starvation. For example if multiple READ_ONLY transaction are started one after another
            the implementation MUST ensure that that doesn't indefinitely prevent a pending READ_WRITE
            transaction from <a title="transaction start">starting</a>.
          </p>
          <p>
            Conforming user agents MUST automatically abort a <a>transaction</a> at
            the end of the scope in which it was created, if an exception is propagated to that scope.
          </p>
          <p>
            Static <a>transaction</a> objects implement the 
            <a><code>IDBTransaction</code></a> or the
            <a><code>IDBTransactionSync</code></a> interfaces.
          </p>
          <p>
             Dynamic <a>transaction</a> objects implement the 
            <a><code>IDBDynamicTransaction</code></a> or the
            <a><code>IDBDynamicTransactionSync</code></a> interfaces.
          </p>
          <div class="issue">
            <p>Define dynamic transactions if we agree they should be part of this specification.</p>
          </div>
        </section> <!-- IDBTransaction -->

        <section class="section" id="request-concept">
          <h4>Requests</h4>
          <p>
            Each reading and writing operation on a <a>database</a> is done using a <dfn>request</dfn>.
            Every request represents one read or write operation. <a>Request</a>s are always belong to
            a <a>transaction</a>. The only exception to this is the request created when a <a>connection</a>
            is opened. <a>Request</a>s have a <dfn title="request done"><var>done</var></dfn> flag which
            initially is false, and a <dfn title="request source">source</dfn> object.
          </p>
          <p>
            When a request is created, it is always <dfn title="place request">placed</a> against a
            <a>transaction</a> using either the <a>steps to a asynchronously execute a request</a> or
            the <a>steps to a synchronously execute a request</a>.
        </section>

        <section class="section" id="range-concept">
          <h4>Key Range</h4>
          <p>
            Records can be retrived from <a>object store</a>s and <a>index</a>es
            using either <a>key value</a>s or <dfn>key range</dfn>s. A 
            key range is a continuous interval over some data type 
            used for keys.
          </p>
          <p>
            A <a>key range</a> MAY be lower-bounded or upper-bounded if there is 
            a value that is, respectively, smaller than or larger than all its 
            elements. A <a>key range</a> is said to be bounded if it is both 
            lower- and upper-bounded and unbounded otherwise. A <a>key range</a> MAY be open, 
            i.e., not including its endpoints or closed, i.e., including
            its endpoints. A <a>key range</a> MAY consist of a single value.
          </p>
          <p>
            The <a><code>IDBKeyRange</code></a> interface defines a 
            <a>key range</a>.
          </p>
          <dl class="idl" title="interface IDBKeyRange"> 
            <dt>readonly attribute any lower</dt>
            <dd>This value is the lower-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute any upper</dt>
            <dd>This value is the upper-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute boolean lowerOpen</dt>
            <dd>Returns false if the lower-bound value is included in the <a>key range</a>.</dd>
            <dt>readonly attribute boolean upperOpen</dt>
            <dd>Returns false if the upper-bound value is included in the <a>key range</a>.</dd>
          </dl>
          <p>
            A <a><var>key value</var></a> is <dfn>in a <a>key range</a></dfn> if both the following conditions are
            fulfilled:
          </p>
          <ul>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-lower"><code>lower</code></a> value is <code>undefined</code> or
              <a>less than</a> <var>key value</var>. It may also be <a>equal to</a> <var>key value</var> if
              <a href="#widl-IDBKeyRange-lowerOpen"><code>lowerOpen</code></a> is <code>false</code>.
            </li>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-upper"><code>upper</code></a> value is <code>undefined</code> or
              <a>greater than</a> <var>key value</var>. It may also be <a>equal to</a> <var>key value</var> if
              <a href="#widl-IDBKeyRange-upperOpen"><code>upperOpen</code></a> is <code>false</code>.
            </li>
          </ul>

          <p>
            To construct a <a>key range</a> a set of constructors are available. In languages with
            interface objects [[!WEBIDL]], these constructors are available on the <code>IDBKeyRange</code>
            interface object. In other languages these constructors are available through language specific
            means, for example as static functions.
          </p>
          <dl class="idl" title="[NoInterfaceObject] interface IDBKeyRangeConstructors"> 
            <dt>IDBKeyRange only()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with both <a href="#widl-IDBKeyRange-lower">lower</a> and
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and both
              <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a>
              set to false.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The only value</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange lowerBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to <var>open</var>,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <code>undefined</code> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to false.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The lower bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the lower-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange upperBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <code>undefined</code>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to false,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>open</var>.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The upper bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the upper-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange bound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to false,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>open</var>.
              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower-bound value</dd>
                <dt>any upper</dt>
                <dd>The upper-bound value</dd>
                <dt>optional boolean openLower</dt>
                <dd>Is the lower-bound value included in the <a>key range</a>. Defaults to false.</dd>
                <dt>optional boolean openUpper</dt>
                <dd>Is the upper-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>lower</var> or <var>upper</var> parameters were not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section> <!-- Key Range -->
        
        <section id="cursor-concept" class="section">
          <h4>Cursor</h4>
          <p>
            <a title="cursor">Cursors</a> are a transient mechanism used to 
            iterate over multiple records in a database. The storage operations
            are performed on the underlying <a>index</a> or an 
            <a>object store</a>.
          </p>
          <p>
            A <dfn>cursor</dfn> comprises a <dfn>range</dfn> of records in either an <a>index</a>
            or an <a>object store</a>. The cursor has a <dfn title="cursor source">source</dfn> indicating
            which index or object store whose records it is iterating. A <a>cursor</a> maintains a <dfn>position</dfn> over 
            this series, which moves in a <dfn>direction</dfn> that is either 
            monotonically increasing or decreasing order of the <a>record</a> keys. Cursors
            also have a <dfn title="cursor key">key</dfn> and a <dfn title="cursor value">value</dfn>
            which represent the <a>key</a> and the <a>value</a> of the last iterated <a>record</a>.
            Cursors finally have a <dfn>got value</dfn> flag. When this flag is false, the cursor is either
            in the process of loading the next value or it has reached the end of its <a>range</a>, when it
            is true, it indicates that the cursor is currently holding a value and that it is ready to iterate
            to the next one.
          </p>
          <p>
            If the <a title="cursor source">source</a> of a cursor is a <a>object store</a>, the <dfn>effective object store</dfn>
            of the cursor is that object store and the <dfn>effective key</dfn> of the cursor is the cursors <a>position</a>.
            If the <a title="cursor source">source</a> of a cursor is a <a>index</a>, the <a>effective object store</a>
            of the cursor is that index's <a>referenced</a> object store and the <a>effective key</a> is the cursors
            <a>object store position</a>.
          </p>
          <p>
            It is possible for the list of records which the cursor is iterating over to
            change before the full <a>range</a> of the cursor has been iterated. In order to
            handle this, cursors maintain their <a>position</a> not as an index, but rather
            as a <a>key</a> of the previously returned record. For a forward iterating cursor,
            the next time the cursor is asked to iterate to the next record it returns the
            record with the lowest <a>key</a> <a>greater than</a> the one previously returned. For
            a backwards iterating cursor, the situation is opposite and it returns the record
            with the highest <a>key</a> <a>less than</a> the one previously returned.
          </p>
          <p>
            For cursors iterating indexes the situation is a little bit more complicated since
            multiple records can have the same key and are therefor also sorted by <a>value</a>.
            When iterating indexes the <a>cursor</a>'s also has a <dfn>object store position</dfn>, which indicates
            the <a>value</a> of the previously found <a>record</a> in the index. Both
            <a>position</a> and the <a>object store position</a> is used when finding the next appropriate record.
          </p>
          <p>
            <a title="cursor">Cursor</a> objects implement the <a><code>IDBCursor</code></a> 
            or the <a><code>IDBCursorSync</code></a> interfaces. There is only ever one
            <a><code>IDBCursor</code></a> or <a><code>IDBCursorSync</code></a> instance representing
            a given <a>cursor</a>. However there is no limit on how many cursors can be used at the
            same time.
          </p>
        </section> <!-- IDBCursor -->

        <section class="section">
          <h3>The <code>IDBDatabaseException</code> Interface</h3>
          <dl class="idl" title="exception IDBDatabaseException">
            <dt>const unsigned short UNKNOWN_ERR = 0</dt>
            <dd>The operation failed for reasons unrelated to the database
              itself and not covered by any other error code.</dd>
            <dt>const unsigned short NON_TRANSIENT_ERR = 1</dt>
            <dd>This error occurred because an operation was not allowed on 
            an object. A retry of the same operation would fail unless the
            cause of the error is corrected.</dd>
            <dt>const unsigned short NOT_FOUND_ERR = 2</dt>
            <dd>The operation failed because the requested database
            object could not be found. For example, an object store
            did not exist but was being opened.</dd>
            <dt>const unsigned short CONSTRAINT_ERR = 3</dt>
            <dd>A mutation operation in the transaction failed due to a
            because a constraint was not satisfied. For example, an
            object such as an object store or index already
            exists and a new one was being attempted to be created.</dd>
            <dt>const unsigned short DATA_ERR = 4</dt>
            <dd>Data provided to an operation does not meet requirements.</dd>
            <dt>const unsigned short NOT_ALLOWED_ERR = 5</dt>
            <dd>A mutation operation was attempted on a database that
            <dt>const unsigned short TRANSACTION_INACTIVE_ERR = 6</dt>
            <dd>A <a>request</a> was placed against a transaction which is
            currently not <a>active</a>, or which is
            <a title="transaction finish">finished</a>.</dd>
            <dt>const unsigned short ABORT_ERR = 7</dt>
            <dd>A <a>request</a> was aborted, for example through a call
            to <a href="#widl-IDBTransaction-abort"><code>IDBTransaction.abort</code></a>.</dd>
            <dt>const unsigned short SERIAL_ERR = 11</dt>
            <dd>The operation failed because of the size of the data set 
            being returned or because there was a problem in serializing or 
            deserializing the object being processed.</dd>
            <dt>const unsigned short RECOVERABLE_ERR = 21</dt>
            <dd>The operation failed because the database was prevented
            from taking an action. The operation might be able to succeed
            if the application performs some recovery steps and retries
            the entire transaction. For example, there was not enough 
            remaining storage space, or the storage quota was reached
            and the user declined to give more space to the database.</dd>
            <!--const unsigned short QUOTA_ERR = 22;
                <dd>The statement failed because there was not enough remaining
     storage space, or the storage quota was reached and the user
     declined to give more space to the database.</dd>-->
            <dt>const unsigned short TRANSIENT_ERR = 31</dt>
            <dd>The operation failed because of some temporary problems.
            The failed operation might be able to succeed when the
            operation is retried without any intervention by 
            application-level functionality.</dd>
            <dt>const unsigned short TIMEOUT_ERR = 32</dt>
            <dd>A lock for the transaction could not be obtained in a
            reasonable time.</dd>
            <dt>const unsigned short DEADLOCK_ERR = 33</dt>
            <dd>The current transaction was automatically rolled back
            by the database because of deadlock or other transaction
            serialization failures.</dd>
            <dt>attribute unsigned short code</dt>
            <dd>
              Return the most appropriate error code.
            </dd>
            <dt>attribute DOMString message</dt>
            <dd>
              Return an error message describing the exception raised. 
              The message should be localized to the user's language.
            </dd>
          </dl>
        </section>
      </section>  
      <section class="section" id="async-api"> 
        <h3>Asynchronous APIs</h3>
        <p>
          The asynchronous API methods return without blocking the calling thread.
          All asynchronous operations return an <a><code>IDBRequest</code></a> instance,
          which can be used to access the results of the operation as they become available.
        </p>
        <section class="section" id="events">
          <h4>Event interfaces</h4>
          <p>
            Events are fired during asynchronous access as <a>database</a> 
            <a>objects</a> are created and data is consumed from these objects. 
            As requests are made to <a>database</a> <a>objects</a>, the user 
            agent loads information about them into memory and when the required
            object handle is available, it alerts the application through the
            firing of events. The events are as follows:
          </p>
          <p>The <a><code>IDBEvent</code></a> interface extends
            the <code>Event</code> interface defined in [[!DOM-LEVEL-3-EVENTS]].
          </p>
          <dl class="idl" title="interface IDBEvent : Event"> 
            <dt>readonly attribute any source</dt>
            <dd>Returns the asynchronous request object that fired this event.</dd>
          </dl>
          <dl class="idl" title="interface IDBSuccessEvent : IDBEvent"> 
            <dt>readonly attribute any result</dt>
            <dd>Returns the result of the successful completion of an asynchronous request
            on the <a class="idlType" href="#widl-IDBEvent-source"><code>source</code></a>.</dd>
          </dl>
          <dl class="idl" title="interface IDBTransactionEvent : IDBSuccessEvent"> 
            <dt>readonly attribute IDBTransaction transaction</dt>
            <dd>Returns the transaction used for the request 
            on the <a class="idlType" href="#widl-IDBEvent-source"><code>source</code></a>.</dd>
          </dl>

          <dl class="idl" title="interface IDBErrorEvent : IDBEvent"> 
            <dt>readonly attribute unsigned short code</dt>
            <dd>Returns the most appropriate error code from carrying out the asynchronous request
            on the <a class="idlType" href="#widl-IDBEvent-source"><code>source</code></a>. The 
            valid values of this error code are defined on the exception
            <a class="idlType" href="#widl-IDBDatabaseException"><code>IDBDatabaseException</code></a>.</dd>
            <dt>readonly attribute DOMString message</dt>
            <dd>Returns the describing the reason for the error. The message should be localized 
            to the user's language.</dd>
          </dl>

          <dl class="idl" title="interface IDBVersionChangeEvent : IDBEvent"> 
            <dt>readonly attribute DOMString version</dt>
            <dd>Returns the new version of the database during a VERSION_CHANGE transaction.
            See the <a>steps for running a <code>VERSION_CHANGE</code> transaction</a>.</dd>
          </dl>

        </section>
        
        <section class="section" id="request-api">
          <h4>The <code>IDBRequest</code> Interface</h4>
          <p>
            The <a><code>IDBRequest</code></a> interface provides means to access results of  
            asynchronous requests to <a title="database">databases</a> and <a>database</a> 
            <a>objects</a> using <a>event handler attributes</a> [[!DOM-LEVEL-3-EVENTS]]. 
          </p>
          <div class="example">       
            <p>
              In the following example, we open a <a>database</a> asynchronously. Various 
              event handlers are registered for responding to various situations.
            </p>
            <codeblock>
 var request = indexedDB.<a>open</a>('AddressBook', 'Address Book');
 request.<a>onsuccess</a> = function(evt) {...};
 request.<a>onerror</a> = function(evt) {...};
            </codeblock>
          </div>
          <dl class="idl" title="interface IDBRequest : EventTarget"> 
            <dt>const     unsigned short LOADING = 1</dt>
            <dd>This state indicates that a request has been started but its results is not
            yet available.</dd>
            <dt>const     unsigned short DONE = 2</dt>
            <dd>This state indicates that a result to a previous request is available in
            the <a class="idlType" href="#widl-IDBRequest-result"><code>result</code></a> attribute.</dd>
            <dt>readonly attribute unsigned short readyState</dt>
            <dd>When the <a title="request done">done</a> flag is false, returns
            <a class="idlType" href="#widl-IDBRequest-LOADING"><code>LOADING</code></a>,
            otherwise returns
            <a class="idlType" href="#widl-IDBRequest-DONE"><code>DONE</code></a>.</dd>
            <dt>attribute Function onsuccess</dt>
            <dd>The event handler for the <a title="event-success">success event</a></dd>
            <dt>attribute Function onerror</dt>
            <dd>The event handler for the <a title="event-error">error event</a></dd>
          </dl>
          <p>
            When a request is made, the 
            <a class="idlType" href="#widl-IDBRequest-readyState"><code>readyState</code></a> changes to 
            <a class="idlType" href="#widl-IDBRequest-LOADING"><code>LOADING</code></a>. 
            If a request completes successfully, the
            <a class="idlType" href="#widl-IDBRequest-readyState"><code>readyState</code></a>
            changes to <a class="idlType" href="#widl-IDBRequest-DONE"><code>DONE</code></a>, 
            the result of the request is included as the 
            <a class="idlType" href="#widl-IDBSuccessEvent-result"><code>result</code></a> of
            a new <a class="idlType" href="#widl-IDBSuccessEvent"><code>IDBSuccessEvent</code></a> 
            event, and <a>queue a task</a> to fire that event with the name <code>success</code>, 
            with no namespace, which does not bubble, is not cancelable at each 
            <a class="externalDFN"><code>Window</code></a> object.
          </p>
          <p>
            If an error occurs while performing the operation, the 
            <a class="idlType" href="#widl-IDBRequest-readyState"><code>readyState</code></a>
            changes to <a class="idlType" href="#widl-IDBRequest-DONE"><code>DONE</code></a>, 
            the error code and message are included in a new <a><code>IDBDatabaseError</code></a>
            event, and <a>queue a task</a> to fire that event with the name 
            <code>error</code>, with no namespace, which does not bubble, is 
            not cancelable at each <a class="externalDFN"><code>Window</code></a> object.
          </p>
          <p>
            The <a href="#widl-IDBDatabase-setVersion">setVersion</a> function on <a>IDBDatabase</a>
            uses a separate interface for its <a>request</a>s in order to make use of the
            <code>blocked event</code> eaiser.
          </p>
          <dl class="idl" title="interface IDBVersionChangeRequest : IDBRequest"> 
            <dt>attribute Function onblocked</dt>
            <dd>The event handler for the <code>blocked event</code></dd>
          </dl>
          <p>
            The <span>task source</span> for these tasks is the 
            <dfn id="database-access-task-source">database access task source</dfn>.
          </p>    
          <p>
            The following are the <span>event handlers</span> (and their corresponding 
            <span>event handler event types</span>) that MUST be supported, as IDL
            attributes, by objects implementing the <a><code>IDBRequest</code></a> interface:
          </p>
          
          <table>
            <thead><tr>
              <th><span>Event handler</span> </th>
              <th><span>Event handler event type</span></th>
              <th><span>Event interface(s)</span></th>
            </tr></thead>
            <tbody>
              <tr>
                <td><dfn id="handler-request-onsuccess"><code>onsuccess</code></dfn> </td>
                <td> <code><dfn title="event-success">success</dfn></code></td>
                <td> <a class="idlType" href="#widl-IDBSuccessEvent"><code>IDBSuccessEvent</code></a>,
                <a class="idlType" href="#widl-IDBTransactionEvent"><code>IDBTransactionEvent</code></a></td>
              </tr>
              <tr>
                <td><dfn id="handler-request-onerror"><code>onerror</code></dfn> </td>
                <td> <code><dfn title="event-error">error</dfn></code></td>
                <td> <a class="idlType" href="#widl-IDBErrorEvent"><code>IDBErrorEvent</code></a></td>
              </tr>
            </tbody>
          </table>        

          <p>
            The following are the <span>event handlers</span> (and their corresponding 
            <span>event handler event types</span>) that MUST be supported, as IDL
            attributes, by objects implementing the <a><code>IDBTransaction</code></a> interface:
          </p>
          
          <table>
            <thead><tr>
              <th><span>Event handler</span> </th>
              <th><span>Event handler event type</span></th>
            </tr></thead>
            <tbody>
              <tr>
                <td><dfn id="handler-request-oncomplete"><code>oncomplete</code></dfn> </td>
                <td> <code><dfn title="event-complete">complete</dfn></code></td>
              </tr>
              <tr>
                <td><dfn id="handler-request-onabort"><code>onabort</code></dfn> </td>
                <td> <code><dfn title="event-abort">abort</dfn></code></td>
              </tr>
              <tr>
                <td><dfn id="handler-request-ontimeout"><code>ontimeout</code></dfn> </td>
                <td> <code><dfn title="event-timeout">timeout</dfn></code></td>
              </tr>
            </tbody>
          </table>        
        </section>
        
        <section class="section" id="requests">
          <h4>Opening a database</h4>
         <p>
            <a title="Window" class="externalDFN"><code>Window</code></a> and 
            <a title="Worker" class="externalDFN"><code>Worker</code></a> objects 
            MUST implement the <a><code>IDBEnvironment</code></a> interface.
          </p>
          <p class="idl" title="Window implements IDBEnvironment">
          <p class="idl" title="Worker implements IDBEnvironment">
          </p>
          
          <dl class="idl" title="[NoInterfaceObject] interface IDBEnvironment">
            <dt>readonly attribute IDBFactory indexedDB</dt>
            <dd>This attribute provides applications a mechanism for accessing
              capabilities of indexed databases.</dd>
          </dl>
          <p>
            Every method for making asynchronous requests returns an 
            <a><code>IDBRequest</code></a> object that communicates back to the requesting
            application through events.
            This design means that any number of requests can be active on any <a>database</a>
            or <a title="objects">object</a> handle at a time. 
          </p>

          <dl class="idl" title="interface IDBFactory">
            <dt>readonly attribute DOMStringList databases</dt>
            <dd>
            This value is the list of the names of databases available in the global scope object.
            </dd>
            <dt>IDBRequest open()</dt>
            <dd>
              <p>
                When invoked, this method creates an <a>IDBRequest</a> and returns it.
                It then asynchronously runs the <a>steps for opening a database</a>.
                Let <var>origin</var> be the origin of the <a>IDBEnvironment</a> used to access
                this <a>IDBFactory</a>, <var>name</var> be the <var>name</var> argument passed
                to the function and <var>request</var> be the created <a>IDBRequest</a>.
              </p>
              <p>
                If an error is returned from the steps above, then the implementation MUST
                fire an <a title="event-error">error event</a> on the <a>IDBRequest</a> returned from
                this method, with its 
                <a class="idlType" href="#widl-IDBErrorEvent-code"><code>code</code></a>
                and <a class="idlType" href="#widl-IDBErrorEvent-message"><code>message</code></a> set to
                appropriate values for the error.
              </p>
              <p>
                If the steps above are successful, the implementation MUST fire a <a title="event-success">success event</a>
                on the <a>IDBRequest</a> returned above. The event MUST use the <a><code>IDBSuccessEvent</code></a> interface with its 
                <a class="idlType" href="#widl-IDBSuccessEvent-result"><code>result</code></a> 
                set to the <var>result</var> returned from the steps.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="database name">name</a> for the <a>database</a></dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section id="database-interface" class="section">
          <h4>Database</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            A <a>database</a> object can be used to manipulate the 
            <a>objects</a> of that <a>database</a>. That is also the only way to 
            obtaining a <a>transaction</a> for that <a>database</a>.
          </p>
          <dl class="idl" title="interface IDBDatabase">
            <dt>readonly attribute DOMString name</dt>
            <dd>
              On getting, this attribute MUST return the <a title="database name">name</a>
              of the <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMString version</dt>
            <dd>
              On getting, this attribute MUST return the <a>version</a> of this
              <a>database</a>. This attribute has the empty string value when the
              <a title="connection">connected</a> <a>database</a> is first created.
            </dd>
            <dt>readonly attribute DOMStringList objectStoreNames</dt>
            <dd>
              On getting, this attribute MUST return a list of names of the 
              <a title="object store">object stores</a> currently in the 
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <!-- There is no currentTransaction any more.
            <dt>readonly attribute IDBTransaction currentTransaction</dt>
            <dd>
              On getting, this attribute MUST return a <a><code>IDBTransaction</code></a> object
              corresponding to the <a>transaction</a> that is <a>active</a> in this
              <a>database</a> <a>connection</a>.
            </dd> -->
            <dt>IDBObjectStore createObjectStore()</dt>
            <dd>
              <p>
                This method creates and returns a new <a>object store</a> with the given name in the 
                <a title="connection">connected</a> <a>database</a>. Note that this method must only
                be called from a <a><code>VERSION_CHANGE</code></a> <a>transaction</a> callback.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of a new <a>object store</a></dd>
                <dt>[TreatNullAs=EmptyString] optional DOMString keyPath</dt>
                <dd>The <a title="object store key path">key path</a> of a new 
                <a>object store</a>. If <a>empty</a> path is specified, then the 
                <a>object store</a> created will not have a <a>key path</a> and will
                use <a>out-of-line keys</a>.</dd>
                <dt>optional boolean autoIncrement</dt>
                <dd>Whether the <a>object store</a> created should have a 
                <a>key generator</a>. This defaults to <code>true</code>.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This method was not called from a <a><code>VERSION_CHANGE</code></a> <a>transaction</a> callback.</dd>
                <dt>CONSTRAINT_ERR</dt>
                <dd>An <a>object store</a> with the same name, compared in a 
                case-sensitive manner, already exists in the 
                <a title="connection">connected</a> <a>database</a>. </dd>
              </dl>
            </dd>
            <dt>IDBRequest deleteObjectStore()</dt>
            <dd>
              <p>
                This method destroys the <a>object store</a> with the given name in the 
                <a title="connection">connected</a> <a>database</a> as well as 
                all <a title="index">indexes</a> that are 
                <a title="referenced">referencing</a> that <a>object store</a>.
                Note that this method must only be called from a <a><code>VERSION_CHANGE</code></a>
                <a>transaction</a> callback.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This method was not called from a <a><code>VERSION_CHANGE</code></a> <a>transaction</a> callback.</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>There is no <a>object store</a> with the given name, compared in a 
                case-sensitive manner, in the  <a title="connection">connected</a> <a>database</a>.</dd>
              </dl>
            </dd>
            <dt>IDBVersionChangeRequest setVersion()</dt>
            <dd>
              This method updates the <a>version</a> of the <a>database</a> by following the
              <a>steps for running a <code>VERSION_CHANGE</code> transaction</a> using
              the <var>version</var> argument as <var>version</var> and the <a>IDBDatabase</a>
              this function was called on as <var>connection</var>. Return the <a>IDBVersionChangeRequest</a>
              returned by those steps.
              <dl class="parameters">
                <dt>[TreatNullAs=EmptyString] DOMString      version</dt>
                <dd>The <a>version</a> to store in the <a>database</a></dd>
              </dl>
            </dd>
            <dt>IDBTransaction transaction()</dt>
            <dd>
              <p>
                This method, when called MUST execute the
                <a title="create a static transaction">steps for creating a transaction</a> in a asychronous
                fashion. If the <var>storeNames</var> argument is provided and non-empty then then use that
                list as the <var>names</var> argument. Otherwise use the full set of <a>object store</a>
                names for the <a>IDBDatabase</a> as <var>names</var> argument. The <var>mode<var> and
                <var>timeout</var> arguments are forwarded to the algorithm as-is. The <var>connection</var>
                argument is set to the <a>IDBDatabase</a> that the <code>transaction()</code> method was
                called on.
              </p>
              <p>
                The method returns a <a>IDBTransaction</a> object representing the <a>transaction</a>
                returned by the steps above</a>.
              </p>
              <dl class="parameters">
                <dt>optional DOMStringList storeNames</dt>
                <dd>The names of <a title="object store">object stores</a> and 
                <a title="index">indexes</a> in the <a>scope</a> of the new
                <a>transaction</a></dd>
                <dt>optional unsigned short mode</dt>
                <dd> The <a>mode</a> for isolating access to data inside the given
                <a title="object store">object stores</a>. If this parameter is not provided, the default
                access <a>mode</a> is <code>READ_ONLY</code>.</dd>
                <dt>optional unsigned long timeout</dt>
                <dd>The interval, specified in milliseconds, which this operation is allowed to take to
                reserve all the <a>database</a> objects identified in the new
                <a title="transaction">transaction's</a> <a>scope</a>. The default
                is user agent specific</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The close() method has been called on this <a>IDBDatabase</a> instance.</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>One of the names provided in the <var>storeNames</var> argument doesn't exist in this <a>database</a>.</dd>
              </dl>
            </dd>
            <dt>void close()</dt>
            <dd>
              This method returns immediately and performs the <a>steps for closing a database connection</a>.
            </dd>
          </dl>
        </section>
        <section class="section" id="object-store">
          <h4>Object Store</h4>
          <a title="object store">Object store</a> objects implement the following
          interface:
          <dl class="idl" title="interface IDBObjectStore">
            <dt>readonly attribute DOMString      name</dt>
            <dd>          
              On getting, provide the <a title="object store name">name</a> of this
              object store.        
            </dd>
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="object store key path">key path</a>
              of this <a>object store</a>. If this attribute is <code>null</code>,
              the application MUST provide a key value for each modification operation.
            </dd>
            <dt>readonly attribute DOMStringList  indexNames</dt>
            <dd>
            On getting, provide a list of the names of <a title="index">indexes</a> on 
            objects in this <a>object store</a>.
            </dd>
            <dt>IDBRequest put()</dt>
            <dd>
              <p>
                This method throws a NOT_ALLOWED_ERR if the transaction which this IDBObjectStore belongs to is
                has its <a>mode</a> set to READ_ONLY. If any of the following conditions are true, this method
                throws a DATA_ERR exception:
              </p>
              <ul>
                <li>
                  The object store uses <a>in-line keys</a> or has a <a>key generator</a> and
                  the <var>key</var> parameter was provided.
                </li>
                <li>
                  The object store uses <a>out-of-line keys</a> and has no <a>key generator</a>
                  and the <var>key</var> parameter was not provided.
                </li>
                <li>
                  The object store uses <a>in-line keys</a> but no <a>key generator</a>
                  and the result of <a title="evaluate key path">evaluating</a> the 
                  <a title="object store key path">object store's key path</a> does not yield a
                  <a>valid key</a>.
                </li>
                <li>
                  The <var>key</var> parameter was provided but does not contain a <a>valid key</a>.
                </li>
                <li>
                  If there are any <a>index</a>es <a title="referenced">referencing</a> this object
                  store and <a title="evaluate key path">evaluating</a> their key path on the
                  <var>value</var> parameter yields a value and that value is not a <a>valid key</a>.
                </li>
              </ul>
              <p>
                Otherwise this method creates a <a>structured clone</a> of the <var>value</var> parameter.
                If this throws an exception that exception is rethrown. It then runs the <a>steps for
                asynchronously executing a request</a> and returns the <a>IDBRequest</a> created by these steps.
                The steps are run with this <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for
                storing a record into an object store</a> as <var>operation</var>, using this <a>IDBObjectStore</a>
                as <var>store</var>, the created clone as <var>value</var>, the <var>key</var> parameter as
                <var>key</var>, and with the <var>no-overwrite flag</var> flag set to false.
              </p>
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the <a>record</a></dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the <a>record</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBObjectStore</a> belongs to is not <a>active</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The <a>mode</a> of the associated <a>transaction</a> is <code>READ_ONLY</code>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The calculated key for the insertion was not a <a>valid key</a>. Also thrown if the
                calculated key for any of the indexes which belong to this object store had a calculated
                key which was not a <a>valid key</a></dd>
              </dl>
              <dl class="exception" title="DOMException">
                <dt>DATA_CLONE_ERR</dt>
                <dd>The data being stored could not be cloned by the internal
                structured cloning algorithm.</dd>
              </dl>
            </dd>
            <dt>IDBRequest add()</dt>
            <dd>
              <p>
                This method throws a NOT_ALLOWED_ERR if the transaction which this IDBObjectStore belongs to is
                has its <a>mode</a> set to READ_ONLY. If any of the following conditions are true, this method
                throws a DATA_ERR exception:
              </p>
              <ul>
                <li>
                  The object store uses <a>in-line keys</a> or has a <a>key generator</a> and
                  the <var>key</var> parameter was provided.
                </li>
                <li>
                  The object store uses <a>out-of-line keys</a> and has no <a>key generator</a>
                  and the <var>key</var> parameter was not provided.
                </li>
                <li>
                  The object store uses <a>in-line keys</a> but no <a>key generator</a>
                  and the result of <a title="evaluate key path">evaluating</a> the 
                  <a title="object store key path">object store's key path</a> does not yield a
                  <a>valid key</a>.
                </li>
                <li>
                  The <var>key parameter was provided but does not contain a <a>valid key</a>.
                </li>
                <li>
                  If there are any <a>index</a>es <a title="referenced">referencing</a> this object
                  store and <a title="evaluate key path">evaluating</a> their key path on the
                  <var>value</var> parameter yields a value and that value is not a <a>valid key</a>.
                </li>
              </ul>
              <p>
                Otherwise this method creates a <a>structured clone</a> of the <var>value</var> parameter.
                If this throws an exception that exception is rethrown. It then runs the <a>steps for
                asynchronously executing a request</a> and returns the <a>IDBRequest</a> created by these steps.
                The steps are run with this <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for
                storing a record into an object store</a> as <var>operation</var>, using this <a>IDBObjectStore</a>
                as <var>store</var>, the created clone as <var>value</var>, the <var>key</var> parameter as
                <var>key</var>, and with the <var>no-overwrite flag</var> flag set to true.
              </p>
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the <a>record</a></dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the <a>record</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBObjectStore</a> belongs to is not <a>active</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The <a>mode</a> of the associated <a>transaction</a> is <code>READ_ONLY</code>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The calculated key for the insertion was not a <a>valid key</a>. Also thrown if the
                calculated key for any of the indexes which belong to this object store had a calculated
                key which was not a <a>valid key</a></dd>
              </dl>
              <dl class="exception" title="DOMException">
                <dt>DATA_CLONE_ERR</dt>
                <dd>The data being stored could not be cloned by the internal
                structured cloning algorithm.</dd>
              </dl>
            </dd>
            <dt>IDBRequest delete()</dt>
            <dd>
              <p>
                This method throws a NOT_ALLOWED_ERR if the transaction which this IDBObjectStore belongs to is
                has its <a>mode</a> set to READ_ONLY. If the <var>key</var> parameter is not a <a>valid key</var>
                this method throws a DATA_ERR exception.
              </p>
              <p>
                Otherwise this method runs the <a>steps for
                asynchronously executing a request</a> and returns the <a>IDBRequest</a> created by these steps.
                The steps are run with this <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for deleting
                a record from an object store</a> as <var>operation</var>, using this <a>IDBObjectStore</a>
                as <var>store</var> and the <var>key</var> parameter as <var>key</var>.
              </p>
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the <a>record</a> to be deleted</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This <a>object store</a> is not in the <a>scope</a> of any existing <a>transaction</a> or
                the associated <a>transaction</a> <a><code>mode</code></a> is <code>READ_ONLY</code>.</dd>
              </dl>
            </dd>
            <dt>IDBRequest get()</dt>
            <dd>
              If the <var>key</var> parameter is not a valid <a>key value</a> or a <a>key range</a>, this method
              throws a DATA_ERR exception. Otherwise, this method runs the <a>steps for asynchronously executing
              a request</a> and returns the <a>IDBRequest</a> created by these steps. The steps are run with this
              <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for retrieving a value from an
              object store</a> as <var>operation</var>, using this <a>IDBObjectStore</a> as <var>store</var> and the
              <var>key</var> parameter as <var>key</var>.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the <a>record</a> to be retrieved. This can also be a <a>IDBKeyRange</a> in which case
                the function retreives the first existing value in that range.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBObjectStore</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>key</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
            <dt>IDBRequest openCursor()</dt>
            <dd>
              <p>
                If the <var>range</var> parameter is specified but is not a valid <a>key value</a> or a <a>key range</a>,
                this method throws a DATA_ERR exception. Otherwise, this method creates a <a>cursor</a> with an undefined
                <a>position</a>, a <a>direction</a> set to the value of the <var>direction</var> parameter, false as
                <a>iterable</a> flag value, and undefined <a title="cursor key">key</a> and
                <a title="cursor value">value</a>. The <a title="cursor source">source</a> of the cursor is the
                <a>IDBObjectStore</a> this function was called on.
              </p>
              <p>
                If the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a> is set to that
                range. Otherwise, if the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a>
                is set to <a>key range</a> containing only that key value. If the <var>range</var> parameter is not specified,
                the cursor's key range is left as undefined.
              </p>
              <p>
                This method runs the <a>steps for asynchronously executing a request</a> and returns the <a>IDBRequest</a>
                created by these steps. The steps are run with this <a>IDBObjectStore</a> as <var>source</var> and the
                <a>steps for iterating a cursor</a> as <var>operation</var>,
                using the created cursor as <var>cursor</var> and with undefined as <var>key</var>.
              </p>
              <dl class="parameters">
                <dt>optional any            range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBObjectStore</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>range</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
            <dt>IDBIndex createIndex()</dt>
            <dd>
              <p>
                This creates and returns a new <a>index</a> with the given name and parameters in the 
                <a title="connection">connected</a> <a>database</a>.  Note that this method must only
                be called from a <a><code>VERSION_CHANGE</code></a> <a>transaction</a> callback.
              </p>
              <dl class="parameters">
                <dt>DOMString      name</dt>
                <dd>The <a title="index name">name</a> of a new <a>index</a></dd>
                <!-- this is removed because it is implicit on the store
                <dt>DOMString      storeName</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a> <a>referenced</a> by the new <a>index</a></dd>-->
                <dt>DOMString      keyPath</dt>
                <dd>The <a title="index key path">key path</a> used by the new
                <a>index</a></dd>
                <dt>optional boolean unique</dt>
                <dd>The <a>unique</a> flag for the new <a>index</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This method was not called from a <a><code>VERSION_CHANGE</code></a> 
                <a>transaction</a> callback.</dd>
                <dt>CONSTRAINT_ERR</dt>
                <dd>An <a>index</a> with the same name, compared in a 
                case-sensitive manner, already exists in the 
                <a title="connection">connected</a> <a>database</a>. </dd>
              </dl>
            </dd>
            <dt>IDBIndex index()</dt>
            <dd>
              Returns a <a>IDBIndex</a> representing a <a>index</a> that is part of the
              to this <a>object store</a>. Every call to this function on the same
              <a>IDBObjectStore</a> instance and with the same <var>name</var> returns the same <a>IDBIndex</a> instance.
              However the retured <a>IDBIndex</a> instance is specific to this <a>IDBObjectStore</a> instance. If this
              function is called on a different <a>IDBObjectStore</a> instance, a different <a>IDBIndex</a> instance is
              returned. A result of this is that different <a>IDBTransaction</a>s use different <a>IDBIndex</a> instances
              to represent the same <a>index</a>.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>There is no <a>index</a> with the given name, compared in a 
                case-sensitive manner, in the <a title="connection">connected</a> <a>database</a>.</dd>
              </dl>
            </dd>
            <dt>void deleteIndex()</dt>
            <dd>
              <p>
                This method destroys the <a>index</a> with the given name in the
                <a title="connection">connected</a> <a>database</a>. Note that this
                method must only be called from a <a><code>VERSION_CHANGE</code></a>
                <a>transaction</a> callback.
              </p>
              <dl class="parameters">
                <dt>DOMString indexName</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This method was not called from a <a><code>VERSION_CHANGE</code></a>
                <a>transaction</a> callback.</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>There is no <a>index</a> with the given name, compared in a 
                case-sensitive manner, in the  <a title="connection">connected</a> <a>database</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="index">
        <h4>Index</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            <a title="index">Index</a> objects implement the following interface:
          </p>
          <dl class="idl" title="interface IDBIndex">
            <dt>readonly attribute DOMString      name</dt>
            <dd>
              On getting, provide the <a title="index name">name</a> of this <a>index</a>.        
            </dd>
            <dt>readonly attribute DOMString      storeName</dt>
            <dd>
              On getting, provide the <a title="object store name">name</a> of this
              <a title="index">index's</a> <a>referenced</a> <a>object store</a>.
            </dd>
        
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="index key path">key path</a> of this
              <a>index</a>. If this attribute is <code>null</code>,
              this <a>index</a> is not <a>auto-populated</a>.
            </dd>
            
            <dt>readonly attribute boolean unique</dt>
            <dd>
              On getting, provide the <a>unique</a> flag of this <a>index</a>.
            </dd>
            <dt>IDBRequest openCursor()</dt>
            <dd>
              <p>
                If the <var>range</var> parameter is specified but is not a valid <a>key value</a> or a <a>key range</a>,
                this method throws a DATA_ERR exception. Otherwise, this method creates a <a>cursor</a> with an undefined
                <a>position</a>, a <a>direction</a> set to the value of the <var>direction</var> parameter, false as
                <a>iterable</a> flag value, and undefined <a title="cursor key">key</a> and
                <a title="cursor value">value</a>. The <a title="cursor source">source</a> of the cursor is the
                <a>IDBIndex</a> this function was called on.
              </p>
              <p>
                If the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a> is set to that
                range. Otherwise, if the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a>
                is set to <a>key range</a> containing only that key value. If the <var>range</var> parameter is not specified,
                the cursor's key range is left as undefined.
              </p>
              <p>
                This method runs the <a>steps for asynchronously executing
                a request</a> and returns the <a>IDBRequest</a> created by these steps. The steps are run with this
                <a>IDBIndex</a> as <var>source</var> and the <a>steps for iterating a cursor</a> as <var>operation</var>,
                using the created cursor as <var>cursor</var> and with undefined as <var>key</var>
              </p>
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The transaction this <a>IDBIndex</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>range</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
            <dt>IDBRequest openKeyCursor()</dt>
            <dd>
              <p>
                If the <var>range</var> parameter is specified but is not a valid <a>key value</a> or a <a>key range</a>,
                this method throws a DATA_ERR exception. Otherwise, this method creates a <a>cursor</a> with an undefined
                <a>position</a>, a <a>direction</a> set to the value of the <var>direction</var> parameter, false as
                <a>iterable</a> flag value, and undefined <a title="cursor key">key</a> and
                <a title="cursor value">value</a>. The <a title="cursor source">source</a> of the cursor is the
                <a>IDBIndex</a> this function was called on.
              </p>
              <p>
                If the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a> is set to that
                range. Otherwise, if the <var>range</var> parameter is a <a>key range</a> then the cursor's <a>range</a>
                is set to <a>key range</a> containing only that key value. If the <var>range</var> parameter is not specified,
                the cursor's key range is left as undefined.
              </p>
              <p>
                This method runs the <a>steps for asynchronously executing
                a request</a> and returns the <a>IDBRequest</a> created by these steps. The steps are run with this
                <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for iterating a cursor</a> as <var>operation</var>,
                using the created cursor as <var>cursor</var> and with undefined as <var>key</var>
              </p>
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The transaction this <a>IDBIndex</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>range</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
            <dt>IDBRequest get()</dt>
            <dd>
              If the <var>key</var> parameter is not a valid <a>key value</a> or a <a>key range</a>, this method
              throws a DATA_ERR exception. This method runs the <a>steps for asynchronously executing a request</a>
              and returns the <a>IDBRequest</a> created by these steps. The steps are run with this
              <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for retrieving a referenced value from an
              index</a> as <var>operation</var>, using this <a>IDBIndex</a> as <var>index</var> and the
              <var>key</var> parameter as <var>key</var>.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved. This can also be a <a>IDBKeyRange</a> in which case
                the function retreives the first existing value in that range.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The transaction this <a>IDBIndex</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>key</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
            <dt>IDBRequest getKey()</dt>
            <dd>
              If the <var>key</var> parameter is not a valid <a>key value</a> or a <a>key range</a>, this method
              throws a DATA_ERR exception. This method runs the <a>steps for asynchronously executing a request</a>
              and returns the <a>IDBRequest</a> created by these steps. The steps are run with this
              <a>IDBObjectStore</a> as <var>source</var> and the <a>steps for retrieving a value from an
              index</a> as <var>operation</var>, using this <a>IDBIndex</a> as <var>index</var> and the
              <var>key</var> parameter as <var>key</var>.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved. This can also be a <a>IDBKeyRange</a> in which case
                the function retreives the first existing value in that range.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The transaction this <a>IDBIndex</a> belongs to is not <a>active</a>.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>key</var> parameter was not passed a valid value.</dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="cursor">
          <h4>Cursor</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            <a title="cursor">Cursor</a> objects implement the following interface:
          </p>
          <dl class="idl" title="interface IDBCursor">
  <dt>const     unsigned short     NEXT = 0</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     NEXT_NO_DUPLICATE = 1</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>
            <dt>const     unsigned short     PREV = 2</dt>
            <dd>
              indicates that <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     PREV_NO_DUPLICATE = 3</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>

            <dt>readonly attribute unsigned short     direction</dt>
            <dd>            
            On getting, provide the traversal <a>direction</a> of the <a>cursor</a>.
            </dd>
            <dt>readonly attribute any key</dt>
            <dd>Returns the cursor's current <a title="cursor key">key</a>. However if the cursor's <a>got value</a>
            flag is false it returns <code>undefined</code>. I.e. if it's currently being iterated or has
            iterated past the end of its range.</dd>
            <dt>readonly attribute any value</dt>
            <dd>Returns the cursor's current <a title="cursor value">value</a>. However if the cursor's <a>got value</a>
            flag is false it returns <code>undefined</code>. I.e. if it's currently being iterated or has
            iterated past the end of its range.</dd>

            <dt>IDBRequest update(in any value)</dt>
            <dd>
              <p>
                This method throws a NOT_ALLOWED_ERR if the transaction which this IDBCursor belongs to
                has its <a>mode</a> set to READ_ONLY, if this cursor's <a>got value</a> flag is false or if this
                cursor was created using
                <a class="idlType" href="#widl-IDBIndex-openKeyCursor"><code>openKeyCursor</code></a>. If the
                <a>effective object store</a> of this cursor uses <a>in-line</a>
                keys and <a title="evaluate key path">evaluating</a> the <a title="object store key path">key path</a>
                of the <var>value</var> parameter results in a different value than the cursor's <a>effective key</a>,
                this method throws DATA_ERR.
              </p>
              <p>
                Otherwise this method creates a <a>structured clone</a> of the <var>value</var> parameter.
                If this throws an exception that exception is rethrown. It then runs the <a>steps for
                asynchronously executing a request</a> and returns the <a>IDBRequest</a> created by these steps.
                The steps are run with this IDBCursor as <var>source</var> and the <a>steps for
                storing a record into an object store</a> as <var>operation</var>, using this cursor's
                <a>effective object store</a> as <var>store</var>, the created clone as <var>value</var>,
                this cursor's <a>effective key</a> as <var>key</var>, and with the <var>no-overwrite flag</var>
                flag set to false.
              </p>
              <p class="issue">
                Should this fire an error if the record had been deleted since we iterated to it? I.e. should
                this never be able to create a new record?
              </p>
              <p>
                Otherwise this method runs the <a>steps for asynchronously executing a request</a> and returns the
                <a>IDBRequest</a> created by these steps. The steps are run with this <a>IDBCursor</a> as <var>source</var>
                and the <a>steps for deleting a record from an object store</a> as <var>operation</var>, using this cursor's
                <a>effective object store</a> and <a>effective key</a> as <var>store</var> and <var>key</var> respectively.
              </p>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBCursor</a> belongs to is not <a>active</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The <a>mode</a> of the <a>transaction</a> this <a>IDBCursor</a> belongs to
                is <code>READ_ONLY</code>. Also thrown if cursor was created using
                <a class="idlType" href="#widl-IDBIndex-openKeyCursor"><code>openKeyCursor</code></a> or if the cursor
                is currently being iterated or has iterated past the end.</dd>
                <dt>DATA_ERR</dt>
                <dd> The underlying <a>object store</a> uses <a>in-line keys</a> and the property in <var>value</var>
                at the object store's <a title="object store key path">key path</a> does not match the key in this <a>cursor</a>'s
                <a>position</a>.</dd>
              </dl>
              <dl class="exception" title="DOMException">
                <dt>DATA_CLONE_ERR</dt>
                <dd>The data being stored could not be cloned by the internal
                structured cloning algorithm.</dd>
              </dl>
            </dd>
            <dt>void    continue()</dt>
            <dd>
              <p>
                If the <var>key</var> parameter is specified but is not a <a>valid key</a>,
                this method throws a DATA_ERR exception. If this cursor's <a>got value</a> flag is false, this method
                throws a NOT_ALLOWED_ERR. Otherwise this method runs the <a>steps for asynchronously executing a request</a>.
                However, the steps are slightly modified such that instead of creating a new IDBRequest, it reuses the
                <a>request</a> originally created when this cursor was created. The <a title="request done">done</a> flag
                on the request is set to false before the request is returned.  The steps are run with the cursor's
                <a title="cursor source">source</a> as <var>source</var> and the <a>steps for iterating a cursor</a> as <var>operation</var>,
                using the created cursor as <var>cursor</var> and the <var>key</var> parameter as <var>key</var>.
              </p>
              <p>
                Before this method returns, unless an exception was thrown, it sets the <a>got value</a> flag fn the cursor to false.
              </p>
              <dl class="parameters">
                <dt>optional any key</dt>
                <dd>The next key to position this <a>cursor</a> at</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBCursor</a> belongs to is not <a>active</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>This <a>got value</a> on the cursor is set to false.</dd>
                <dt>DATA_ERR</dt>
                <dd>The <var>key</var> parameter was specified but did not contain a <a>valid key</a>.</dd>
              </dl>
            </dd>
            
            <dt>IDBRequest    delete()</dt>
            <dd>          
              <p>
                This method throws a NOT_ALLOWED_ERR if the transaction which this IDBCursor belongs to
                has its <a>mode</a> set to READ_ONLY, if this cursor's <a>got value</a> flag is false,
                or if this cursor was created using
                <a class="idlType" href="#widl-IDBIndex-openKeyCursor"><code>openKeyCursor</code></a>.
              </p>
              <p>
                Otherwise this method runs the <a>steps for asynchronously executing a request</a> and returns the
                <a>IDBRequest</a> created by these steps. The steps are run with this <a>IDBCursor</a> as <var>source</var>
                and the <a>steps for deleting a record from an object store</a> as <var>operation</var>, using this cursor's
                <a>effective object store</a> and <a>effective key</a> as <var>store</var> and <var>key</var> respectively.
              </p>
              <p class="issue">
                This method used to set this cursor's <a title="cursor value">value</a> to <code>null</code>. Do we want to
                keep that?
              </p>
              <dl class="exception" title="IDBDatabaseException">
                <dt>TRANSACTION_INACTIVE_ERR</dt>
                <dd>The <a>transaction</a> this <a>IDBCursor</a> belongs to is not <a>active</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The <a>mode</a> of the <a>transaction</a> this <a>IDBCursor</a> belongs to
                is <code>READ_ONLY</code>. Also thrown if cursor was created using
                <a class="idlType" href="#widl-IDBIndex-openKeyCursor"><code>openKeyCursor</code></a> or if the cursor
                is currently being iterated or has iterated past the end.</dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="transaction">
        <h4>Transaction</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            <a title="transaction">Static transaction</a> objects implement the following interface:
          </p>
          <dl class="idl" title="interface IDBTransaction : EventTarget">
            <dt>const     unsigned short READ_WRITE    = 0</dt>
            <dd>Modification operations are allowed in the <a>transactions</a>
            in this mode.</dd>
            <dt>const     unsigned short READ_ONLY    = 1</dt>
            <dd>Modification operations are not allowed in the <a>transaction</a>
            in this mode.</dd>
            <dt>const     unsigned short VERSION_CHANGE = 2</dt>
            <dd>This mode is used solely for updating the version number of
            transactions started using the <code>setVersion()</code> method of <a><code>IDBDatabase</code></a>.</dd>
            <dt>readonly attribute unsigned short mode</dt>
            <dd>On getting, provide the <a>mode</a> for isolating access to data inside
            the <a title="object store">object stores</a> that are in the
            <a>scope</a> of the <a>transaction</a>.</dd>
            <dt>readonly attribute IDBDatabase db</dt>
            <dd>The <a>database</a> <a>connection</a> of which this <a>transaction</a>
              is a part
            </dd>
            <dt>IDBObjectStore objectStore()</dt>
            <dd>
              Returns a <a>IDBObjectStore</a> representing a <a>object store</a> that is part of the
              to the <a>scope</a> of this <a>transaction</a>. Every call to this function on the same
              <a>IDBTransaction</a> instance and with the same <var>name</var> returns the same <a>IDBObjectStore</a> instance.
              However the retured <a>IDBObjectStore</a> instance is specific to this <a>IDBTransaction</a>. If this
              function is called on a different <a>IDBTransaction</a>, a different <a>IDBObjectStore</a> instance is returned.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The requested <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the requested <a>object store</a> is not in this 
                <a>transaction</a>'s <a>scope</a>.
                </dd>
              </dl>
            </dd>
            <dt>void abort()</dt>
            <dd>
              If this <a>transaction</a> is <a title="transaction finish">finished</a>, throw a NOT_ALLOWED_ERR
              exception. Otherwise this method <a title="transaction abort">aborts</a> the transaction by running the
              <a>steps to abort a transaction</a> with <var>code</var> set to ABORT_ERR.
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>If this <a>transaction</a> has already been committed or aborted.</dd>
              </dl>
            </dd>
            <dt>attribute Function onabort</dt>
            <dd>The event handler for the <a>onabort</a> event.</dd>
            <dt>attribute Function oncomplete</dt>
            <dd>The event handler for the <a>oncomplete</a> event.</dd>
            <dt>attribute Function ontimeout</dt>
            <dd>The event handler for the <a>ontimeout</a> event.</dd>
          </dl>

          <p>
            <a title="dynamic transaction">Dynamic transaction</a> objects implement the following interface:
          </p>
          <dl class="idl" title="interface IDBDynamicTransaction : EventTarget">
            <dt>readonly attribute IDBDatabase db</dt>
            <dd>The <a>database</a> <a>connection</a> of which this <a>transaction</a> is a part.</dd>
            <dt>IDBRequest openObjectStore()</dt>
            <dd>
              Returns immediately and then attempts to lock the requesed <a>object store</a> in the given <a>mode</a>. 
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The requested <a>object store</a>.</dd>
                <dt>optional unsigned short mode</dt>
                <dd>The <a>mode</a> for isolating access to the <a>object store</a>, which defaults to 
                <code>READ_ONLY</code>.</dd>
              </dl>
            </dd>
            <dt>void abort()</dt>
            <dd>
              This method returns immediately and undoes all the changes performed to 
              the <a>objects</a> of this <a>database</a> in this <a>transaction</a>. If this <a>transaction</a> 
              has already been committed or aborted,  then an
              <a title="event-error">error event</a> is fired on this method's
              returned object with its 
              <a class="idlType" href="#widl-IDBErrorEvent-code"><code>code</code></a> set to
              <a class="idlType" href="#widl-IDBDatabaseException-NON_TRANSIENT_ERR"><code>NON_TRANSIENT_ERR</code></a>
              and a suitable 
              <a class="idlType" href="#widl-IDBErrorEvent-message"><code>message</code></a>.
            </dd>
            <dt>attribute Function onabort</dt>
            <dd>The event handler for the <a>onabort</a> event.</dd>
            <dt>attribute Function oncomplete</dt>
            <dd>The event handler for the <a>oncomplete</a> event.</dd>
            <dt>attribute Function ontimeout</dt>
            <dd>The event handler for the <a>ontimeout</a> event.</dd>
          </dl>
          <div class="issue">
            <p>Finish the dynamic transaction IDL and define the behavior of dynamic transactions.</p>
          </div>
        </section>
      </section>
      <section id="sync-database" class="section">
        <h3>Synchronous APIs</h3>
        <section id="opening-sync" class="section">
          <h4>Opening a database</h4>
          <p>
            <a title="Worker" class="externalDFN"><code>Worker</code></a> objects MUST implement the 
            <a><code>IDBEnvironmentSync</code></a> interface.
          </p>
          <p class="idl" title="WorkerUtils implements IDBEnvironmentSync">
          </p>
          
          <dl class="idl" title="[NoInterfaceObject] interface IDBEnvironmentSync">
            <dt>readonly attribute IDBFactorySync indexedDBSync</dt>
            <dd>This attribute provides applications a mechanism for accessing
              capabilities of indexed databases.</dd>
          </dl>
          
          <dl class="idl" title="interface IDBFactorySync">
            <dt>IDBDatabaseSync open()</dt>
            <dd>
              <p>
                When invoked, this method synchronously runs the <a>steps for opening a database</a>.
                Let <var>origin</var> be the origin of the <a>IDBEnvironmentSync</a> used to access
                this <a>IDBFactorySync</a>, <var>name</var> be the <var>name</var> argument passed
                to the function and <var>request</var> be the created <a>IDBRequest</a>.
              </p>
              <p>
                If an error is returned from the steps above, then the implementation MUST
                throw an <a><code>IDBDatabaseException</code></a> with its 
                <a class="idlType" href="#widl-IDBDatabaseException-code"><code>code</code></a>
                and <a class="idlType" href="#widl-IDBDatabaseException-message"><code>message</code></a> set to
                appropriate values for the error.
              </p>
              <p>
                If the steps above are successful, the implementation MUST create a IDBDatabaseSync
                object representing the created <a>connection</a> and return it.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="database name">name</a> for the <a>database</a></dd>
              </dl>
            </dd>
          </dl>
        </section>
        
        <section id="database-interface-sync" class="section">
          <h4>Database</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <dl class="idl" title="interface IDBDatabaseSync">
            <dt>readonly attribute DOMString name</dt>
            <dd>
              On getting, this attribute MUST return the <a title="database name">name</a>
              of the <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMString description</dt>  
            <dd>
              On getting, this attribute MUST return the description of the
              <a title="connection">connected</a> <a>database</a> at the time of opening.
            </dd>
            <dt>readonly attribute DOMString version</dt>
            <dd>
              On getting, this attribute MUST return the <a>version</a> of this
              <a>database</a>. This attribute has the <a>null</a> value when the
              <a title="connection">connected</a> <a>database</a> is first created.
            </dd>
            <dt>readonly attribute DOMStringList objectStoreNames</dt>
            <dd>
              On getting, this attribute MUST return a list of names of the 
              <a title="object store">object stores</a> currently in the 
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <!-- There is no notion of a current transaction any more
            <dt>readonly attribute IDBTransactionSync currentTransaction</dt>
            <dd>
              On getting, this attribute MUST return a <a><code>IDBTransaction</code></a> object
              corresponding to the <a>transaction</a> that is <a>active</a> in this
              <a>database</a> <a>connection</a>.
            </dd>-->
            <dt>IDBObjectStoreSync createObjectStore()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>object store</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of a new <a>object store</a></dd>
                <dt>[Null=Null] DOMString keyPath</dt>
                <dd>The <a title="object store key path">key path</a> of a new 
                <a>object store</a>. If <a>null</a> path is specified, then the 
                <a>object store</a> created will not have a <a>key path</a> and will
                use <a>out-of-line keys</a>.</dd>
                <dt>optional boolean autoIncrement</dt>
                <dd>Whether the <a>object store</a> created should have a 
                <a>key generator</a>. The default
                value of this parameter is false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dt>IDBObjectStoreSync openObjectStore()</dt>
            <dd>
              <p>
                This method opens the <a>object store</a> with the given name
                in the <a title="connection">connected</a> <a>database</a> for the
                <a>mode</a> specified.
              </p>              
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of an existing 
                <a>object store</a></dd>
                <dt>optional unsigned short mode</dt>
                <dd>The <a>mode</a> used to access the <a>object store</a>. The default 
                for this is <a><code>IDBObjectStore</code></a>.<a class="idlType" href="#widl-IDBObjectStore-READ_WRITE"><code>READ_WRITE</code></a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dd>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>index</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void deleteObjectStore()</dt>
            <dd>
              <p>
                This method destroys an <a>object store</a> with the 
                given name as well as all <a title="index">indexes</a> that are 
                <a title="referenced">referencing</a> that <a>object store</a>.
              </p>
              
              <dl class="parameters">
                <dt>DOMString storeName</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name, compared in a
                case-sensitive manner, does not already exist
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void setVersion()</dt>
            <dd>
              This method sets the <a>version</a> of the 
              <a title="connection">connected</a> <a>database</a>.
              <dl class="parameters">
                <dt>[TreatNullAs=EmptyString] DOMString      version</dt>
                <dd>The <a>version</a> to store in the <a>database</a></dd>
              </dl>
            </dd>
            <dt>IDBTransactionSync transaction()</dt>
            <dd>
              <p>
                This method, when called MUST execute the
                <a title="create a static transaction">steps for creating a transaction</a> in a asychronous
                fashion. If the <var>storeNames</var> argument is provided and non-empty then then use that
                list as the <var>names</var> argument. Otherwise use the full set of <a>object store</a>
                names for the <a>IDBDatabase</a> as <var>names</var> argument. The <var>mode<var> and
                <var>timeout</var> arguments are forwarded to the algorithm as-is. The <var>connection</var>
                argument is set to the <a>IDBDatabase</a> that the <code>transaction()</code> method was
                called on.
              </p>
              <p>
                The method returns a <a>IDBTransactionSync</a> object representing the <a>transaction</a>
                returned by the steps above</a>.
              </p>
              <dl class="parameters">
                <dt>optional DOMStringList storeNames</dt>
                <dd>The names of <a title="object store">object stores</a> and 
                <a title="index">indexes</a> in the <a>scope</a> of the new
                <a>transaction</a></dd>
                <dt>optional unsigned long timeout</dt>
                <dd>The interval in milliseconds which this operation is allowed to 
                take to reserve all the <a>database</a> objects identified in the new
                <a title="transaction">transaction's</a> <a>scope</a>. The default
                is user agent specific</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-TIMEOUT_ERR"><code>TIMEOUT_ERR</code></a></dt>
                <dd>
                If <a title="transaction start">starting</a> the transaction takes longer than the specified timeout.
                </dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The close() method has been called on this <a>IDBDatabase</a> instance.</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>One of the names provided in the <var>storeNames</var> argument doesn't exist in this <a>database</a>.</dd>
              </dl>
            </dd>
          </dl>  
        </section>
          
        <section class="section" id="object-store-sync">  
          <h4>Object Store</h4>
          <div class="example">       
            <p>
              In the following example, we set up an <a>object store</a> to use the 
              <a title="object store key path">key path</a> <em>id</em>. This
              <a>object store</a> is also designed to use a <a>key generator</a>.
            </p>
            <codeblock>var db = indexedDB.open('AddressBook', 'Address Book');
if (db.version !== '1') {
   var olddb = indexedDB.open('AddressBook', 'Address Book');
   olddb.createObjectStore('Contact', 'id', true);
   olddb.setVersion('1');
}</codeblock>
            <p>
              Using this <a>database</a>, we can store records in the <em>Contact</em>
              <a>object store</a>. 
            </p>
            <codeblock>var store = db.openObjectStore('Contact');

var lincoln = {name: 'Lincoln', number: '7012'};
var contact = store.put(lincoln);
// contact.id === 1</codeblock>
            <p>
              A stored value can be retrieved using the same key used by the
              first put operation.
            </p>
            <codeblock>var contact = store.get(1);
// contact.name === 'Lincoln'</codeblock>
            <p>
              A second put operation will overwrite the record stored by the first 
              put operation.
            </p>
            <codeblock>var abraham = {id: 1, name: 'Abraham', number: '2107'};
store.put(abraham);</codeblock>
            <p>
              Now when the object store is read with the same key, the result 
              is different compared to the object read earlier.
            </p>
            <codeblock>var contact = store.get(1);
// contact.id === 1 &amp;&amp; contact.name === 'Abraham';</codeblock>
            <p>
              Additionally, all the <a>records</a> of an <a>object store</a> 
              matching a certain <a>key range</a> can be retrieved in key order.
            </p>
            <codeblock>var range = new IDBKeyRange.bound(2, 4);
var cursor = store.openCursor(range);
// each value is a contact and each key is the id for that  
// contact whose id is between 2 and 4, both inclusive
cursor.continue();</codeblock>
          </div>
          
          <dl title="interface IDBObjectStoreSync" class="idl">
            <dt>const     unsigned short READ_WRITE    = 0</dt>
            <dd>Modification operations are allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>const     unsigned short READ_ONLY    = 1</dt>
            <dd>Modification operations are not allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>readonly attribute unsigned short mode</dt>
            <dd>On getting, provide the <a>mode</a> for isolating access to data 
            inside this <a>object store</a>.
            </dd>
            <dt>readonly attribute DOMString      name</dt>
            <dd>          
              On getting, provide the <a title="object store name">name</a> of this
              object store.        
            </dd>
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="object store key path">key path</a>
              of this <a>object store</a>. If this attribute is <code>null</code>,
              the application MUST provide a key value for each modification operation.
            </dd>
            <dt>readonly attribute DOMStringList  indexNames</dt>
            <dd>
            On getting, provide a list of the names of <a title="index">indexes</a> on 
            objects in this <a>object store</a>.
            </dd>
            <dt>any put()</dt>
            <dd>
              Store the given value in this <a>object store</a> by following
              the <a>steps for storing a record into an object store</a>. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>This <a>object store</a> uses <a>out-of-line</a> keys and
                no <a>key generator</a> but the <var>key</var> parameter was not
                passed</dd>
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
              </dl>
            </dd>
            <dt>any add()</dt>
            <dd>
              Store the given value in this <a>object store</a> by following
              the <a>steps for storing a record into an object store</a> with the no-overwrite flag set. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>This <a>object store</a> uses <a>out-of-line</a> keys and
                no <a>key generator</a> but the <var>key</var> parameter was not
                passed</dd>
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
                <dt>CONSTRAINT_ERR</dt>
                <dd>A record
                exists in this <a>object store</a> for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>void delete()</dt>
            <dd>
              Remove the record from this <a>object store</a> by following
              the <a>steps for deleting a record from an object store</a>
              corresponding to the given key.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be deleted</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>object store</a> for the record 
              corresponding to the given key by following the
              <a>steps for retrieving a value from an object store</a>. The
              value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be deserialized by the internal
                structured cloning algorithm</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>IDBIndexSync createIndex()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>index</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>DOMString      name</dt>
                <dd>The <a title="index name">name</a> of a new <a>index</a></dd>
                <dt>DOMString      keyPath</dt>
                <dd>The <a title="index key path">key path</a> used by the new
                <a>index</a></dd>
                <dt>optional boolean unique</dt>
                <dd>The <a>unique</a> flag for the new <a>index</a>. The default
                value of this parameter is false.</dd>
              </dl>
            <dt>IDBIndexSync index()</dt>
            <dd>
              Returns a <a>IDBIndexSync</a> representing a <a>index</a> that is part of the
              to this <a>object store</a>. Every call to this function on the same
              <a>IDBObjectStoreSync</a> instance and with the same <var>name</var> returns the same <a>IDBIndexSync</a> instance.
              However the retured <a>IDBIndexSync</a> instance is specific to this <a>IDBObjectStoreSync</a> instance. If this
              function is called on a different <a>IDBObjectStoreSync</a> instance, a different <a>IDBIndexSync</a> instance is
              returned. A result of this is that different <a>IDBTransactionSync</a>s use different <a>IDBIndexSync</a> instances
              to represent the same <a>index</a>.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>      
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void deleteIndex()</dt>
            <dd>
              <p>
                This method destroys an <a>index</a> with the 
                given name. 
              </p>
              <dl class="parameters">
                <dt>DOMString indexName</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>IDBCursorSync openCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this
              <a>object store</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>. 
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>object store</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>
          </dl>                
        </section>
        <section id="index-sync" class="section">  
          <h4>Index</h4>
          
          <div class="example">
            <p>
              An <a>index</a> can be created for retrieving records other than
              by using record keys. Continuing the earlier example, an auto-populated
              index could be maintained on the <em>name</em> property of objects
              in the <em>Contact</em> <a>object store</a>.
            </p>
            <codeblock>var db = indexedDB.<a>open</a>('AddressBook', 'Address Book');
if (db.version === '1') {
   var olddb = indexedDB.<a>open</a>('AddressBook', 'Address Book');
   olddb.<a>createObjectStore</a>('Contact', 'id', true);
   olddb.<a>createIndex</a>('ContactName', 'Contact', 'name', false);
   olddb.<a>setVersion</a>('2');
}</codeblock>
            <p>
              For example, the <em>id</em> of an object with the <em>name</em> 
              property value 'Lincoln' can be retrieved using the 
              <em>ContactName</em> <a>index</a>.
            </p>
            <codeblock>var index = db.<a>openIndex</a>('ContactName');
var id = index.<a>get</a>('Lincoln');
// id === 1</codeblock>              
            <p>
              Additionally, all the records of an <a>object store</a> matching
              a certain range index keys can be retrieved in key order. When
              objects are retrieved from the <em>Contact</em> <a>object store</a>, 
              they are arranged by the value of the <em>id</em> attribute. On the
              other hand, when objects are retrieved using the <em>ContactName</em>
              <a>index</a>, they are arranged by the value of the <em>name</em> 
              property. 
            </p>
            <codeblock>var range = new <a>IDBKeyRange</a>.<a>bound</a>('L', 'M');
var cursor = index.<a>openCursor</a>(range);
// each value is a contact and each key is the name for that  
// contact whose name's first letter is either L or M
cursor.continue();</codeblock>
            <p>
              If, on the other hand, we only want the names but not the <em>Contact</em>
              objects for a given range, then we can use a different mechanism for that.
            </p>
            <codeblock>var range = new <a>IDBKeyRange</a>.<a>bound</a>('L', 'M');
var cursor = index.<a>openObjectCursor</a>(range);
// each value is a contact and each key is the name for that  
// contact whose name's first letter is either L or M
cursor.continue();</codeblock>
          </div>
              
          <dl class="idl" title="interface IDBIndexSync">
            <dt>readonly attribute DOMString      name</dt>
            <dd>
              On getting, provide the <a title="index name">name</a> of this <a>index</a>.        
            </dd>
            <dt>readonly attribute DOMString      storeName</dt>
            <dd>
              On getting, provide the <a title="object store name">name</a> of this
              <a title="index">index's</a> <a>referenced</a> <a>object store</a>.
            </dd>
        
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="index key path">key path</a> of this
              <a>index</a>. If this attribute is <code>null</code>,
              this <a>index</a> is not <a>auto-populated</a>.
            </dd>
            
            <dt>readonly attribute boolean unique</dt>
            <dd>
              On getting, provide the <a>unique</a> flag of this <a>index</a>.
            </dd>

            <dt>void openCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this 
              <a>index</a>'s <a>referenced</a> <a>object store</a> as arranged by
              this <a>index</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>.
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>index</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>

            <dt>void openKeyCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this 
              <a>index</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>. 
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>index</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>index</a>'s <a>referenced</a>
              <a>object store</a> for the record corresponding to the given key
              by following the <a>steps for retrieving a referenced value from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>any getKey()</dt>
            <dd>
              Retrieve the value from this <a>index</a> for the record 
              corresponding to the given key by following the 
              <a>steps for retrieving a value from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="cursor-sync">  
          <h4>Cursor</h4>
          <p>
            Using the synchronous API, an application can process all the records
            in the <a>cursor</a>'s <a>range</a>. No two values provided by the
            user agent to callbacks processing data in this <a>cursor</a> can be
            identical.
          </p>
          <div class="example">
            <p>
              By default, a <a>cursor</a> walks over objects starting at the
              first record and ending at the last record including
              all the duplicates encountered along the way. If the
              cursor callback returns true, then the iteration is 
              stopped.
            </p>
            <codeblock>var objects = ...
var cursor = objects.openCursor();
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
            
            <p>
              To start at the last record and end in the first record, the cursor 
              should be created with the direction parameter <a class="idlType" href="#widl-IDBCursor-PREV"><code>PREV</code></a>.
            </p>
            <codeblock>var objects = ...
var cursor = objects.openCursor(<a>IDBCursor</a>.<a>PREV</a>);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>

            <p>
              To start at a certain key and end in the last record, i.e.,
              for a lower-bounded cursor, while skipping duplicates,
              the cursor should be created with both the required 
              start key and the direction parameter. 
            </p>
            
            <codeblock>var objects = ...
var range = <a>IDBKeyRange</a>.leftBound(key);
objects.openCursor(range, <a>IDBCursor</a>.<a>NEXT_NO_DUPLICATE</a>);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
        
            <p>
              It is also possible to create a bounded cursor, i.e., with
              application-specified starting and ending points, the
              cursor should be created with both the required keys.
              If the range is inclusive of both keys, then additional
              flags are required. In the following example, all keys
              with values in the inclusive range (<code>start</code>, 
              <code>end</code>) are returned with all their duplicates,
              from the beginning of the range to its end.
            </p>
  
            <codeblock>var objects = ...
var range = <a>IDBKeyRange</a>.bound(start, end);
objects.openCursor(range);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
          </div>
          <dl title="interface IDBCursorSync" class="idl">
            <dt>const     unsigned short     NEXT = 0</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     NEXT_NO_DUPLICATE = 1</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>
            <dt>const     unsigned short     PREV = 2</dt>
            <dd>
              indicates that <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     PREV_NO_DUPLICATE = 3</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>

            <dt>readonly attribute unsigned short     direction</dt>
            <dd>            
            On getting, provide the traversal <a>direction</a> of the <a>cursor</a>.
            </dd>
            <dt>readonly attribute any key</dt>
            <dd>The key for the record at the <a>cursor</a>'s <a>position</a>.</dd>
            <dt>attribute any value</dt>
            <dd>The value for the record at the <a>cursor</a>'s <a>position</a>.
              <dl class="setraises" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>If the underlying <a>object store</a> uses <a>in-line keys</a>
                and the property at the <a title="object store key path">key path</a>
                does not match the key in this <a>cursor</a>'s <a>position</a>.
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The underlying <a>index</a> or <a>object store</a> does not
                support updating the item because it is open in the 
                <a class="idlType" href="#widl-IDBObjectStore-READ_ONLY"><code>READ_ONLY</code></a> <a>mode</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>An index record cannot be changed because the underlying 
                <a>index</a> is <a>auto-populated</a>.</dd>
              </dl>
            </dd>

            <dt>boolean  continue()</dt>
            <dd>
              Advance the <a>cursor</a> to the next position along its <a>direction</a>
              to the item whose key matches the optional parameter. If no such
              parameter is provided, advance to the immediate next position. If
              the <a>cursor</a> has reached the end of its <a>range</a>, then this
              method returns false, otherwise it returns true.
              <dl class="parameters">
                <dt>optional any key</dt>
                <dd>The next key to position this <a>cursor</a> at</dd>
              </dl>
            </dd>
            
            <dt>void    delete()</dt>
            <dd>          
              <p>
                Delete the object at the <a>cursor</a>'s <a>position</a>. The cursor's
                position is not changed. Any attempts to retrieve the cursor's
                current value will return <code>null</code>.
              </p>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The underlying <a>index</a> or <a>object store</a> does not
                support updating the item because it is open in the 
                <a class="idlType" href="#widl-IDBObjectStore-READ_ONLY"><code>READ_ONLY</code></a> <a>mode</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section id="transaction-sync" class="section">
          <h4>Transaction</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            When an application <a title="create a transaction">creates</a> a 
            <a>transaction</a> synchronously, it blocks until the user agent is able
            to reserve the required <a>database</a> <a>objects</a>.
          </p>
          <dl class="idl" title="interface IDBTransactionSync">
            <dt>attribute boolean static</dt>
            <dd>If <code>true</code>, then this <a>transaction</a> is <a>static</a>
              and <code>false</code> otherwise.
            <dt>attribute IDBDatabaseSync db</dt>
            <dd>The <a>database</a> <a>connection</a> of which this <a>transaction</a>
              is a part</dd>
            <dt>IDBObjectStoreSync objectStore()</dt>
            <dd>
              Returns a <a>IDBObjectStoreSync</a> representing a <a>object store</a> that is part of the
              to the <a>scope</a> of this <a>transaction</a>. Every call to this function on the same
              <a>IDBTransactionSync</a> instance and with the same <var>name</var> returns the same <a>IDBObjectStoreSync</a> instance.
              However the retured <a>IDBObjectStoreSync</a> instance is specific to this <a>IDBTransactionSync</a>. If this
              function is called on a different <a>IDBTransactionSync</a>, a different <a>IDBObjectStoreSync</a> instance is returned.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The requested <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the requested <a>object store</a> is not in this 
                <a>transaction</a>'s <a>scope</a>.
                </dd>
              </dl>
            </dd>
            <dt>void abort()</dt>
            <dd>
              If this <a>transaction</a> is <a title="transaction finish">finished</a>, throw a NOT_ALLOWED_ERR
              exception. Otherwise this method <a title="transaction abort">aborts</a> the transaction by running the
              <a>steps to abort a transaction</a> with <var>code</var> set to ABORT_ERR.
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>If this <a>transaction</a> has already been committed or aborted.</dd>
              </dl>
            </dd>
            <dt>void commit()</dt>
            <dd>
              This method signals the normal and satisfactory completion
              of a <a>transaction</a>. At this point, the user agent should durably
              store all the changes performed to the <a>objects</a> of this 
              <a>database</a> since the creation of this <a>transaction</a>.
              <dl class="exception" title="IDBDatabaseException">
                <dt>RECOVERABLE_ERR</dt>
                <dd>If this <a>transaction</a>'s <a>scope</a> is <a>dynamic</a>, and
                the user agent cannot commit all the changes due to another 
                <a>transaction</a>.
                <dt>NON_TRANSIENT_ERR</dt>
                <dd>If this <a>transaction</a> has already been committed or aborted.</dd>
              </dl>
            </dd>
          </dl>
          <div class="note">
            Applications MUST not assume that committing the <a>transaction</a>
            produces an instantaneously durable result. The user agent
            MAY delay flushing data to durable storage until an appropriate
            time.
          </div>
                              
          <p>
            Once a <a>transaction</a> is aborted or committed, the <a>active</a> 
            <a>transaction</a> on this <a>database</a> <a>connection</a> is removed.
            A new <a>transaction</a> can be created to perform operations atomically.
          </p>
        </section> <!-- IDBTransaction -->
       </section>
      </section>
      <section class="section" id="algorithms">
        <h3>Algorithms</h3>
        <section class="section" id="opening">
          <h4>Opening the database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are as follows. The algorithm in these steps
            take three arguments. A <var>origin</var> which requested the <a>database</a> to be opened,
            a database <var>name</var>. It also optionally takes a <var>request</var> which represents
            a <a>request</a> used when opening the database is done using an asynchronous API.
          </p>
          
          <ol>
            <li>
              If these steps fail for any reason, return a error with the appropriate code and abort
              this algorithm.
            </li>
            <li>
              If there is already a database with the given name from the origin <var>origin</var>, then
              let <var>db</var> be that database.
            </li>
            <li>
              If no database with the given name from the origin <var>origin</var>
              exists, then create the database <var>db</var> with name <var>name</var>, with the empty
              string as <a>version</a>, and with no <a>object store</a>s.
            </li>
            <li>
              Wait until no already existing <a>connection</a>s to <var>db</var>, have
              non-<a title="transaction finish">finished</a> VERSION_CHANGE <a>transaction</a>s.
              <p class="note">
                There can potentially be several <a>connection</a>s waiting for a VERSION_CHANGE transaction
                to finish. Once that transaction <a title="transaction finish">finishes</a> another <a>connection</a>
                could be created and a new VERSION_CHANGE transaction could be started before these steps has
                a chance to continue. In that case the implementation MUST keep waiting at this step.
              </p>
            </li>
            <li>
              Create a <a>connection</a> to <var>db</var> and return it.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Transaction Creation steps</h4>
          <p>
            When the user agent is to <dfn>create a static <a>transaction</a></dfn>
            it MUST run the following steps. This algorithm takes four parameters:
            A <a><var>connection</var></a>, a <a><var>mode</var></a>, a list of <var>names</var> of
            <a>object store</a>s to be included in the <a>scope</a> of the transaction, and a
            <var>timeout</var> for the transaction <a title="transaction start">starting</a>.
          </p>
          
          <ol>
            <li>
              If any of the strings in <var>names</var> identifies an <a>object store</a> which doesn't
              exist, throw a NOT_FOUND_ERR exception. If the <a>closePending</a>
              flag is set on <var>connection</var> the throw a NOT_ALLOWED_ERR.
            </li>
            <li>
              <a title="transaction create">Create</a> a <a>transaction</a> using <var>connection</var> as
              <a>connection</a>, <var>mode</var> as <a>mode</a>, and the <a>object store</a>s identified in
              <var>names</var> as <a>scope</a>.
            </li>
            <li>
              If these steps are running asynchronously, return the created <a>transaction</a> and run the
              remaining steps asynchronously. When control is returned to the event loop, the implementation
              MUST set the <a>active</a> flag to false.
            </li>
            <li>
              Wait until the <a>transaction</a> can be <a title="transaction start">started</a> according to the
              <a>transaction lifetime</a> rules. If this takes longer than the specified <var>timeout</var> then:
              <ul>
                <li>
                  If these steps are run asynchronously, run the <a>steps for aborting a transaction</a> using
                  TIMEOUT_ERR as <var>code</var>.
                </li>
                <li>
                  If steps are run synchronously, throw a TIMEOUT_ERR exception.
                </li>
              </ul>
            </li>
            <li>
              If these steps are running synchronously, return the created <a>transaction</a>.
            </li>
          </ol>
          <div class="issue">
            <p>Add steps for creating dynamic transactions.</p>
          </div>     
        </section>
        <section class="section">
          <h4>Steps for aborting a transaction</h4>
          <p>
            When taking the <dfn>steps for aborting a <a>transaction</a></dfn> the implementation MUST
            execute the following algorithm. This algorithm takes two parameter, the <var>transaction</var> to abort
            and a <var>code</var>.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> the transaction uses are reverted. For VERSION_CHANGE
              transactions this includes changes to the set of <a>object store</a>s and <a>index</a>es, as well
              as the change to the <a>version</a>.
            </li>
            <li>
              If the transaction's <a>request list</a> contain any <a>request</a>s whose <a title="request done">done</a> flag
              is still false, <a>fire a error event</a> with code <var>code</code> against each such <a>request</a>
              and set its <a title="request done">done</a> flag to true. Also abort the <a>steps for asynchronously
              executing a request</a> for each such transaction.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for asynchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and a <var>operation</var> to
            perform on a database.
          </p>
          <p>
            These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
            to is <a title="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with <var>source</var>.
            </li>
            <li>
              If <var>transaction</var> is not <a>active</a> throw a TRANSACTION_INACTIVE_ERR exception.
            </li>
            <li>
              Create a <a>IDBRequest</a> object and set <var>request</var> to this object. Set <var>request</var>'s
              <a title="request source">source</a> to <var>source</var> and add <var>request</var> to the end of the
              <a title="request list">list</a> of <a>request</a>s in <var>transaction</var>. Return
              this object and run the remaining steps in this algorithm asynchronously.
              <p class="note">
                Cursors override this step to reuse an existing <a>IDBRequest</a>. However they still put the
                <a>IDBRequest</a> at the end of the list of <a>request</a>s in <var>transaction</var>.
              </p>
            </li>
            <li>
              Wait until all previously added <a>requests<a> in <var>transaction</var> have their
              <a title="request done">done</a> flag set to true.
            </li>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then set the <a title="request done">done</a> flag
              on the <var>request</var> to true and <a>fire a success event</a> at <var>request</var> with
              the result of the operation.
            </li>
            <li>
              If performing <var>operation</var> failed then revert all changes made by <var>operation</var>,
              set the <a title="request done">done</a> flag on the <var>request</var> to true and
              <a>fire a error event</a> at <var>request</var> with the code of the error from <var>operation</var>.
              <div class="note">
                This only reverts the changes done by this request, not any other changes made by the transaction.
              </div>
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Steps for synchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps to a synchronously execute a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>transaction</var> object and a <var>operation</var> to
            perform on a database.
          </p>
          <ol>
            <li>
              Perform <var>operation</var>.
            </li>
            <li>
              If performing <var>operation</var> succeeded then set return the result of the operation.
            </li>
            <li>
              If performing <var>operation</var> failed then throw a IDBDatabaseException with the code
              of the error from <var>operation</var>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>VERSION_CHANGE transaction steps</h4>
          <p>
            The <dfn>steps for running a <code>VERSION_CHANGE</code> transaction</dfn> are
            as follows. This algorithm takes two parameters - a <var>connection</var> object which is used
            to update the <a>database</a> and a new <var>version number</var> to be set for the <a>database</a>.
          </p>
          <ol>
            <li>
              Create a new <a>transaction</a> with <a>mode</a> set to VERSION_CHANGE and <var>connection</var> used as <a>connection</a>.
              The <a>scope</a> of the transaction includes every <a>object store</a> in <var>connection</var>. Set its
              <a>active</a> flag to false.
            </li>
            <li>
              Create a new <a>request</a> which uses the <a>IDBVersionChangeRequest</a> interface and return it.
              The remaining steps in this algorithm are run asynchronously.
            </li>
            <li>
              Let <var>openDatabases</var> be the set of all <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
              objects, except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.
            </li>
            <li>
              <p>
                Fire a <code>versionchange</code> event at each object in <var>openDatabases</var> that is open. The event MUST NOT
                be fired on objects which has the <code>closePending</code> flag set. The event MUST use the
                <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <var>version number</var>.
                This event MUST NOT bubble or be cancelable.
              </p>
              <p class="note">
                Firing this event might cause one or more of the other objects in <var>openDatabases</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </p>
            </li>
            <li>
              <p>
                If any of the <a>connection</a>s in <var>openDatabases</var> are still not closed, fire a <code>blocked</code> event at
                <var>request</var>. The event MUST use the <a><code>IDBVersionChangeEvent</code></a> interface and have the
                <a href="#widl-IDBVersionChangeEvent-version"><code>version</code></a> property set to <var>version number</var>.
                This event MUST NOT bubble or be cancelable.
              </p>
            </li>
            <li id="VERSION_CHANGE-close-block">
              Wait until all objects in <var>openDatabases</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
              <p class="issue">Should we allow <code>blocked</code> to be fired here too, if waiting takes "too long"?</p>.
            </li>
            <li>
              Start a the <a>transaction</a> created above. Note that until this <a>transaction</a> is finished, no other <a>connection</a>s
              can be opened to the same <a>database</a>.
            </li>
            <li>
              Set the version of <var>database</var> to the given <var>version number</var>. This change is considered part of the
              <a><code>transaction</code></a>, and so if the transaction is <a>abort</a>ed, this change is reverted.
            </li>
            <li>
              Fire a <a><code>success</code></a> event targeted at the <var>request</var> object. The <a><code>result</code></a>
              propety of the event should be set to a new <a><code>IDBTransaction</code></a> object representing the
              <a><code>VERSION_CHANGE</code></a> transaction created in step 4.
            </li>
            <li>
              Follow the normal steps for executing a <a><code>transaction</code></a> and let the <a><code>transaction</code></a>
              finish normally.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Database closing steps</h4>
          <p>The <dfn>steps for closing a database connection</dfn> are as follows. These steps take one argument, a <var>connection</var> object.
          <ol>
            <li>
              Set the internal <a><code>closePending</code></a> flag of <var>connection</var> to true.
            </li>
            <li>
              Wait for all transactions <a title="transaction create">created</a> using <var>connection</var> to complete.
              Once they are complete, <var>connection</var> is <dfn title="database close">closed</dfn>.
            </li>
          </ol>
          <p class="note">
            Once the <a><code>closePending</code></a> flag has ben set to true no new transactions can be
            <a title="transaction create">created</a> using <var>connection</var>. All functions that
            <a title="transaction create">create</a> transactions first check the the <a>closePending</a> flag first and
            throw an exception if it is true.
          </p>
          <p class="note">
            Once the <a>connection</a> is closed, this can unblock the <a>steps for running a <code>VERSION_CHANGE</code>
            transaction</a>, which <a href="#VERSION_CHANGE-close-block">wait</a> for <a>connection</a>s to a given
            <a>database</a> to be closed before continuing.
          </p>
        </section>
        <section class="section">
          <h4>Fire a success event</h4>
          <p>
            To <dfn title="fire a success event">fire a success event with result <var>result</var></dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch a <a title="event-success">success event</a>, which does not bubble and is not
              cancelable, at <a>request</a>. The event must use the <a><code>IDBSuccessEvent</code></a> interface and have its 
              <a class="idlType" href="#widl-IDBSuccessEvent-result"><code>result</code></a> set to <var>result</var>. The
              <a class="idlType" href="#widl-IDBEvent-source"><code>source</code></a> is set to <var>request</var>s
              <a title="request source">source</a>. And <a class="idlType" href="#widl-IDBTransactionEvent-result"><code>transaction</code></a>
              is set to <var>transaction</var>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Fire an error event</h4>
          <p>
            To <dfn title="fire a error event">fire a error event with code <var>code</var></dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to true.
            </li>
            <li>
              Dispatch a <a title="event-error">error event</a> at <a>request</a>. The event must use
              the <a><code>IDBErrorEvent</code></a> interface and have its 
              <a class="idlType" href="#widl-IDBErrorEvent-code"><code>code</code></a> set to <var>code</var>. The
              <a class="idlType" href="#widl-IDBEvent-source"><code>source</code></a> is set to <var>request</var>s internal
              <a title="request source">source</a>. The <a class="idlType" href="#widl-IDBErrorEvent-message"><code>message</code></a> is
              set to a string appropriate for <var>code</var>.
            <li>
              Set the <a>active</a> flag of <var>transaction</var> to false.
            </li>
          </ol>
          <p class="issue">
            TODO: need to define more error handling here.
          </p>
        </section>
      </section>
      <section class="section" id="database operations">
        <h3>Database operations</h3>
        <p>
          This section describes various operations done on the data in <a>object store</a>s and <a>index</a>es
          in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a> and
          the <a>steps for synchronously executing a request</a>.
        </p>
        <section class="section">
          <h4>Object Store Storage Operation</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> are as follows. 
            The algorithm run by these steps takes four parameters: a object store <var>store</var>,
            a <var>value</var>, an optional <var>key</var>, and a <var>no-overwrite flag</var>.
          </p>
          <ol>
            <li>
              If <var>store</var> uses a <a>key generator</a> set and <var>key</var> is undefined, set
              <var>key</var> to the next generated key. If <var>store</var> also uses <a>in-line keys</a>,
              then set the property in <var>value</var> pointed to by <var>store</var>'s
              <a title="object store key path">key path</a> to the new value for <var>key</var>
            </li>
            <li>
              If <var>store</var> does not use a <a>key generator</a> but does use <a>in-line keys</a>, then set
              <var>key</var> to the the result of <a title="evaluate key path">evaluting</a>
              <a title="object store key path"><var>store</var>'s key path</a> on <var>value</var>.
            </li>
            <li>
              If the no-overwrite flag was passed to these steps and is set, and 
              a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              terminate these steps and set error code to
              <a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a>
              and abort this algorithm without taking any further steps.
            </li>
            <li>
              If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then 
              remove the <a>record</a> from <a>store</a> using the <a>steps for deleting a record from an object store</a>.
            </li>
            <li>
              Store a record in <var>store</var> containing <var>key</var> as its key and <var>object</var> as its
              value. The record is stored in the the object store's <a title="objec store record list">list</a> such
              that the list is sorted according key of the records in ascending order.
            </li>
            <li>
              If there are any <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, perform the
              following sub steps on each such index.
              <ol>
                <li>
                  Set <var>index</var> to the index.
                </li>
                <li>
                  <a title="evaluate key path">Evaluate</a> <var>index</var>'s <a title="index key path">key path</a> on
                  <var>value</var>. If this does not yield a value don't take any further actions for this index.
                  Otherwise set the result to <var>index key</var>.
                  <div class="note">
                    The places invoking these steps ensures that <var>index key</var> is always a <a>valid key</a> at this
                    point.
                </li>
                <li>
                  If <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
                  and <var>index</var> has it's <a>unique</a> flag set to true, then set error code to CONSTRAINT_ERR and
                  abort this algorithm without taking any further steps.
                </li>
                <li>
                  Store a record in <var>index</var> containig <var>index key</var> as its key and <var>key</var> as its
                  value. The record is stored in <var>index</var>'s <a title="index record list">list of records</a> such
                  that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
                  order.
                </li>
              </ol>
            </li>
            <li>
              The result of this algorithm is <var>key</var>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an object store</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>object store</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>store</var> be the <a>object
              store</a> passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then retreive the <a>record</a>
              with key <var>key</var> from <var>store</var>. If <var>key</var> is a <a>key range</a>, then
              retreive the first <a>record</a> from <var>store</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found in the previous step,
              then terminate these steps and set error code
              <a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a>.
            </li>
            <li>
              The result of this algorithm is a new <a>structured clone</a> of the value in the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Referenced Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a referenced value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found in the previous step, then the algorithm failed with a
              <a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code> error</a>.
            </li>
            <li>
              Otherwise, the result of the operation is the <a>referenced value</a> of the found record.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Index Value Retrieval Operation</h4>
          <p>
            The <dfn>steps for retrieving a value from an index</dfn> are
            as follows. These steps MUST be run with two parameters - the record 
            key and the <a>index</a>.
          </p>
            
          <ol>
            <li>
              Let <var>key</var> be the key and <var>index</var> be the <a>index</a>
              passed to these steps.
            </li>
            <li>
              If <var>key</var> is not a <a>key range</a> then find the first <a>record</a>
              with key <var>key</var> from <var>index</var>. If <var>key</var> is a <a>key range</a>, then
              find the first <a>record</a> from <var>index</var> whose key is <a title="in a key range">in</a> <var>key</var>.
            </li>
            <li>
              If no record was found in the previous step, then the algorithm failed with a
              <a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code> error</a>.
            </li>
            <li>
              If a record was found, the result of this algorithm is the <a>value</a> of the found <a>record</a>.
            </li>
          </ol>
        </section>
        
        <section class="section">
          <h4>Object Store Deletion Operation</h4>
          <p>
            The <dfn>steps for deleting a record from an object store</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: a object store <var>store</var> and
            a <var>key</var>.
          </p>
          <ol>
            <li>
              If no <a>record</a> exists with key <var>key</var> in <var>store</var>,
              then terminate these steps and set error code
              <a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a>.
              <p class="issue">
                Should we instead return a boolean indicating if a record was found or not?
              </p>
            </li>            
            <li>
               Remove the record from <var>store</var> with key <var>key</var>.
            </li>
            <li>
              In all <a>index</a>es which <a title="referenced">reference</a> <var>store</var>, remove all
              <a>records</a> with value <var>key</var>.
            </li>
            <li>
              The result of this algorithm is <code>undefined</code>.
            </li>
          </ol>
        </section>
        <section class="section">
          <h4>Cursor Iteration Operation</h4>
          <p>
            The <dfn>steps for iterating a cursor</dfn> are as follows. 
            The algorithm run by these steps takes two parameters: a <var>cursor</var> and optional
            <var>key</var> to iterate to.
          </p>
          <ol>
            <li>
              Let <var>source</var> be <var>cursor</var>'s <a title="cursor source">source</a>, let
              <var>records</var> be list of <a>records</a> in <var>source</var>, let <var>direction</var>
              be <var>cursor</var>'s <a>direction</a>, let <var>position</var> be <var>cursor</var>'s
              <a>position</a>, let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>
              and let <var>range</var> be <var>cursor</var>'s <a>range</a>.
              <p class="note">
                <var>source</var> is always a <a>object store</a> or a <a>index</a>.
              </p>
              <p class="note">
                <var>records</var> is always sorted in ascending <a>key</a> order. In the case of
                <var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
                <a>value</a> order.
              </p>
            </li>

            <li>
              <p>
                If <var>direction</var> is NEXT, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is a <a>object store</a>, the record's
                  key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
                  <var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is NEXT_NO_DUPLICATE, let <var>found record</var> be the first record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is PREV, let <var>found record</var> be the last record in <var>records</var> which
                satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is a <a>object store</a>, the record's
                  key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                  key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
                  <var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>direction</var> is PREV_NO_DUPLICATE, let <var>temp record</var> be the last record in
                <var>records</var> which satisfy all of the following requirements:
              </p>
              <ul>
                <li>
                  If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                </li>
                <li>
                  If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.
                </li>
                <li>
                  If <var>range</var> is defined, the record's key is <a title="in a key range">in</a> <var>range</var>.
                </li>
              </ul>
              <p>
                If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
                whose key is <a>equal to</a> <var>temp record</var>'s key.
              </p>
            </li>
            <li>
              If <var>found record</var> is not defined, the result of this algorithm is <code>undefined</code>. Abort these steps.
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a>position</a> to <var>found record</var>'s key. If <var>source</var> is a <a>index</a>,
                set <var>cursor</var>'s <a>object store position</a> to <var>found record</var>'s value.
              </p>
            </li>
            <li>
              <p>
                Set <var>cursor</var>'s <a title="cursor key">key</a> to <var>found record</var>'s key.
              </p>
              <p>
                If <var>cursor</var> was created using <a href="#widl-IDBIndex-openCursor"><code>IDBIndex.openCursor</code></a> or
                <a href="#widl-IDBIndexSync-openCursor"><code>IDBIndexSync.openCursor</code></a>, then set
                <var>cursor</var>'s <a title="cursor value">value</a> to <var>found record</var> <a>referenced value</a>. Otherwise, set
                <var>cursor</var>'s <a title="cursor value">value</a> to the value of <var>found record</var>.
              </p>
            </li>
            <li>
              Set <var>cursor</var>'s <a>got value</a> flag to true.
              <p class="issue">
                This should only be done right before firing the success event. Not asynchronously before. Not sure
                how/where to express that.
              </p>
            </li>
            <li>
              The result of the algorithm is <var>cursor</var>.
            </li>
          </ol>
        </section>
      </section>

  <!-- database-api -->


	    <section id="privacy" class="section">
      <h2>Privacy</h2>
      
      <section id="user-tracking" class="section">
        <h3>User tracking</h3>
        
        <p>
          A third-party host (or any object capable of getting content 
          distributed to multiple sites) could use a unique identifier 
          stored in its client-side database to track a user across multiple 
          sessions, building a profile of the user's activities. In conjunction
          with a site that is aware of the user's real id object (for 
          example an e-commerce site that requires authenticated credentials),
          this could allow oppressive groups to target individuals with
          greater accuracy than in a world with purely anonymous Web usage.
        </p>
        
        <p>
          There are a number of techniques that can be used to mitigate the
          risk of user tracking:
        </p>
        
        <dl>
          <dt>Blocking third-party storage</dt>
          <dd>
            User agents MAY restrict access to the database objects
            to scripts originating at the domain of the top-level document of
            the <span>browsing context</span>, for instance denying access to
            the API for pages from other domains running in <code>iframe</code>s.
          </dd>

          <dt>Expiring stored data</dt>
          <dd>
            <p>User agents MAY automatically delete stored data after a period
            of time.</p>

            <p>This can restrict the ability of a site to track a user, as the
            site would then only be able to track the user across multiple
            sessions when he authenticates with the site itself (e.g. by
            making a purchase or logging in to a service).</p>
        
            <p>However, this also puts the user's data at risk.</p>
          </dd>

          <dt>Treating persistent storage as cookies</dt>
          <dd>          
            <p>User agents should present the database feature
            to the user in a way that associates them strongly with HTTP
            session cookies. [[!COOKIES]]</p>
        
            <p>This might encourage users to view such storage with healthy
            suspicion.</p>
          </dd>

          <dt>Site-specific white-listing of access to databases</dt>
          <dd>
            <p>User agents MAY require the user to authorize access to
            databases before a site can use the feature.</p>
          </dd>
      
          <dt>Origin-tracking of stored data</dt>          
          <dd>
            <p>User agents MAY record the <span title="origin">origins</span>
            of sites that contained content from third-party origins that
            caused data to be stored.</p>
            
            <p>If this information is then used to present the view of data
            currently in persistent storage, it would allow the user to make
            informed decisions about which parts of the persistent storage to
            prune. Combined with a blacklist ("delete this data and prevent
            this domain from ever storing data again"), the user can restrict
            the use of persistent storage to sites that he trusts.</p>
          </dd>
      
          <dt>Shared blacklists</dt>
          <dd>          
            <p>User agents MAY allow users to share their persistent storage
            domain blacklists.</p>
      
            <p>This would allow communities to act together to protect their
            privacy.</p>
          </dd>
        </dl>

        <p>
          While these suggestions prevent trivial use of this API for user
          tracking, they do not block it altogether. Within a single domain, a
          site can continue to track the user during a session, and can then
          pass all this information to the third party along with any
          identifying information (names, credit card numbers, addresses)
          obtained by the site. If a third party cooperates with multiple
          sites to obtain such information, a profile can still be
          created.
        </p>
        
        <p>
          However, user tracking is to some extent possible even with no
          cooperation from the user agent whatsoever, for instance by using
          session identifiers in URLs, a technique already commonly used for
          innocuous purposes but easily repurposed for user tracking (even
          retroactively). This information can then be shared with other
          sites, using using visitors' IP addresses and other user-specific
          data (e.g. user-agent headers and configuration settings) to combine
          separate sessions into coherent user profiles.          
        </p>
      </section>

      <section id="cookie-resurrection" class="section">
        <h3>Cookie resurrection</h3>
        
        <p>
          If the user interface for persistent storage presents data in the
          persistent storage features described in this specification
          separately from data in HTTP session cookies, then users are likely
          to delete data in one and not the other. This would allow sites to
          use the two features as redundant backup for each other, defeating a
          user's attempts to protect his privacy.
        </p>
      </section>
      
      <section id="sensitivity-of-data" class="section">
        <h3>Sensitivity of data</h3>
        
        <p>
          User agents should treat persistently stored data as potentially
          sensitive; it's quite possible for e-mails, calendar appointments,
          health records, or other confidential documents to be stored in this
          mechanism.
        </p>
        
        <p>To this end, user agents should ensure that when deleting data,
          it is promptly deleted from the underlying storage.
        </p>
      </section>
    </section> <!-- Privacy -->

    <section id="authorization" class="section">
      <h2>Authorization</h2>
      
      <section id="dns-spoofing-attacks" class="section">
        <h3>DNS spoofing attacks</h3>
        
        <p>
          Because of the potential for DNS spoofing attacks, one cannot
          guarantee that a host claiming to be in a certain domain really is
          from that domain. To mitigate this, pages can use SSL. Pages using
          SSL can be sure that only pages using SSL that have certificates
          identifying them as being from the same domain can access their
          databases.
        </p>
      </section>
  
      <section id="cross-directory-attacks" class="section">
        <h3>Cross-directory attacks</h3>
        
        <p>
          Different authors sharing one host name, for example users
          hosting content on <code>geocities.com</code>, all share one
          set of databases.
        </p>
        
        <p>
          There is no feature to restrict the access by pathname. Authors on
          shared hosts are therefore recommended to avoid using these
          features, as it would be trivial for other authors to read the data
          and overwrite it.
        </p>
        
        <p class="note">Even if a path-restriction feature was made
          available, the usual DOM scripting security model would make it
          trivial to bypass this protection and access the data from any
          path.
        </p>
      </section>
      
      <section id="implementation-risks" class="section">
        <h3>Implementation risks</h3>
        
        <p>The two primary risks when implementing these persistent storage
        features are letting hostile sites read information from other
        domains, and letting hostile sites write information that is then
        read from other domains.</p>
        
        <p>Letting third-party sites read data that is not supposed to be
        read from their domain causes <em>information leakage</em>, For
        example, a user's shopping wish list on one domain could be used by
        another domain for targeted advertising; or a user's
        work-in-progress confidential documents stored by a word-processing
        site could be examined by the site of a competing company.</p>
        
        <p>Letting third-party sites write data to the persistent storage of
        other domains can result in <em>information spoofing</em>, which is
        equally dangerous. For example, a hostile site could add records to a
        user's wish list; or a hostile site could set a user's session
        identifier to a known ID that the hostile site can then use to track
        the user's actions on the victim site.</p>
        
        <p>Thus, strictly following the <span>origin</span> model described
        in this specification is important for user security.</p>
      </section>
    </section> <!-- authorization -->
    
    <section class="appendix section" id="requirements">
      <h2>Requirements</h2>
      <div class="ednote">
        Requirements will be written with an aim to verify that these were actually
        met by the API specified in this document.
      </div>
    </section>
    <section class="section appendix" id="acknowledgements">
      <h2>Acknowledgements</h2>
      <div>
        The editor of this specification was employed by Oracle Corp during its early 
        drafts.
      </div>
      <div>
        Garret Swart was extremely influential in the design of this specification.
        Feedback from Margo Seltzer, Jonas Sicking, Arun Ranganathan, Shawn Wilsher,
        Pablo Castro, Kris Zyp, Chris Anderson, and Dana Florescu have led to
        improvements to this specification over time.
      </div>
    </section>


  </body>
</html>
