<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graff", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" },
              { name: "Jeremy Orlow", url: "mailto:jorlow@google.com",
                company: "Google" },
              { name: "Joshua Bell", url: "mailto:jsbell@google.com",
                company: "Google" }
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",

          // Please do not use this "idlOldStyleExceptions" mechanism in other
          // specs. Exceptions should be described normatively in the prose and
          // define consider the order for which exceptional conditions will be
          // tested. See: https://www.w3.org/Bugs/Public/show_bug.cgi?id=17681
          idlOldStyleExceptions: true,

          noIDLSectionTitle: true,
      };
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      aside>.example-title>span {
          display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple
        values and hierarchical objects. Each record consists of a key and some
        value. Moreover, the database maintains indexes over records it stores.
        An application developer directly uses an API to locate records either
        by their key or by using an index. A query language can be layered on
        this API. An indexed database can be implemented using a persistent
        B-tree data structure.
      </p>
    </section>


    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>

      <!-- begin-content -->
      <section id="constructs" class="section">
      <h3>Constructs</h3>
       <section id="database-concept" class="section">
          <h4>Database</h4>
          <p>
          	A database's <a>origin</a> is the same as the <a>origin</a> of the document or <a>worker</a>.
          	Each <a>origin</a> has an associated set of databases.
          </p>
          <p class="note">The database origin is not affected by changes to <code>document.domain</code>.
		  </p>
          <p>
            Each <a>origin</a> has an associated set of
            <a title="database">databases</a>. A <dfn>database</dfn> comprises
            one or more <a title="object store">object stores</a> which hold the data stored
            in the database.
          </p>
          <p>
            Every <a>database</a> has a <dfn title="database name">name</dfn> which identifies it
            within a specific <a>origin</a>. The name can be any string value, including the empty string, and
            stays constant for the lifetime of the database. Each <a>database</a> also has a current
            <dfn>version</dfn>. When a database is first created, its <a>version</a> is 0.
          </p>
          <p class="note">
            Implementations MUST support all names. If an implementation
            uses a storage mechanism which can't handle arbitrary database names,
            the implementation must use an escaping mechanism or something similar
            to map the provided name to a name that it can handle.
          </p>
          <p class="note">
            Each <a>database</a> has one version at a time; a <a>database</a>
            can't exist in multiple versions at once. The only way to change the version is using a <code>"versionchange"</code>
            <a>transaction</a>.
          </p>
          <p>
            Databases has a <dfn>delete pending</dfn> flag which is used during deletion. When a database is requested
            to be deleted the flag is set to true and all attempts at opening the database are stalled until the database
            can be deleted.
          </p>
          <p>
            The act of opening a <a>database</a> creates a <dfn>connection</dfn>. There MAY be multiple
            <a>connection</a>s to a given <a>database</a> at any given time. Each connection has a
            <dfn>closePending</dfn> flag which initially is set to false.
          </p>
          <p>
            When a <a>connection</a> is initially created it is in <var>opened</var> state. The connection
            can be <dfn title="database close">closed</dfn> through several means. If the connection is GCed
            or execution context where the <a>connection</a> is created is destroyed (for example due to the
            user navigating away from that page), the connection is closed. The connection can also be closed
            explicitly using the <a>steps for closing a database connection</a>. When the connection is closed
            the <a>closePending</a> flag is always set to true if it hasn't already been.
          </p>
          <p>
            The <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
            interfaces represent a <a>connection</a> to a <a>database</a>.
          </p>
        </section>  <!-- IDBDatabase -->

        <section class="section" id="object-store-concept">
          <h4>Object Store</h4>
          <p>
            An <dfn>object store</dfn> is the primary storage mechanism for storing data in a
            <a>database</a>.
          </p>
          <p>
            Each database contain a set of <a>object store</a>s. The set of <a>object store</a>s can be changed,
            but can only be changed using a <code>"versionchange"</code> transactions, i.e. in response to a
            <code>upgradeneeded</code> event. When a new database is created it doesn't contain any <a>object store</a>s.
          </p>
          <p>
            The object store has a <a title="object store record list">list of records</a> which hold the
            data stored in the object store. Each <dfn>record</dfn> consists of a <dfn>key</dfn> and a <dfn>value</dfn>.
            The list is sorted according to key in ascending order. There can never be multiple records in a given object
            store with the same key.
          </p>
          <p>
            Every <a>object store</a> has a <dfn title="object store name">name</dfn>.
            The name is unique within the <a>database</a> to which it belongs. Every object store also optionally has a
            <a>key generator</a> and an optional <dfn title="object store key path">key path</dfn>.
            If the object store has a key path it is said to use <dfn>in-line keys</dfn>. Otherwise it is said to
            use <dfn>out-of-line</dfn> keys.
          </p>
          <p>
            The object store can derive the <a>key</a> from one of three sources:
          </p>
          <ol>
            <li>
              A <a>key generator</a>. A key generator generates a monotonically increasing numbers every time
              a key is needed.
            </li>
            <li>
              Keys can be derived via a <a title="object store key path">key path</a>.
            </li>
            <li>
              Keys can also be explicitly specified when a <a>value</a> is stored in the object store.
            </li>
          </ol>
          <p>
            The <a><code>IDBObjectStore</code></a> and <a><code>IDBObjectStoreSync</code></a>
            interfaces represent an <a>object store</a>. Note however that multiple instances of those
            interfaces representing the same <a>object store</a> can exist.
          </p>
        </section> <!-- Object store -->

        <section id="key-construct" class="section">
          <h4>Keys</h4>
          <p>
            In order to efficiently retrieve <a>record</a>s stored in an indexed database,
            each <a>record</a> is organized according to its <dfn>key</dfn>. A value is said to be a <dfn>valid key</dfn>
            if it is one of the following types:
            <code>Array</code> JavaScript objects [[!ECMA-262]], <code>DOMString</code> [[!WEBIDL]],
            <code>Date</code> [[!ECMA-262]] or <code>float</code> [[!WEBIDL]].
            However <code>Array</code>s are only <a>valid key</a>s if every item in the array is defined and is
            a <a>valid key</a> (i.e. sparse arrays can not be <a>valid key</a>s) and if the <code>Array</code> doesn't directly or
            indirectly contain itself.
            Any non-numeric properties are ignored, and thus does not affect whether the <code>Array</code> is a <a>valid key</a>.
            Additionally, if the value is of type <code>float</code>, it is only a <a>valid key</a> if it is not <code>NaN</code>,
            and if the value is of type <code>Date</code> it is only a <a>valid key</a> if its <code>[<span>[</span>PrimitiveValue]]</code>
            internal property, as defined by [[!ECMA-262]], is not <code>NaN</code>.
            <a>Conforming user agents</a> MUST support all <a>valid key</a>s as keys.
          </p>
          <p class="note">
            Infinite <code>float</code> values are <a>valid key</a>s. As are empty <code>Array</code>s.
          </p>
          <p>
            For purposes of comparison, all <code>Array</code>s are greater than all <code>DOMString</code>,
            <code>Date</code> and <code>float</code> values; all <code>DOMString</code> values are greater than all
            <code>Date</code> and <code>float</code> values; and all <code>Date</code> values are greater than all
            <code>float</code> values. Values of type <code>float</code> are compared to other <code>float</code> values
            numerically. Values of type <code>Date</code> are compared to other <code>Date</code> values chronologically.
            Values of type <code>DOMString</code> are compared to other values of type <code>DOMString</code>
            by using the algorithm defined by step 4 of <cite>section 11.8.5, The Abstract Relational Comparison Algorithm</cite>,
            of the ECMAScript Language Specification [[!ECMA-262]].
            Values of type <code>Array</code> are compared to other values of type <code>Array</code> as follows:
          </p>
          <ol>
            <li>
              Let <var>A</var> be the first <code>Array</code> value and <var>B</var> be the second <code>Array</code>
              value.
            </li>
            <li>
              Let <var>length</var> be the lesser of <var>A</var>'s length and <var>B</var>'s length.
            </li>
            <li>
              Let <var>i</var> be 0.
            </li>
            <li>
              If the <var>i</var>th value of <var>A</var> is <a>less than</a> the <var>i</var>th value of
              <var>B</var>, then <var>A</var> is less than <var>B</var>. Skip the remaining steps.
            </li>
            <li>
              If the <var>i</var>th value of <var>A</var> is <a>greater than</a> the <var>i</var>th value of
              <var>B</var>, then <var>A</var> is greater than <var>B</var>. Skip the remaining steps.
            </li>
            <li>
              Increase <var>i</var> by 1.
            </li>
            <li>
              If <var>i</var> is not equal to <var>length</var>, go back to step 4. Otherwise continue to next step.
            </li>
            <li>
              If <var>A</var>'s length is less than <var>B</var>'s length, then <var>A</var> is less
              than <var>B</var>. If <var>A</var>'s length is greater than <var>B</var>'s length, then
              <var>A</var> is greater than <var>B</var>. Otherwise <var>A</var> and <var>B</var> are equal.
            </li>
          </ol>
          <p class="note">
            Note that <code>Array</code>s that contain other <code>Array</code>s are allowed as <a>valid key</a>s.
            In this case the algorithm above runs recursively when comparing the individual values in the arrays.
          </p>
          <p class="note">
            As a result of the above rules, negative infinity is the lowest possible value for a key.
            There is no highest possible key value.
            This is because an array of any candidate highest key followed by another valid key is even higher.
          </p>
          <p>
            The terms <dfn>greater than</dfn>, <dfn>less than</dfn> and <dfn>equal to</dfn> is defined in the terms of
            the above comparisons.
          </p>
          <p>
            The following examples illustrate the different behaviors when trying to use in-line <a>key</a>s and <a>key generator</a>s
            to save an object to an <a>object store</a>.
          </p>
          <aside class="example">
            <p>If the following conditions are true:</p>
              <ul>
                <li>This is the fourth entry in an <a>object store</a>.</li>
                <li>The <a>object store</a> has a <a>key generator</a>.</li>
                <li>There is no in-line value for the <a>key path</a> property.</li>
              </ul>
              <p>
                Then the value provided by the <a>key generator</a> is used to populate the key value.
                In the example below the <a>key path</a> for the object store is <code>"foo.bar"</code>.
                The actual object has no value for the <code>bar</code> property, <code>{ foo: {} }</code>.
                When the object is saved in the <a>object store</a> the <code>bar</code> property is assigned a value of 4
                because that is the next <a>key</a> generated by the <a>object store</a>.
              </p>
            <pre class="example highlight">
 "foo.bar"
{ foo: {} }
            </pre>
            <p>If the following conditions are true:</p>
              <ul>
                <li>This is the fourth entry in an <a>object store</a>.</li>
                <li>The <a>object store</a> has a <a>key generator</a>.</li>
                <li>There is a value for the <a>key path</a> property.</li>
              </ul>
            <p>
              Then the value associated with the <a>key path</a> property is used.
              The auto-generated <a>key</a> is not used.
              In the example below the <a>keypath</a> for the <a>object store</a> is <code>"foo.bar"</code>.
              The actual object has a value of 10 for the <code>bar</code> property, <code>{ foo: { bar: 10} }</code>.
              When the object is saved in the <a>object store</a> the <code>bar</code> property keeps its value of 10, because that is the <a>key value</a>.
            </p>
            <pre class="example highlight">
"foo.bar"
{ foo: { bar: 10 } }
            </pre>
            <p>
              The following example illustrates the scenario when the specified in-line <a>key</a> is defined through a <a>key path</a> but there is no property matching it.
              The value provided by the <a>key generator</a> is then used to populate the <a>key value</a> and the system is responsible
              for creating as many properties as it requires to suffice the property dependencies on the hierarchy chain.
              In the example below the <a>key path</a> for the <a>object store</a> is <code>"foo.bar.baz"</code>.
              The actual object has no value for the <code>foo</code> property, <code>{ zip: {} }</code>.
              When the object is saved in the <a>object store</a> the <code>foo</code>, <code>bar</code>, and <code>baz</code> properties
              are created each as a child of the other until a value for <code>foo.bar.baz</code> can be assigned.
              The value for <code>foo.bar.baz</code> is the next key generated by the object store.
            </p>
            <pre class="example highlight">
"foo.bar.baz"
{ zip: {} }
            </pre>
            <p>
              Attempting to store a property on a primitive value will fail and throw an error.
              In the first example below the <a>key path</a> for the object store is <code>"foo"</code>.
              The actual object is a primitive with the value, 4.
              Trying to define a property on that primitive value fails.
              The same is true for arrays.  Properties are not allowed on an array.
              In the second example below, the actual object is an array, [10].
              Trying to define a property on the array fails.
            </p>
            <pre class="example highlight">
// The key generation will attempt to create and store the key path property on this primitive.
"foo"
4

// The key generation will attempt to create and store the key path property on this array.
"foo"
[10]

            </pre>
          </aside>
        </section>

        <section id="value-construct" class="section">
          <h4>Values</h4>
          <p>
            Each record is associated with a <dfn>value</dfn>. <a>Conforming user agents</a> MUST support
            any value supported by the <a>structured clone algorithm</a>
            [[!HTML5]]. This includes simple types such as <code>DOMString</code>
            and <code>Date</code> as well as <code>Object</code> and <code>Array</code>
            instances.
          </p>
        </section>

        <section id="key-path-construct" class="section">
          <h4>Key Path</h4>
          <p>
            A <dfn>key path</dfn> is a <code>DOMString</code> or <code>Array</code> that defines how to extract a <a>key</a>
            from a <a>value</a>. A <dfn>valid key path</dfn> is one of:
          </p>
          <ul>
            <li>An empty <code>DOMString</code>.</li>
            <li>An <dfn>identifier</dfn>, which is a <code>DOMString</code> matching
                the <code>IdentifierName</code> production from the JavaScript language grammar. [[!ECMA-262]].</li>
            <li>A <code>DOMString</code> containing multiple <a title="identifier">identifiers</a> separated by
            periods (ASCII character code 46).</li>
            <li>A non-empty <code>Array</code> containing only <code>DOMString</code>s conforming to
            the above requirements.</li>
          </ul>
          <p>
            Note that spaces are not allowed within a key path. To <dfn title="evaluate key path">evaluate a key path</dfn>,
            run the <a>steps for extracting a key from a value using a key path</a>.
          </p>
          <p>
          	<a>Key path</a> values can only be accessed from properties explicitly copied by the <a>structured clone algorithm</a>,
          	as well as the following properties:
          </p>
          		<ul>
          			<li><code>Blob.size</code></li>
          			<li><code>Blob.type</code></li>
          			<li><code>File.name</code></li>
          			<li><code>File.lastModifiedDate</code></li>
          			<li><code>Array.length</code></li>
          			<li><code>String.length</code></li>
          		</ul>

        </section>

        <section id="index-concept" class="section">
          <h4>Index</h4>
          <p>
            It is sometimes useful to retrieve <a>records</a> in an <a>object store</a> through other means
            than their <a>key</a>. An <dfn>index</dfn> allows looking up <a>record</a>s in an <a>object store</a>
            using properties of the <a>value</a>s in the <a>object store</a>s <a>record</a>s.
          </p>
          <p>
            An index is a specialized persistent key-value storage and has a <dfn>referenced</dfn> <a>object store</a>.
            The index has a <dfn title="index record list">list of records</dfn> which hold the
            data stored in the index. The records in an index are automatically populated whenever records in the
            <a>referenced</a> object store are inserted, updated or deleted. There can be several <a>index</a>es
            referencing the same <a>object store</a>, in which changes to the object store cause all such indexes
            to get updated.
          </p>
          <p>
            The values in the index's <a>record</a>s are always values of <a>keys</a> in the index's <a>referenced</a>
            object store. The keys are derived from the referenced object store's <a>value</a>s using a <dfn title="index key path"><a>key path</a></dfn>.
            If a given <a>record</a> with key <var>X</var> in the object store referenced by the index has the value <var>A</var>, and
            <a title="evaluate key path">evaluating</a> the <a title="index key path">index's key path</a> on <var>A</var> yields the result
            <var>Y</var>, then the index will contain a record with key <var>Y</var> and value <var>X</var>.
          </p>
          <p>
            Records in an index are said to have a <dfn>referenced value</dfn>. This is the value of the record in the index's referenced
            object store which has a key equal to the index's record's value. So in the example above,
            the record in the index whose key is <var>Y</var> and value is <var>X</var> has a <a>referenced value</a> of <var>A</var>.
          </p>
          <p class="note">
            Each record in an index reference one and only one record in the index's <a>referenced</a> object store. However there can be
            multiple records in an index which reference the same record in the object store. And there can also be no records in an index
            which reference a given record in an object store.
          </p>
          <p>
            The <a>record</a>s in an index are always sorted according to the <a title="record">record's</a> key. However unlike object stores,
            a given index can contain multiple records with the same key. Such records are additionally sorted according to
            the <a title="index">index's</a> <a title="record">record's</a> value (meaning the key of the record in the referenced <a>object store</a>).
          </p>
          <p>
            An index contains a <dfn>unique</dfn> flag. When this flag is set to true, the index enforces that no two <a>record</a>s
            in the index has the same key. If a <a>record</a> in the index's referenced object store is attempted to be inserted or
            modified such that evaluating the index's key path on the records new value yields a result which already exists in the
            index, then the attempted modification to the object store fails.
          </p>
          <p>
            An index also contains a <dfn>multiEntry</dfn> flag. This flag affects how the index behaves when the result of evaluating
            the index's <a title="index key path">key path</a> yields an <code>Array</code>. If the <a>multiEntry</a> flag is false, then
            a single <a>record</a> whose <a>key</a> is an <code>Array</code> is added to the index. If the <a>multiEntry</a> flag is
            true, then the one <a>record</a> is added to the index for each item in the <code>Array</code>. The <a>key</a> for each
            record is the value of respective item in the <code>Array</code>.
          </p>
          <p>
            The <a><code>IDBIndex</code></a> and <a><code>IDBIndexSync</code></a> interfaces
            provide access to the metadata of an <a>index</a>. Note however that multiple instances of those
            interfaces representing the same <a>index</a> can exist.
          </p>
        </section> <!-- IDBIndex -->

        <section id="transaction-concept" class="section">
          <h4>Transaction</h4>
          <p>
            A <dfn>transaction</dfn> is used to interact with the data in a <a>database</a>.
            Whenever data is read or written to the database it is done by using a <a>transaction</a>.
          </p>
          <p>
            All transactions are created through a <a>connection</a>, which is the transaction's
            <dfn title="transaction connection">connection</dfn>.
            The transaction has a <a>mode</a> that determines which types of interactions can be performed
            upon that transaction. The <a>mode</a> is set when the transaction is created and remains
            fixed for the life of the transaction. The transaction also has a <dfn>scope</dfn> that
            determines the <a>object store</a>s with which the transaction may interact. Transactions
            have an <dfn>active</dfn> flag, which determines if new <a>request</a>s can be made
            against the transaction. Finally, transactions also contain a <dfn>request list</dfn> of
            <a>request</a>s which have been made against the transaction.
          </p>
          <p>
            Each transaction has a fixed scope, determined when the transaction is created.
            A transaction's scope remains fixed for the lifetime of that transaction.
          </p>
          <p>
            <a title="transaction">Transactions</a> offer some protection from
            application and system failures. A <a>transaction</a> may be used to
            store multiple data records or to conditionally modify certain data
            records. A <a>transaction</a> represents an atomic and durable set
            of data access and data mutation operations.
          </p>
          <p>
            <a title="transaction">Transactions</a> are expected to be short lived. This is encouraged
            by the <a title="commit">automatic committing</a> functionality described below. Authors can still cause
            transactions to run for a long time; however, this usage pattern
            is not generally recommended as it can lead to a bad user experience.
          </p>
          <p>
            The <dfn title="transaction lifetime">lifetime</dfn> of a <a>transaction</a> is as follows:
          </p>
          <ol>
            <li>
              A transaction is <dfn title="transaction create">created</dfn> using
              <a class="idlType" href="#widl-IDBDatabase-transaction-IDBTransaction-any-storeNames-DOMString-mode">IDBDatabase.transaction</a>.
              The arguments passed determine the <a>scope</a> of the transaction and whether the transaction is read-only.
              When a transaction is created its <a>active</a> flag is initially set to true.
            </li>
            <li>
              The implementation MUST allow <a>request</a>s to be <a title="place request">placed</a> against the transaction
              whenever the <a>active</a> flag is true. This is the case even if the transaction has not yet been
              <a title="transaction start">started</a>. Until the transaction is <a title="transaction start">started</a>
              the implementation MUST NOT execute these requests; however, the implementation MUST keep track of the
              <a>request</a>s and their order. Requests may be placed against a transaction only while that transaction
              is <a>active</a>. If an attempt is made to place a request against a transaction when that transaction is not
              <a>active</a>, the implementation MUST reject the attempt by throwing a
              <code>DOMException</code> of type <a><code>TransactionInactiveError</code></a>.
            </li>
            <li>
              Once an implementation is able to enforce the constraints defined for the transaction <a>mode</a>, defined below,
              the implementation MUST queue up an operation to <dfn title="transaction start">start</dfn> the transaction asynchronously.
              The timing for when this happens is affected by:
                <ul>
                  <li>The <a>mode</a> in which the transaction is opened.</li>
                  <li>Which <a>object store</a>s are included in the <a>scope</a> of the transaction.</li>
                </ul>
            </li>
            <li>
              Once the transaction has been <a title="transaction start">started</a> the implementation can
              start executing the <a>request</a>s placed against the transaction. Unless otherwise defined, requests
              MUST be executed in the order in which they were made against the transaction. Likewise, their results MUST
              be returned in the order the requests were placed against a specific transaction.
              There is no guarantee about the order that results from requests in different transactions are returned.
              Similarly, the transaction <a>mode</a>s ensure that two requests placed against different transactions
              can execute in any order without affecting what resulting data is stored in the database.
            </li>
            <li>
              A transaction can be <dfn title="abort">aborted</dfn> at any time before it is <a title="transaction finish">finished</a>,
              even if the transaction isn't currently <a>active</a> or hasn't yet <a title="transaction start">started</a>.
              When a transaction is aborted the implementation MUST undo (roll back) any changes
              that were made to the <a>database</a> during that transaction. This includes both changes to the contents of
              <a>object store</a>s as well as additions and removals of <a>object store</a>s and <a>index</a>es.
            </li>
            <li>
              A transaction can fail for reasons not tied to a particular <a>DOMRequest</a>. For example due to IO errors
              when committing the transaction, or due to running into a quota limit where the implementation can't tie
              exceeding the quota to a partcular request. In this case the implementation MUST run the
              <a>steps for aborting a transaction</a> using the transaction as <var>transaction</var> and the appropriate
              error type as <var>error</var>. For example if quota was exceeded then <code>QuotaExceededError</code> should
              be used as <var>error</var>, and if an IO error happened, <code>UnknownError</code> should be used as
              <var>error</var>.
            </li>
            <li>
              When a transaction can no longer become <a>active</a>, the implementation MUST attempt to
              <dfn>commit</dfn> it, as long as the transaction has not been <a title="abort">aborted</a>.
              This usually happens after all requests placed against the
              transaction have been executed and their returned results handled, and no new requests have been placed
              against the transaction. When a transaction is committed, the implementation MUST atomically write
              any changes to the <a>database</a> made by requests placed against the transaction. That is, either all
              of the changes MUST be written, or if an error occurs, such as a disk write error, the implementation
              MUST NOT write any of the changes to the database. If such an error occurs, the implementation MUST
              <a>abort</a> the transaction by following the <a>steps for aborting a transaction</a>, otherwise it
              MUST <a>commit</a> the transaction by following the <a>steps for committing a transaction</a>.
            </li>
            <li>
              When a transaction is <a>commit</a>ted or <a>abort</a>ed, it is said to be
              <dfn title="transaction finish">finished</dfn>. If a transaction can't be finished, for example
              due to the implementation crashing or the user taking some explicit action to cancel it, the
              implementation MUST <a>abort</a> the transaction.
            </li>
          </ol>
          <p>
            Transactions are opened in one of three <dfn title="mode">modes</dfn>. The mode
            determines how concurrent access to <a>object store</a>s in the transaction are isolated.
          </p>

          <dl class="idl" title="enum IDBTransactionMode">
            <dt>readonly</dt>
            <dd>
                This mode means that the transaction is only allowed
                to read data. No modifications can be done by this type of transaction. This has the advantage
                that several <code>"readonly"</code> transactions can run at the same time even if their <a>scope</a>s
                are overlapping, i.e. if they are using the same object stores. This type of transaction can
                be created any time once a database has been opened using the <a>IDBDatabase.transaction()</a> or
                <a>IDBDatabaseSync.transaction()</a> functions.
            </dd>

            <dt>readwrite</dt>
            <dd>
                The type of transaction is allowed to read, modify and
                delete data from existing object stores. However object stores and indexes can't be added or removed.
                Multiple <code>"readwrite"</code> transactions can't run at the same time if their <a>scope</a>s are overlapping
                since that would mean that they can modify each other's data in the middle of the transaction.
                This type of transaction can be created any time once a database has been opened using the
                <a>IDBDatabase.transaction()</a> function.
            </dd>

            <dt>versionchange</dt>
            <dd>
                This is similar to a <code>"readwrite"</code> transaction,
                however it can additionally create and remove object stores and indexes. It is the only type of
                transaction that can do so. This type of transaction can't be manually created, but instead is created
                automatically when a <a><code>upgradeneeded</code></a> event is fired.
            </dd>
          </dl>

          <p>
            Any number of transactions opened in <a><code>"readonly"</code></a> mode are allowed to run concurrently,
            even if the transaction's <a>scope</a> overlap and include the same <a>object store</a>s.
            As long as a <code>"readonly"</code> transaction is running, the data that the implementation returns
            through <a>request</a>s created with that transaction MUST remain
            constant. That is, two requests to read the same piece of data MUST yield the same result
            both for the case when data is found and the result is that data, and for the case when data
            is not found and a lack of data is indicated.
          </p>
          <p>
            There are a number of ways that an implementation ensures this. The implementation can prevent any
            <code>"readwrite"</code> transaction, whose scope overlaps the scope of the <code>"readonly"</code> transaction, from
            starting until the <code>"readonly"</code> transaction finishes. Or the implementation can allow the <code>"readonly"</code>
            transaction to see a snapshot of the contents of the <a>object store</a>s which is taken when
            the <code>"readonly"</code> transaction started.
          </p>
          <p>
            Similarly, implementations MUST ensure that a <code>"readwrite"</code> transaction is only affected by
            changes to <a>object store</a>s that are made using the transaction itself. For example, the
            implementation MUST ensure that another transaction does not modify the contents of
            <a>object store</a>s in the <code>"readwrite"</code> transaction's <a>scope</a>. The implementation
            MUST also ensure that if the <code>"readwrite"</code> transaction completes successfully, the
            changes written to <a>object store</a>s using the transaction can be committed to the
            <a>database</a> without merge conflicts. An implementation MUST NOT abort a transaction
            due to merge conflicts.
          </p>
          <p>
            If multiple <code>"readwrite"</code> transactions are attempting to access the same object store (i.e.
            if they have overlapping <a>scope</a>), the transaction that was <a title="transaction create">
            created</a> first MUST be the transaction which gets access to the object store first. Due to
            the requirements in the previous paragraph, this also means that it is the only transaction
            which has access to the object store until the transaction is <a title="transaction finish">finished</a>.
          </p>
          <p class="note">
            Generally speaking, the above requirements mean that <code>"readwrite"</code> transactions which have overlapping
            scopes always run in the order they were <a title="transaction create">created</a>, and never run
            in parallel.
          </p>
          <p>
            A <code>"versionchange"</code> transaction never run concurrently with other transactions.
            When a database is opened with a <a>version</a> number higher than the current <a>version</a>, a new
            <code>"versionchange"</code> transaction is automatically created and made available through the
            <code>"upgradeneeded"</code> event. The <code>"upgradeneeded"</code> event isn't fired, and thus the
            <code>"versionchange"</code> transaction isn't started, until all other <a>connection</a>s to the same
            <a>database</a> are closed. This ensures that all other transactions are <a>finished</a>.
          </p>
          <p>
            As long as a <code>"versionchange"</code> transaction
            is running, attempts to open more <a>connection</a>s to the same <a>database</a> are delayed,
            and any attempts to use the same <a>connection</a> to start additional transactions will result in
            an exception being thrown. Thus <code>"versionchange"</code> transactions not only ensure that
            no other transactions are running concurrently, but also ensure that no other transactions are queued
            against the same <a>database</a> as long as the transaction is running.
          </p>
          <p class="note">
          	<code>"versionchange"</code> transaction is automatically created
          	when a database version number is provided that is greater than the current database version.
          	This <a>transaction</a> will be active inside the <a><code>onupgradeneeded</code></a> event handler,
          	allowing the creation of new <a title="object store">object stores</a> and <a title="index">indexes</a>.
          </p>
          <p>
            User agents MUST ensure a reasonable level of fairness across transactions to prevent
            starvation. For example, if multiple <code>"readonly"</code> transactions are started one after another
            the implementation MUST NOT indefinitely prevent a pending <code>"readwrite"</code>
            transaction from <a title="transaction start">starting</a>.
          </p>
          <p>
            Each <a>transaction</a> object implements either the <a><code>IDBTransaction</code></a> or the
            <a><code>IDBTransactionSync</code></a> interface.
          </p>
        </section> <!-- IDBTransaction -->

        <section class="section" id="request-concept">
          <h4>Requests</h4>
          <p>
            Each reading and writing operation on a <a>database</a> is done using a <dfn>request</dfn>.
            Every request represents one read or write operation.
            <a>Request</a>s have a <dfn title="request done"><var>done</var></dfn> flag which
            initially is false, and a <dfn title="request source">source</dfn> object. Every request
            also has a <dfn title="request result">result</dfn> and an <dfn title="error attribute">error attribute</dfn>,
            neither of which are accessible until the <a title="request done">done</a> flag is set to true.
          </p>
          <p>
            Finally, requests have a <dfn>request transaction</dfn>. When a request is created, it is
            always <dfn title="place request">placed</dfn> against a <a>transaction</a> using either the
            <a href="#steps-for-asynchronously-executing-a-request">steps for asynchronously executing a request</a> or the
            <a href="#steps-for-synchronously-executing-a-request">steps for synchronously executing a request</a>.
            The steps set the <a>request transaction</a> to be that <a>transaction</a>.
            The steps do not set the <a>request transaction</a> to be that request for the request returned from an
            <a href="#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version">IDBFactory.open</a> call however.
            That function create requests which have a null <a>request transaction</a>.
          </p>
          <dl class="idl" title="enum IDBRequestReadyState">
            <dt>pending</dt>
            <dd>The <a title="request done">done</a> flag of the <a>request</a> is false.</dd>
            <dt>done</dt>
            <dd>The <a title="request done">done</a> flag of the <a>request</a> is true.</dd>
          </dl>
        </section>

        <section class="section" id="range-concept">
          <h4>Key Range</h4>
          <p>
            Records can be retrieved from <a>object store</a>s and <a>index</a>es
            using either <a title="key">keys</a> or <a title="key range">key ranges</a>. A
            <dfn>key range</dfn> is a continuous interval over some data type
            used for keys.
          </p>
          <p>
            A <a>key range</a> MAY be lower-bounded or upper-bounded
            (there is a value that is, respectively, smaller than or larger than all its elements).
            A <a>key range</a> is said to be bounded if it is both lower-bounded and upper-bounded.
            If a key range is neither lower-bounded nor upper-bounded it is said to be unbounded.
            A <a>key range</a> MAY be open (the key range does not include its endpoints)
            or closed (the key range includes its endpoints).
            A key range MAY consist of a single value.
          </p>
          <p>
            The <a><code>IDBKeyRange</code></a> interface defines a
            <a>key range</a>.
          </p>
          <dl class="idl" title="interface IDBKeyRange">
            <dt>readonly attribute any lower</dt>
            <dd>This value is the lower-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute any upper</dt>
            <dd>This value is the upper-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute boolean lowerOpen</dt>
            <dd>Returns false if the lower-bound value is included in the <a>key range</a>.
            Returns true if the lower-bound value is excluded from the <a>key range</a>.</dd>
            <dt>readonly attribute boolean upperOpen</dt>
            <dd>Returns false if the upper-bound value is included in the <a>key range</a>.
            Returns true if the upper-bound value is excluded from the <a>key range</a>.</dd>
            <dt>static IDBKeyRange only()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with both <a href="#widl-IDBKeyRange-lower">lower</a> and
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and both
              <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a>
              set to false.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The only value</dd>
              </dl>
              <dl class="exception remove" title="DOMException">
                <dt>DataError</dt>
                <dd>The <var>value</var> parameter was not passed a <a>valid key</a>.</dd>
              </dl>
            </dd>
            <dt>static IDBKeyRange lowerBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to <var>open</var>,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <code>undefined</code> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to true.
              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Set to false if the lower-bound should be included in the <a>key range</a>. Set to true if the lower-bound value should
                be excluded from the <a>key range</a>. Defaults to false (lower-bound value is included).</dd>
              </dl>
              <dl class="exception remove" title="DOMException">
                <dt>DataError</dt>
                <dd>The <var>value</var> parameter was not passed a <a>valid key</a>.</dd>
              </dl>
            </dd>
            <dt>static IDBKeyRange upperBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <code>undefined</code>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to true,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>upper</var> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>open</var>.
              <dl class="parameters">
                <dt>any upper</dt>
                <dd>The upper bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Set to false if the upper-bound should be included in the <a>key range</a>. Set to true if the upper-bound value should
                be excluded from the <a>key range</a>. Defaults to false (upper-bound value is included).</dd>
              </dl>
              <dl class="exception remove" title="DOMException">
                <dt>DataError</dt>
                <dd>The <var>value</var> parameter was not passed a <a>valid key</a>.</dd>
              </dl>
            </dd>
            <dt>static IDBKeyRange bound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to <var>lowerOpen</var>,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>upper</var> and
              <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>upperOpen</var>.
              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower-bound value</dd>
                <dt>any upper</dt>
                <dd>The upper-bound value</dd>
                <dt>optional boolean lowerOpen</dt>
                <dd>Set to false if the lower-bound should be included in the <a>key range</a>. Set to true if the lower-bound value should
                be excluded from the <a>key range</a>. Defaults to false (lower-bound value is included).</dd>
                <dt>optional boolean upperOpen</dt>
                <dd>Set to false if the upper-bound should be included in the <a>key range</a>. Set to true if the upper-bound value should
                be excluded from the <a>key range</a>. Defaults to false (upper-bound value is included).</dd>
              </dl>
              <dl class="exception remove" title="DOMException">
                <dt>DataError</dt>
                <dd>Either the <var>lower</var> or <var>upper</var> parameters were not passed a <a>valid key</a>
                  or the lower key is greater than the upper key or the lower key and upper key match and either
                  of the bounds are open.</dd>
              </dl>
            </dd>
          </dl>
          <p>
            A <a><var>key</var></a> is <dfn>in a <a>key range</a></dfn> if both the following conditions are
            fulfilled:
          </p>
          <ul>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-lower"><code>lower</code></a> value is <code>undefined</code> or
              <a>less than</a> <var>key</var>. It may also be <a>equal to</a> <var>key</var> if
              <a href="#widl-IDBKeyRange-lowerOpen"><code>lowerOpen</code></a> is <code>false</code>.
            </li>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-upper"><code>upper</code></a> value is <code>undefined</code> or
              <a>greater than</a> <var>key</var>. It may also be <a>equal to</a> <var>key</var> if
              <a href="#widl-IDBKeyRange-upperOpen"><code>upperOpen</code></a> is <code>false</code>.
            </li>
          </ul>
        </section> <!-- Key Range -->

        <section id="cursor-concept" class="section">
          <h4>Cursor</h4>
          <p>
            <a title="cursor">Cursors</a> are a transient mechanism used to
            iterate over multiple records in a database.
            Storage operations are performed on the underlying <a>index</a> or an
            <a>object store</a>.
          </p>
          <p>
            A <dfn>cursor</dfn> comprises a <dfn>range</dfn> of records in either an <a>index</a>
            or an <a>object store</a>. The cursor has a <dfn title="cursor source">source</dfn> that indicates
            which index or object store is associated with the records over which the <a>cursor</a> is iterating.
            A <a>cursor</a> maintains a <dfn>position</dfn> over
            this series, which moves in a <dfn>direction</dfn> that is in either
            monotonically increasing or decreasing order of the <a>record</a> keys. Cursors
            also have a <dfn title="cursor key">key</dfn> and a <dfn title="cursor value">value</dfn>
            which represent the <a>key</a> and the <a>value</a> of the last iterated <a>record</a>.
            Cursors finally have a <dfn>got value</dfn> flag. When this flag is false, the cursor is either
            in the process of loading the next value or it has reached the end of its <a>range</a>, when it
            is true, it indicates that the cursor is currently holding a value and that it is ready to iterate
            to the next one.
          </p>
          <p>
            There are four possible values for a cursor's <a>direction</a>. The direction of a cursor determines
            if the cursor initial position is at the start of its <a title="cursor source">source</a> or at its end.
            It also determines in which direction the cursor moves when iterated, and if it skips duplicated values
            when iterating indexes. The allowed values for a cursor's <a>direction</a> is as follows:
          </p>
          <dl class="idl" title="enum IDBCursorDirection">
            <dt>next</dt>
            <dd>This direction causes the cursor to be opened at the start of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should yield all records, including
            duplicates, in monotonically increasing order of keys.</dd>

            <dt>nextunique</dt>
            <dd>This direction causes the cursor to be opened at the start of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should not yield records with
            the same key, but otherwise yield all records, in monotonically increasing order of keys. For every key
            with duplicate values, only the first record is yielded. When the <a title="cursor source">source</a> is
            an <a>object store</a> or a <a>unique</a> <a>index</a>, this direction has the exact same behavior as <code>"next"</code>.</dd>
            <dt>prev</dt>
            <dd>This direction causes the cursor to be opened at the end of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should yield all records, including
            duplicates, in monotonically decreasing order of keys.</dd>

            <dt>prevunique</dt>
            <dd>This direction causes the cursor to be opened at the end of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should not yield records with
            the same key, but otherwise yield all records, in monotonically decreasing order of keys. For every key
            with duplicate values, only the first record is yielded. When the <a title="cursor source">source</a> is
            an <a>object store</a> or a <a>unique</a> <a>index</a>, this direction has the exact same behavior as <code>"prev"</code>.</dd>
          </ul>
          <p>
            If the <a title="cursor source">source</a> of a cursor is an <a>object store</a>, the <dfn>effective object store</dfn>
            of the cursor is that object store and the <dfn>effective key</dfn> of the cursor is the cursor's <a>position</a>.
            If the <a title="cursor source">source</a> of a cursor is an <a>index</a>, the <a>effective object store</a>
            of the cursor is that index's <a>referenced</a> object store and the <a>effective key</a> is the cursor's
            <a>object store position</a>.
          </p>
          <p>
            It is possible for the list of records which the cursor is iterating over to
            change before the full <a>range</a> of the cursor has been iterated. In order to
            handle this, cursors maintain their <a>position</a> not as an index, but rather
            as a <a>key</a> of the previously returned record. For a forward iterating cursor,
            the next time the cursor is asked to iterate to the next record it returns the
            record with the lowest <a>key</a> <a>greater than</a> the one previously returned. For
            a backwards iterating cursor, the situation is opposite and it returns the record
            with the highest <a>key</a> <a>less than</a> the one previously returned.
          </p>
          <p>
            For cursors iterating indexes the situation is a little bit more complicated since
            multiple records can have the same key and are therefore also sorted by <a>value</a>.
            When iterating indexes the <a>cursor</a> also has an <dfn>object store position</dfn>, which indicates
            the <a>value</a> of the previously found <a>record</a> in the index. Both
            <a>position</a> and the <a>object store position</a> are used when finding the next appropriate record.
          </p>
          <p>
            <a title="cursor">Cursor</a> objects implement the <a><code>IDBCursor</code></a>
            or the <a><code>IDBCursorSync</code></a> interfaces. There is only ever one
            <a><code>IDBCursor</code></a> or <a><code>IDBCursorSync</code></a> instance representing
            a given <a>cursor</a>. However there is no limit on how many cursors can be used at the
            same time.
          </p>
        </section> <!-- IDBCursor -->
        <section class="section">
          <h3>Exceptions</h3>
          <p>
          	Each of the exceptions defined in the IndexedDB spec is a <code><dfn>DOMException</dfn></code> with a specific type. [[!DOM4]]
          	Existing DOM Level 4 exceptions will set their code to a legacy value; however, the new indexedDB type exceptions will have a code value of 0.
          	The message value is optional.
          </p>
          <p>
          	IndexedDB uses the following new <code>DOMException</code> types with their various messages.
          	All of these new types will have a code value of <code>0</code> zero.
          </p>
          <table>
          		<tr>
          			<th>Type</th>
          			<th>Message (Optional)</th>
          		</tr>
          		<tr>
          			<td><code><dfn>UnknownError</dfn></code></td>
          			<td>The operation failed for reasons unrelated to the database itself and not covered by any other errors.</td>
          		</tr>
          		<tr>
          			<td><code><dfn>ConstraintError</dfn></code></td>
	          		<td>
	          			A mutation operation in the transaction failed because a constraint was not satisfied.
	          			For example, an object such as an <a>object store</a> or <a>index</a> already exists and a request attempted to create a new one.
	          		</td>
          		</tr>
          		<tr>
          			<td><code><dfn>DataError</dfn></code></td>
	          		<td>Data provided to an operation does not meet requirements.</td>
          		</tr>
          		<tr>
          			<td><code><dfn>TransactionInactiveError</dfn></code></td>
	          		<td>A request was placed against a transaction which is currently not active, or which is finished.</td>
          		</tr>
          		<tr>
          			<td><code><dfn>ReadOnlyError</dfn></code></td>
	          		<td>The mutating operation was attempted in a <code>"readonly"</code> transaction.</td>
          		</tr>
          		<tr>
          			<td><code><dfn>VersionError</dfn></code></td>
	          		<td>An attempt was made to open a database using a lower version than the existing version.</td>
          		</tr>
          	</table>
			<p>
				IndexedDB reuses the following existing <a>DOMException</a> types from [[!DOM4]].
				These types will continue to return the codes and names as specified in DOM4;
				however, they will have the following messages when thrown from an IndexedDB API:
			</p>
			<table>
				<tr>
					<th>Type</th>
					<th>Message (Optional)</th>
				</tr>
				<tr>
					<td><code><dfn>NotFoundError</dfn></code></td>
					<td>
						The operation failed because the requested database object could not be found.
						For example, an <a>object store</a> did not exist but was being opened.
					</td>
				</tr>
				<tr>
					<td><code><dfn>InvalidStateError</dfn></code></td>
					<td>
						An operation was called on an object on which it is not allowed or at a time when it is not allowed.
						Also occurs if a request is made on a source object that has been deleted or removed.
						Use <a>TransactionInactiveError</a> or <a>ReadOnlyError</a> when possible, as they are more specific variations of <a>InvalidStateError</a>.
					</td>
				</tr>
				<tr>
					<td><code><dfn>InvalidAccessError</dfn></code></td>
					<td>
						An invalid operation was performed on an object. For example transaction creation attempt was made,
                                                but an empty scope was provided.
					</td>
				</tr>
				<tr>
					<td><code><dfn>AbortError</dfn></code></td>
					<td>
						A <a>request</a> was aborted, for example through a call to <code>IDBTransaction.abort</code>.
					</td>
				</tr>
				<tr>
					<td><code><dfn>TimeoutError</dfn></code></td>
					<td>A lock for the <a>transaction</a> could not be obtained in a reasonable time.</td>
				</tr>
				<tr>
					<td><code><dfn>QuotaExceededError</dfn></code></td>
					<td>
						The operation failed because there was not enough remaining storage space,
						or the storage quota was reached and the user declined to give more space to the database.
					</td>
				</tr>
				<tr>
					<td><code><dfn>SyntaxError</dfn></code></td>
					<td>The <code>keypath</code> argument contains an invalid <a>key path</a>.</td>
				</tr>
          		<tr>
          			<td><code><dfn>DataCloneError</dfn></code></td>
	          		<td>The data being stored could not be cloned by the internal structured cloning algorithm.</td>
          		</tr>
			</table>

        </section>
        <section id="options-object-concept" class="section">
          <h4>Options Object</h4>
          <p>
            <dfn>Options object</dfn>s are dictionary objects [[!WEBIDL]]
            which are used to supply optional parameters to some indexedDB functions like
            <a href="#widl-IDBDatabase-createObjectStore-IDBObjectStore-DOMString-name-IDBObjectStoreParameters-optionalParameters">createObjectStore</a> and
            <a href="#widl-IDBObjectStore-createIndex-IDBIndex-DOMString-name-any-keyPath-IDBIndexParameters-optionalParameters">createIndex</a>. The attributes on the object
            correspond to optional parameters on the function called.
          </p>

          <p>The following WebIDL defines <dfn>IDBObjectStoreParameters</dfn> dictionary type.</p>
          <dl class="idl" title="dictionary IDBObjectStoreParameters">
            <dt>DOMString? keyPath = null
            <dd>
            <dt>boolean autoIncrement = false
            <dd>
          </dl>

          <p>The following WebIDL defines <dfn>IDBIndexParameters</dfn> dictionary type.</p>
          <dl class="idl" title="dictionary IDBIndexParameters">
            <dt>boolean unique = false
            <dd>
            <dt>boolean multiEntry = false
            <dd>
          </dl>

          <p>The following WebIDL defines <dfn>IDBVersionChangeEventInit</dfn> dictionary type.</p>
          <dl class="idl" title="dictionary IDBVersionChangeEventInit : EventInit">
            <dt>unsigned long long oldVersion = 0
            <dd>
            <dt>unsigned long long? newVersion = null
            <dd>
          </dl>

        </section> <!-- Options Object -->
        <section id="key-generator-concept" class="section">
          <h4>Key Generators</h4>
          <p>
            When a <a>object store</a> is created it can be specified to use a <dfn>key generator</dfn>.
            A <a>key generator</a> keeps an internal <dfn>current number</dfn>. The <a>current number</a>
            is always a positive integer. Whenever the key generator is used to generate a new <a>key</a>, the
            generator's <a>current number</a> is returned and <strong>then</strong> incremented to prepare
            for the next time a new <a>key</a> is needed. Implementations MUST use the following rules
            for generating numbers when a <a>key generator</a> is used.
          </p>
          <ul>
            <li>
              Every object store that uses key generators use a seprate generator. I.e. interacting with one
              object store never affects the key generator of any other object store.
            </li>
            <li>
              The <a>current number</a> of a <a>key generator</a> is always set to <code>1</code> when the
              <a>object store</a> for that key generator is first created.
            </li>
            <li>
              When a key generator is used to generate a new <a>key</a> for a <a>object store</a>, the
              key generator's <a>current number</a> is used as the new key value and then the
              key generator's <a>current number</a> is increased by <code>1</code>.
            </li>
            <li>
              <p>
                When a <a>record</a> is stored and an key value is specified in the call to store the record,
                if the specified key value is a <code>float</code> greater than or equal to the key generator's
                <a>current number</a>, then the key generator's <a>current number</a> is set to the smallest integer
                number <a>greater than</a> the explicit key.
                A key can be specified both for object stores which use <a>in-line keys</a>, by setting the
                property on the stored value which the <a title="object store key path">object store's key path</a>
                points to, and for object stores which use <a>out-of-line</a> keys, by passing a key argument
                to the call to store the <a>record</a>.
              </p>
              <p>
                Only specified keys values which
                are <code>float</code> values affect the <a>current number</a> of the key generator.
                <code>Date</code>s and <code>Array</code>s which contain <code>float</code>s do not affect
                the <a>current number</a> of the key generator. Nor do <code>DOMString</code> values which
                could be parsed as <code>float</code>s. Likewise, negative <code>float</code> numbers
                do not affect the <a>current number</a> since they are always lower than the <a>current
                number</a>.
              </p>
            </li>
            <li>
              Modifying a key generator's <a>current number</a> is considered part of a database operation.
              This means that if the operation fails and the operation is reverted, the <a>current number</a>
              is reverted to the value it had before the operation started. This applies both to modifications
              that happen due to the <a>current number</a> getting increased by <code>1</code> when the key
              generator is used, and to modifications that happen due to a <a>record</a> being stored with a
              key value specified in the call to store the <a>record</a>.
            </li>
            <li>
              Likewise, if a <a>transaction</a> is aborted, the <a>current number</a> of the key generator's
              for all <a>object store</a>s in the transaction's <a>scope</a> is reverted to the values they
              had before the <a>transaction</a> was started.
            </li>
            <li>
              When the <a>current number</a> of a key generator reaches above the value <code>2^53</code>
              (<code>9007199254740992</code>) any attempts to use the key generator to generate a new
              <a>key</a> will result in a <code>ConstraintError</code>.
              It is still possible to insert <a title="record">records</a> into the
              object store by specifying an explicit key, however the only way to use a key generator
              again for the object store is to delete the object store and create a new one.
              <p class="note">
                Note that as long as key generators are used in a normal fashion this will not be a problem.
                If you generate a new key 1000 times per second day and night, you won't run into this limit
                for over 285000 years.
              </p>
            </li>
            <li>
              The <a>current number</a> for a key generator never decreases, other than as a result of
              database operations being reverted. Deleting a <a>record</a> from an <a>object store</a>
              never affects the object store's key generator. Even clearing all records from an
              object store, for example using the
              <a href="#widl-IDBObjectStore-clear-IDBRequest"><code>clear()</code></a> function, does
              not affect the <a>current number</a> of the object store's key generator.
            </li>
          </ul>
          <p>
            A practical result of this is that the first key generated for an object store is always <code>1</code>
            (unless a higher numeric key is inserted first) and the key generated for an object store is always a
            positive integer higher than the highest numeric key in the store. The same key is never generated
            twice for the same object store unless a transaction is rolled back.
          </p>
          <aside class="example">
            <p>Each object store gets its own key generator:</p>
            <pre class="example highlight">
store1 = db.createObjectStore("store1", { autoIncrement: true });
store1.put("a"); // Will get key 1
store2 = db.createObjectStore("store2", { autoIncrement: true });
store2.put("a"); // Will get key 1
store1.put("b"); // Will get key 2
store2.put("b"); // Will get key 2
            </pre>

            <p>If an insertion fails due to constraint violations or IO error, the
            key generator is not updated.</p>
            <pre class="example highlight">
transaction.onerror = function(e) { e.preventDefault() };
store = db.createObjectStore("store1", { autoIncrement: true });
index = store.createIndex("index1", "ix", { unique: true });
store.put({ ix: "a"}); // Will get key 1
store.put({ ix: "a"}); // Will fail
store.put({ ix: "b"}); // Will get key 2
            </pre>

            <p>Removing items from an objectStore never affects the key generator.
            Including when .clear() is called.</p>
            <pre class="example highlight">
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.delete(1);
store.put("b"); // Will get key 2
store.clear();
store.put("c"); // Will get key 3
store.delete(IDBKeyRange.lowerBound(0));
store.put("d"); // Will get key 4
            </pre>

            <p>Inserting an item with an explicit key affects the key generator if,
            and only if, the key is numeric and higher than the last generated
            key.</p>
            <pre class="example highlight">
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.put("b", 3); // Will use key 3
store.put("c"); // Will get key 4
store.put("d", -10); // Will use key -10
store.put("e"); // Will get key 5
store.put("f", 6.00001); // Will use key 6.0001
store.put("g"); // Will get key 7
store.put("f", 8.9999); // Will use key 8.9999
store.put("g"); // Will get key 9
store.put("h", "foo"); // Will use key "foo"
store.put("i"); // Will get key 10
store.put("j", [1000]); // Will use key [1000]
store.put("k"); // Will get key 11
// All of these would behave the same if the objectStore used a
keyPath and the explicit key was passed inline in the object
            </pre>

            <p>Aborting a transaction rolls back any increases to the key generator
            which happened during the transaction. This is to make all rollbacks
            consistent since rollbacks that happen due to crash never has a chance
            to commit the increased key generator value.</p>
            <pre class="example highlight">
db.createObjectStore("store", { autoIncrement: true });
trans1 = db.transaction(["store"], "readwrite");
store_t1 = trans1.objectStore("store");
store_t1.put("a"); // Will get key 1
store_t1.put("b"); // Will get key 2
trans1.abort();
trans2 = db.transaction(["store"], "readwrite");
store_t2 = trans2.objectStore("store");
store_t2.put("c"); // Will get key 1
store_t2.put("d"); // Will get key 2
            </pre>
          </aside>
        </section> <!-- Key Generator -->
      </section>
      <!-- end-content -->
    </section>
  </body>
</html>
