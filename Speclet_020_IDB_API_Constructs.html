<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.41 2010/03/24 17:58:17 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }

      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });

        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'},
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'},
                       sn.element('pre', {'class': 'code'},
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      window.onload = function() {
        examples();
        codeblocks();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple 
        values and hierarchical objects. Each record consists of a key and some 
        value. Moreover, the database maintains indexes over records it stores. 
        An application developer directly uses an API to locate records either 
        by their key or by using an index. A query language can be layered on 
        this API. An indexed database can be implemented using a persistent 
        B-tree data structure.
      </p>
    </section>


    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>

      <!-- begin-content -->
      <section id="constructs" class="section">
      <h3>Constructs</h3>
        <p>
          An indexed database is made of records holding simple values
          and hierarchical objects. Each <dfn>record</dfn> consists of a key and a value. 
        </p>
        
        <section id="key-construct" class="section">
          <h4>Keys</h4>
          
          <p>
            In order to efficiently retrieve <a title="record">records</a> 
            stored in an indexed database, a user agent needs to organize each 
            <a>record</a> according to its key. <a>Conforming user agents</a>
            MUST support the use of the following types as <dfn>key value</dfn>s: IDL data types
            <code>DOMString</code>, <code>long</code>, and <code>float</code> [[!WEBIDL]]; the
            <code>Date</code> JavaScript object [[!ECMA-262]]; as well as the value <code>null</code>.
            For the particular case of <code>float</code>, the value NaN is not allowed.
          </p>
          <p class="note">
            Inifinite <code>float</code> values are allowed.
          </p>
          <p>
            For purposes of comparison, all <code>DOMString</code> values are evaluated as greater than 
            <code>long</code>, <code>float</code>, and <code>Date</code> values; <code>Date</code> values are evaluated as greater than <code>long</code> 
            and <code>float</code> values; and <code>long</code> and <code>float</code> values are evaluated by their numeric 
            value with no need to separate them by type. Moreover, <code>null</code> always evaluates 
            less than any other key value that is a non-null value.
          </p>
          <p>
            The terms <dfn>greater than</dfn>, <dfn>less than</dfn> and <dfn>equal to</dfn> is defined in the terms of
            the above comparisons.
          </p>
          <p class="note">
            Only data types with natural ordering can be used as keys. 
            The ECMAScript <code>undefined</code> MUST NOT be used as a key.
          </p>
        </section>
        
        <section id="value-construct" class="section">
          <h4>Values</h4>
          <p>
            Values can be any data type supported by the <a>structured clone algorithm</a> 
            [[!HTML5]]. This includes simple types such as <code>DOMString</code>
            and <code>Date</code> as well as <code>Object</code> and <code>Array</code>
            instances.
          </p>
          
          <p>
            A database can derive a key from the contents of
            the value being stored. In such a case, only <code>Object</code> 
            instances MAY be stored as values. Only the direct enumerable
            properties of a stored <code>Object</code> instance SHOULD be 
            used to derive a key value.
          </p>
        </section>
        
        <section class="section" id="object-store-concept">  
          <h4>Object Store</h4>
          <p>
            An <dfn>object store</dfn> is a persistent storage mechanism that 
            holds key-value pairs, also called <a title="record">records</a> 
            or <dfn>stored objects</dfn>. An <a>object store</a>'s 
            <a title="record">records</a> are sorted by keys to enable fast 
            insertion and look up as well as ordered retrieval. 
          </p>
          <p>
            Every <a>object store</a> has a 
            <dfn title="object store name">name</dfn>. Within a <a>database</a>, 
            each <a>object store</a> MUST have a <a title="valid-name">valid</a> 
            and unique <a title="object store name">name</a>. 
          </p>          
          <p>
            If an <a>object store</a> uses keys generated from a monotonically
            increasing sequence, it MUST have a <dfn>key generator</dfn> that 
            produces unique keys for <a title="record">records</a> in that 
            <a>object store</a>. Alternatively, if an application provides keys, 
            they MAY either be identified as a part of the value being stored, 
            also called <dfn>in-line keys</dfn>, or be identified separately, 
            also called <dfn>out-of-line keys</dfn>. No two 
            <a title="record">records</a> in an <a>object store</a> MAY be 
            identified by the same key. An <a>object store</a> MUST have a 
            <dfn title="object store key path">key path</dfn> if it uses 
            <a>in-line keys</a>. The <a>key path</a> MUST be the name 
            of an enumerated property of all stored objects in that 
            <a>object store</a>.
          </p>
          <!--div class="ednote">
            The detached reading behavior MAY need more explanation.
          </div-->
          <p>
            The <a><code>IDBObjectStore</code></a> and <a><code>IDBObjectStoreSync</code></a>
            interfaces provide access to the metadata of an <a>object store</a>.
          </p>
        </section> <!-- Object store -->
        
        <section id="index-concept" class="section">
          <h4>Index</h4>
          <p>
            <a title="record">Records</a> in an <a>object store</a> can be 
            retrieved using the <a title="record">record's</a> key. However, 
            that MAY not always be adequate to recall 
            <a title="record">records</a>. An <a>index</a> is used to lookup 
            records in an <a>object store</a> other than through a
            <a>record</a> key.
          </p>
          <p>
            An <dfn>index</dfn> is a specialized persistent store that holds 
            key-value pairs such that each value is the key of objects in the 
            <dfn>referenced</dfn> <a>object store</a>. If an <a>index</a>'s 
            <dfn>unique</dfn> flag is set, then it MUST NOT allow duplicate 
            values for a key. Every <a>index</a> has a 
            <dfn title="index name">name</dfn>. Within an 
            <a>object store</a>, each <a>index</a> MUST have a
            <a title="valid-name">valid</a> and unique 
            <a title="index name">name</a>.
          </p>
          <p>
            If an <a>index</a> is <dfn>auto-populated</dfn>, then the user agent 
            populates records using the values stored in the <a>referenced</a> 
            <a>object store</a>. An <a>auto-populated</a> <a>index</a> MUST have 
            a <dfn title="index key path">key path</dfn>. This <a>key path</a> 
            MUST be the name of an enumerated property of every object to be 
            stored in the <a>object store</a> <a>referenced</a> by that 
            <a>index</a>. The <a>auto-populated</a> <a>index</a> record 
            corresponding to an <a>object store</a> record MUST satisfy the 
            following <dfn>index maintenance conditions</dfn>:
          </p>
          <ul>
            <li><a>index</a> record key = value of the enumerated property at 
            the <a title="index key path">key path</a> in the <a>object store</a> 
            record value</li>
            <li><a>index</a> record value = <a>object store</a> record key</li>
          </ul>
          <p>
            The <a><code>IDBIndex</code></a> and <a><code>IDBIndexSync</code></a> interfaces
            provide access to the metadata of an <a>index</a>.
          </p>
        </section> <!-- IDBIndex -->
        
       <section id="database-concept" class="section">
          <h4>Database</h4>
          <p>
            Each <a>origin</a> has an associated set of 
            <a title="database">databases</a>. A <dfn>database</dfn> comprises
            one or more <a title="object store">object stores</a>.
          </p>
          <p>
            Every <a>database</a> has a <dfn title="database name">name</dfn> which identifies it
            within a specific <a>origin</a>. The name can be any string value, including the empty string, and
            stays constant for the lifetime of the database. Each <a>database</a> also has a current
            <dfn>version</dfn>.
          </p>
          <p class="note">
            Implementations MUST support all names. If a implementation
            uses a storage mechanism which can't handle arbitrary database names,
            the implementation must use an escaping mechanism or something similar
            to map the provided name to a name that it can handle.
          </p>
          <div class="note">
            Each <a>database</a> has one version at a time; a <a>database</a> 
            can't exist in multiple versions at once. The only way to change the version is using a VERSION_CHANGE
            <a>transaction</a>.
          </div>
          <p>
            Each database contain a set of <a>object store</a>s. The set of <a>object store</a>s
            can changed, but can only be changed using VERSION_CHANGE transactions. When a new database is
            created it doesn't contain any <a>object store</a>s and has the empty string as <a>version</a>.
          </p>
          <p>
            The act of opening a <a>database</a> creates a <dfn>connection</dfn>. There MAY be multiple 
            <a>connection</a>s to a given <a>database</a> at any given time. Each connection has a
            <dfn>closePending</dfn> flag which initially is set to false.
          </p>
          <p>
            When a <a>connection</a> is initially created it is in <var>opened</var> state. The connection
            can be <dfn title="database close">closed</dfn> through several means. If the connection is GCed
            or execution context where the <a>connection</a> is created is destroyed (for example due to the
            user navigating away from that page), the connection is closed. The connection can also be closed
            explicitly using the <a>steps for closing a database connection</a>. When the connection is closed
            the <a>closePending</a> flag is always set to true if it hasn't already been.
          </p>
          <p>
            The <a><code>IDBDatabase</code></a> and <a><code>IDBDatabaseSync</code></a>
            interfaces represent a <a>connection</a> to a <a>database</a>. 
          </p>
        </section>  <!-- IDBDatabase -->

        <section id="transaction-concept" class="section">
          <h4>Transaction</h4>
          <p>
            A <dfn>transaction</dfn> is used to interact with the data in a <a>database</a>.
            Whenever data is read or written to the database this is done using a <a>transaction</a>.
          </p>
          <p>
            All transactions are created using a <a>connection</a>.
            The transaction has a <a>mode</a> which determines which types of interactions can be performed
            using the transaction. The <a>mode</a> is set when the transaction is created and remains
            constant for the lifetime of the transaction. The transaction also has a <dfn>scope</dfn> which
            determines which <a>object store</a>s the transaction can interact with. Finally, transactions
            have a <dfn>active</dfn> flag, which determines if new <a>request</a>s can currently be placed
            against the transaction. Finally, transactions also contain a <dfn>request list<dfn> of
            <a>request</a>s which have been placed against the transaction.
          </p>
          <p>
            Transactions are either static or dynamic which determines if the <a>scope</a> of the transaction
            can change during the lifetime of the transaction. <dfn>Static</dfn> transactions have a constant
            scope which is determined when the transaction is created and remains contant for the lifetime of
            the transaction. <dfn>Dynamic</dfn> transactions scope can change during the lifetime of the
            transaction.
          </p>
          <p class="issue">TODO: decide what happens when dynamic transactions need to lock a database
            object that is already exclusively locked by another transaction.
          </p>
          <p>
            <a title="transaction">Transactions</a> offer some protection from 
            application and system failures. A <a>transaction</a> may be used to
            store multiple data records or to conditionally modify certain data 
            records. A <a>transaction</a> represents an atomic and durable set 
            of data access and mutation operations. 
          </p>
          <p>
            <a title="transaction">Transactions</a> are expected to be short lived. This is encouraged
            using the automatically committing functionality described below. Authors can still cause
            transactions to run for a long time, however this is generally not a usage pattern which
            is recommended and can lead to bad user experience in some implementations.
          </p>
          <p>
            The <dfn title="transaction lifetime">lifetime</dfn> of a <a>transaction</a> is as follows:
          </p>
          <ol>
            <li>
              A transaction is <dfn title="transaction create">created</dfn> using of one of the available explicit
              APIs, for example <a class="idlType" href="#widl-IDBDatabase-transaction">IDBDatabase.transaction</a>.
              Which constructor is used, and the arguments passed to that constructor, determines if the transaction
              is <a>static</a> or <a>dynamic</a>, as well as which <a>mode</a> the transaction uses. If the transaction
              is <a>static</a>, the constructor arguments also determine what the <a>scope</a> of the transaction is.
              When a transaction is created its <a>active</a> flag is initially set to true.
            </li>
            <li>
              The implementation MUST allow <a>request</a>s to be <a title="place request">placed</a> against the transaction
              whenever the <a>active</a> flag is true. This is the case even if the transaction has not yet been
              <a title="transaction start">started</a>. Until the transaction is <a title="transaction start">started</a>
              the implementation MUST NOT execute these requests, but the implementation MUST still keep track of the
              <a>request</a>s and their order. Requests may only be placed against the transaction while the transaction
              is <a>active</a>. If a request is attempted to be placed against a transaction when it is not
              <a>active</a>, the implementation MUST reject the attempt by throwing a TRANSACTION_INACTIVE_ERR exception.
            </li>
            <li>
              Once an implementation is able to enforce the constraints defined for the <a>mode</a> of
              the transaction, defined below, the implementation MUST asynchronously
              <dfn title="transaction start">start</dfn> the transaction. When this happens is affected
              by the <a>mode</a> in which the transaction is opened, and which <a>object store</a>s are
              included in <a>scope</a> of the transaction.
            </li>
            <li class="issue">
              <p>
                Should we also define that if an implementation can't run two transactions at the same time,
                it MUST <a title="transaction start">start</a> them in the order they were
                <a title="transaction create">created</a>. Maybe only specify this if they have any overlapping
                <a>scope</a>. If we don't do this then starting two write transactions at the same time could
                result in the second one that's created running before the first one that is created.
              </p>
              <p>
                At least we need to ensure that a READ_ONLY transaction which is created after a READ_WRITE
                transaction has started sees the data that the READ_WRITE transaction wrote, and not a snapshot
                of what the object store looked like before the READ_WRITE transaction was started.
              </p>
              <p>
                Might be best to define this as part of the <a>mode</a> restrictions.
              </p>
            </li>
            <li>
              Once the transaction has been <a title="transaction start">started</a> the implementation can
              start executing the <a>request</a>s placed against the transaction. Unless otherwise defined requests
              MUST be executed in the order they are placed against the transaction. Likewise, their result MUST
              be returned in the order the request was placed against a specific transaction.
              There is no guarentee about the order that results from requests in different transactions are returned.
              Similarly, the isolation <a>mode</a> ensure that it doesn't matter which order requests placed against
              different transactions are executed.
            </li>
            <li>
              At any time a transaction can be <dfn>abort</dfn>ed, even if the transaction isn't currently
              <a>active</a>. When a transaction is aborted the implementation MUST undo (roll back) any changes
              made to the <a>database</a> using the transaction. This includes both changes to the contents of
              <a>object store</a>s as well as additions and removals of <a>object store</a>s and <a>index</a>es.
              <p class="note">
                A transaction can be aborted at any time before it is <a title="transaction finish">finished</a>.
                Including if it isn't <a>active</a> or hasn't yet
                <a title="transaction start">started</a>.
            </li>
            <li>
              Once a transaction no longer can become <a>active</a>, and if the transaction
              hasn't been <a>abort</a>ed, the implementation MUST automatically attempt to
              <dfn title="commit">commit</dfn> it. This usually happens after all requests placed against the
              transaction has been executed and their returned results handled, but no new requests has been placed
              against the transaction. When a transaction is committed implementation MUST atomically write
              any changes to the <a>database</a> made by requests placed against the transaction. That is, either all
              of the changes MUST be written, or if an error occurs, such as a disk write error, the implementation
              MUST NOT write any of the changes to the database. If such an error occurs the implementation MUST
              <a>abort</a> the transaction.
            </li>
            <li>
              When a transaction is <a>commit</a>ted or <a>abort</a>ed, it is said to be
              <def title="transaction finish">finished</def>. If a transaction can't be finished, for example
              due to the implementation crashing or the user taking some explicit action to cancel it, the
              implementation MUST <a>abort</a> the transaction.
            </li>
          </ol>
          <p>
            Transactions are opened in one of three <dfn title="mode">modes</dfn>. The mode
            determine how concurrent access to <a>object store</a>s in the transaction is isolated.
          </p>
          <ol>
            <li><code><dfn>READ_ONLY</dfn></code></li>
            <li><code><dfn>READ_WRITE</dfn></code></li>
            <li><code><dfn>VERSION_CHANGE</dfn></code></li>
          </ol>

          <p>
            The transaction <a>mode</a> determines both which operations are allowed to be performed
            during the transaction, as well whether two transactions can run concurrently or not.
            Which operations are allowed be be performed are defined in detail below, but in general
            transactions opened in <code><a>READ_ONLY</a><code> mode are only allowed to perform
            reading operations which does not change data. READ_WRITE transactions are allowed to
            perform reading and writing transactions to existing <a>object store</a>s, where as
            VERSION_CHANGE transactions are allowed to perform any operations, including ones that
            delete and create <a>object store</a>s and <a>index</a>es.
          </p>
          
          <p>
            A VERSION_CHANGE transaction can never run concurrently with other transactions. When
            a VERSION_CHANGE transaction is created, the implementation MUST wait to
            <a title="transaction start">start</a> the VERSION_CHANGE transaction until no other transactions
            against the same <a>database</a> are running. As long as the VERSION_CHANGE transaction, the implementation
            MUST wait with <a title="transaction start">starting</a> any other transactions against the same <a>database</a>
            until the VERSION_CHANGE transaction is finished.
          </p>
          <p>
            Any number of transactions opened in <a>READ_ONLY</a> mode are allowed to run concurrently,
            even if the transaction's <a>scope</a> overlap and include the same <a>object store</a>s.
            As long as a READ_ONLY transaction is running, the data that the implementation returns
            through <a>request</a>s created with that transaction MUST remain
            constant. That is, two requests to read the same piece of data MUST yield the same result
            both for the case when data is found and the result is that data, and for the case when data
            is not found and a lack of data is indicated.
          </p>
          <p>
            There are a number of ways that an implementation ensure this. It can prevent
            READ_WRITE transactions whose scope overlap the scope of the READ_ONLY transaction from
            starting until the READ_ONLY transaction is finished. Or it can allow the READ_ONLY
            transaction to see a snapshot of contents of the <a>object store</a>s which is taken when
            the READ_ONLY transaction is started.
          </p>
          <p>
            Similarly, implementations MUST ensure that a READ_WRITE transaction is only affected by
            changes to <a>object store</a>s that are made using the transaction itself. I.e. the
            implementation MUST ensure that another transaction does not modify the contents of
            <a>object store</a>s in the READ_WRITE transactions <a>scope</a>. The implementation
            MUST also ensure that if the READ_WRITE transaction completes successfully, that the
            changes written to <a>object store</a>s using the transaction can be comitted to the
            <a>database</a> without merge conflicts. An implementation MUST NOT abort a transaction
            due to merge conflicts.
          </p>
          <p>
            A result of these requirements is that an implementation MUST NOT allow two READ_WRITE
            transactions access the same <a>object store</a> at the same time. Even to perform just
            read operations. One implementation strategy is to never start a READ_WRITE transaction
            until all other READ_WRITE transactions with overlapping <a>scope</a>s have finished.
          </p>
          <p class="issue">
            TODO: This requirement could be tightened further. Currently two READ_WRITE transactions
            with <b>partially</b> overlapping scopes can run in paralell, until both (or "the second") of
            them touch object stores in the overlapping scope.
          </p>
          <p>
            User agents MUST ensure a reasonable level of fairness across transactions to prevent
            starvation. For example if multiple READ_ONLY transaction are started one after another
            the implementation MUST ensure that that doesn't indefinitely prevent a pending READ_WRITE
            transaction from <a title="transaction start">starting</a>.
          </p>
          <p>
            Conforming user agents MUST automatically abort a <a>transaction</a> at
            the end of the scope in which it was created, if an exception is propagated to that scope.
          </p>
          <p>
            Static <a>transaction</a> objects implement the 
            <a><code>IDBTransaction</code></a> or the
            <a><code>IDBTransactionSync</code></a> interfaces.
          </p>
          <p>
             Dynamic <a>transaction</a> objects implement the 
            <a><code>IDBDynamicTransaction</code></a> or the
            <a><code>IDBDynamicTransactionSync</code></a> interfaces.
          </p>
          <div class="issue">
            <p>Define dynamic transactions if we agree they should be part of this specification.</p>
          </div>
        </section> <!-- IDBTransaction -->

        <section class="section" id="request-concept">
          <h4>Requests</h4>
          <p>
            Each reading and writing operation on a <a>database</a> is done using a <dfn>request</dfn>.
            Every request represents one read or write operation. <a>Request</a>s are always belong to
            a <a>transaction</a>. The only exception to this is the request created when a <a>connection</a>
            is opened. <a>Request</a>s have a <dfn title="request done"><var>done</var></dfn> flag which
            initially is false, and a <dfn title="request source">source</dfn> object.
          </p>
          <p>
            When a request is created, it is always <dfn title="place request">placed</a> against a
            <a>transaction</a> using either the <a>steps to a asynchronously execute a request</a> or
            the <a>steps to a synchronously execute a request</a>.
        </section>

        <section class="section" id="range-concept">
          <h4>Key Range</h4>
          <p>
            Records can be retrived from <a>object store</a>s and <a>index</a>es
            using either <a>key value</a>s or <dfn>key range</dfn>s. A 
            key range is a continuous interval over some data type 
            used for keys.
          </p>
          <p>
            A <a>key range</a> MAY be lower-bounded or upper-bounded if there is 
            a value that is, respectively, smaller than or larger than all its 
            elements. A <a>key range</a> is said to be bounded if it is both 
            lower- and upper-bounded and unbounded otherwise. A <a>key range</a> MAY be open, 
            i.e., not including its endpoints or closed, i.e., including
            its endpoints. A <a>key range</a> MAY consist of a single value.
          </p>
          <p>
            The <a><code>IDBKeyRange</code></a> interface defines a 
            <a>key range</a>.
          </p>
          <dl class="idl" title="interface IDBKeyRange"> 
            <dt>readonly attribute any lower</dt>
            <dd>This value is the lower-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute any upper</dt>
            <dd>This value is the upper-bound of the <a>key range</a>.</dd>
            <dt>readonly attribute boolean lowerOpen</dt>
            <dd>Returns false if the lower-bound value is included in the <a>key range</a>.</dd>
            <dt>readonly attribute boolean upperOpen</dt>
            <dd>Returns false if the upper-bound value is included in the <a>key range</a>.</dd>
          </dl>
          <p>
            A <a><var>key value</var></a> is <dfn>in a <a>key range</a></dfn> if both the following conditions are
            fulfilled:
          </p>
          <ul>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-lower"><code>lower</code></a> value is <code>undefined</code> or
              <a>less than</a> <var>key value</var>. It may also be <a>equal to</a> <var>key value</var> if
              <a href="#widl-IDBKeyRange-lowerOpen"><code>lowerOpen</code></a> is <code>false</code>.
            </li>
            <li>
              The <a>key range</a> <a href="#widl-IDBKeyRange-upper"><code>upper</code></a> value is <code>undefined</code> or
              <a>greater than</a> <var>key value</var>. It may also be <a>equal to</a> <var>key value</var> if
              <a href="#widl-IDBKeyRange-upperOpen"><code>upperOpen</code></a> is <code>false</code>.
            </li>
          </ul>

          <p>
            To construct a <a>key range</a> a set of constructors are available. In languages with
            interface objects [[!WEBIDL]], these constructors are available on the <code>IDBKeyRange</code>
            interface object. In other languages these constructors are available through language specific
            means, for example as static functions.
          </p>
          <dl class="idl" title="[NoInterfaceObject] interface IDBKeyRangeConstructors"> 
            <dt>IDBKeyRange only()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with both <a href="#widl-IDBKeyRange-lower">lower</a> and
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and both
              <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a>
              set to false.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The only value</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange lowerBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to <var>open</var>,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <code>undefined</code> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to false.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The lower bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the lower-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange upperBound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <code>undefined</code>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to false,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>open</var>.
              <dl class="parameters">
                <dt>any bound</dt>
                <dd>The upper bound value</dd>
                <dt>optional boolean open</dt>
                <dd>Is the upper-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>value</var> parameter was not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
            <dt>IDBKeyRange bound()</dt>
            <dd>
              Creates and returns a new <a>key range</a> with <a href="#widl-IDBKeyRange-lower">lower</a> set to
              <var>lower</var>, <a href="#widl-IDBKeyRange-lowerOpen">lowerOpen</a> set to false,
              <a href="#widl-IDBKeyRange-upper">upper</a> set to <var>value</var> and
              and <a href="#widl-IDBKeyRange-upperOpen">upperOpen</a> set to <var>open</var>.
              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower-bound value</dd>
                <dt>any upper</dt>
                <dd>The upper-bound value</dd>
                <dt>optional boolean openLower</dt>
                <dd>Is the lower-bound value included in the <a>key range</a>. Defaults to false.</dd>
                <dt>optional boolean openUpper</dt>
                <dd>Is the upper-bound value included in the <a>key range</a>. Defaults to false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>The <var>lower</var> or <var>upper</var> parameters were not passed a valid <a>key value</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section> <!-- Key Range -->
        
        <section id="cursor-concept" class="section">
          <h4>Cursor</h4>
          <p>
            <a title="cursor">Cursors</a> are a transient mechanism used to 
            iterate over multiple records in a database. The storage operations
            are performed on the underlying <a>index</a> or an 
            <a>object store</a>.
          </p>
          
          <p>
            A <dfn>cursor</dfn> comprises a <dfn>range</dfn> of records in 
            either an <a>index</a> or an <a>object store</a>. A 
            <a title="cursor">cursor</a> maintains a <dfn>position</dfn> over 
            this series, which moves in a <dfn>direction</dfn> that is either 
            monotonically increasing or decreasing order of the record keys. 
          </p>
          <p>
            <a title="cursor">Cursor</a> objects implement the <a><code>IDBCursor</code></a> 
            or the <a><code>IDBCursorSync</code></a> interfaces.
          </p>
        </section> <!-- IDBCursor -->

        <section class="section">
          <h3>The <code>IDBDatabaseException</code> Interface</h3>
          <dl class="idl" title="exception IDBDatabaseException">
            <dt>const unsigned short UNKNOWN_ERR = 0</dt>
            <dd>The operation failed for reasons unrelated to the database
              itself and not covered by any other error code.</dd>
            <dt>const unsigned short NON_TRANSIENT_ERR = 1</dt>
            <dd>This error occurred because an operation was not allowed on 
            an object. A retry of the same operation would fail unless the
            cause of the error is corrected.</dd>
            <dt>const unsigned short NOT_FOUND_ERR = 2</dt>
            <dd>The operation failed because the requested database
            object could not be found. For example, an object store
            did not exist but was being opened.</dd>
            <dt>const unsigned short CONSTRAINT_ERR = 3</dt>
            <dd>A mutation operation in the transaction failed due to a
            because a constraint was not satisfied. For example, an
            object such as an object store or index already
            exists and a new one was being attempted to be created.</dd>
            <dt>const unsigned short DATA_ERR = 4</dt>
            <dd>Data provided to an operation does not meet requirements.</dd>
            <dt>const unsigned short NOT_ALLOWED_ERR = 5</dt>
            <dd>A mutation operation was attempted on a database that
            <dt>const unsigned short TRANSACTION_INACTIVE_ERR = 6</dt>
            <dd>A <a>request</a> was placed against a transaction which is
            currently not <a>active</a>, or which is
            <a title="transaction finish">finished</a>.</dd>
            <dt>const unsigned short ABORT_ERR = 7</dt>
            <dd>A <a>request</a> was aborted, for example through a call
            to <a href="#widl-IDBTransaction-abort"><code>IDBTransaction.abort</code></a>.</dd>
            <dt>const unsigned short SERIAL_ERR = 11</dt>
            <dd>The operation failed because of the size of the data set 
            being returned or because there was a problem in serializing or 
            deserializing the object being processed.</dd>
            <dt>const unsigned short RECOVERABLE_ERR = 21</dt>
            <dd>The operation failed because the database was prevented
            from taking an action. The operation might be able to succeed
            if the application performs some recovery steps and retries
            the entire transaction. For example, there was not enough 
            remaining storage space, or the storage quota was reached
            and the user declined to give more space to the database.</dd>
            <!--const unsigned short QUOTA_ERR = 22;
                <dd>The statement failed because there was not enough remaining
     storage space, or the storage quota was reached and the user
     declined to give more space to the database.</dd>-->
            <dt>const unsigned short TRANSIENT_ERR = 31</dt>
            <dd>The operation failed because of some temporary problems.
            The failed operation might be able to succeed when the
            operation is retried without any intervention by 
            application-level functionality.</dd>
            <dt>const unsigned short TIMEOUT_ERR = 32</dt>
            <dd>A lock for the transaction could not be obtained in a
            reasonable time.</dd>
            <dt>const unsigned short DEADLOCK_ERR = 33</dt>
            <dd>The current transaction was automatically rolled back
            by the database because of deadlock or other transaction
            serialization failures.</dd>
            <dt>attribute unsigned short code</dt>
            <dd>
              Return the most appropriate error code.
            </dd>
            <dt>attribute DOMString message</dt>
            <dd>
              Return an error message describing the exception raised. 
              The message should be localized to the user's language.
            </dd>
          </dl>
        </section>
      </section>  
      <!-- end-content -->
    </section>
  </body>
</html>
