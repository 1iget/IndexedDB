<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <meta name='revision' content='$Id: Overview.html,v 1.41 2010/03/24 17:58:17 nmehta3 Exp $'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/simple-node.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2010-01-05",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          extraCSS: [
                "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                "SimpleDB.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
      };
    </script>
    <script class="remove">
      function examples() {
        var examples = document.querySelectorAll('div.example');
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });
        for (var i = 0; i < examples.length; i++) {
          var example = examples.item(i);
          var header = sn.element('div', {'class': 'exampleHeader'}, null, 'Example');
          example.insertBefore(header, example.firstChild);
        }
      }

      function codeblocks() {
        document.normalize();
        sn = new berjon.simpleNode({
                        "":     "http://www.w3.org/1999/xhtml",
                        "x":    "http://www.w3.org/1999/xhtml"
                    });

        var blocks = document.querySelectorAll('codeblock');
        for (var i = 0; i < blocks.length; i++) {
          var codeblock = blocks.item(i);
          var div = sn.element('div', {'class': 'block'})
          sn.element('span', {'class': 'blockTitle'},
            sn.element('div', {'class': 'blockTitleDiv'}, div), 'ECMAScript');
          var code = sn.element('code', {'class': 'es-code'},
                       sn.element('pre', {'class': 'code'},
                         sn.element('div', {'class': 'blockContent'}, div)));
          sn.copyChildren(codeblock, code);
          codeblock.parentNode.replaceChild(div, codeblock);
        }
      }
      window.onload = function() {
        examples();
        codeblocks();
        (new berjon.respec()).loadAndRun();
      }
    </script>
    <!--[if IE]>
    <style type='text/css'>
      .ignore {
        -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
        filter: alpha(opacity=50);
      }
    </style>
    <![endif]-->
    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      h5 {
        display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>


    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>

      <!-- begin-content -->
      <section id="sync-database" class="section">
        <h3>Synchronous APIs</h3>
        <section id="opening-sync" class="section">
          <h4>Opening a database</h4>
          <p>
            <a title="Worker" class="externalDFN"><code>Worker</code></a> objects MUST implement the 
            <a><code>IDBEnvironmentSync</code></a> interface.
          </p>
          <p class="idl" title="WorkerUtils implements IDBEnvironmentSync">
          </p>
          
          <dl class="idl" title="[NoInterfaceObject] interface IDBEnvironmentSync">
            <dt>readonly attribute IDBFactorySync indexedDBSync</dt>
            <dd>This attribute provides applications a mechanism for accessing
              capabilities of indexed databases.</dd>
          </dl>
          
          <dl class="idl" title="interface IDBFactorySync">
            <dt>IDBDatabaseSync open()</dt>
            <dd>
              <p>
                When invoked, this method synchronously runs the <a>steps for opening a database</a>.
                Let <var>origin</var> be the origin of the <a>IDBEnvironmentSync</a> used to access
                this <a>IDBFactorySync</a>, <var>name</var> be the <var>name</var> argument passed
                to the function and <var>request</var> be the created <a>IDBRequest</a>.
              </p>
              <p>
                If an error is returned from the steps above, then the implementation MUST
                throw an <a><code>IDBDatabaseException</code></a> with its 
                <a class="idlType" href="#widl-IDBDatabaseException-code"><code>code</code></a>
                and <a class="idlType" href="#widl-IDBDatabaseException-message"><code>message</code></a> set to
                appropriate values for the error.
              </p>
              <p>
                If the steps above are successful, the implementation MUST create a IDBDatabaseSync
                object representing the created <a>connection</a> and return it.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="database name">name</a> for the <a>database</a></dd>
              </dl>
            </dd>
          </dl>
        </section>
        
        <section id="database-interface-sync" class="section">
          <h4>Database</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <dl class="idl" title="interface IDBDatabaseSync">
            <dt>readonly attribute DOMString name</dt>
            <dd>
              On getting, this attribute MUST return the <a title="database name">name</a>
              of the <a title="connection">connected</a> <a>database</a>.
            </dd>
            <dt>readonly attribute DOMString description</dt>  
            <dd>
              On getting, this attribute MUST return the description of the
              <a title="connection">connected</a> <a>database</a> at the time of opening.
            </dd>
            <dt>readonly attribute DOMString version</dt>
            <dd>
              On getting, this attribute MUST return the <a>version</a> of this
              <a>database</a>. This attribute has the <a>null</a> value when the
              <a title="connection">connected</a> <a>database</a> is first created.
            </dd>
            <dt>readonly attribute DOMStringList objectStoreNames</dt>
            <dd>
              On getting, this attribute MUST return a list of names of the 
              <a title="object store">object stores</a> currently in the 
              <a title="connection">connected</a> <a>database</a>.
            </dd>
            <!-- There is no notion of a current transaction any more
            <dt>readonly attribute IDBTransactionSync currentTransaction</dt>
            <dd>
              On getting, this attribute MUST return a <a><code>IDBTransaction</code></a> object
              corresponding to the <a>transaction</a> that is <a>active</a> in this
              <a>database</a> <a>connection</a>.
            </dd>-->
            <dt>IDBObjectStoreSync createObjectStore()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>object store</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of a new <a>object store</a></dd>
                <dt>[Null=Null] DOMString keyPath</dt>
                <dd>The <a title="object store key path">key path</a> of a new 
                <a>object store</a>. If <a>null</a> path is specified, then the 
                <a>object store</a> created will not have a <a>key path</a> and will
                use <a>out-of-line keys</a>.</dd>
                <dt>optional boolean autoIncrement</dt>
                <dd>Whether the <a>object store</a> created should have a 
                <a>key generator</a>. The default
                value of this parameter is false.</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dt>IDBObjectStoreSync openObjectStore()</dt>
            <dd>
              <p>
                This method opens the <a>object store</a> with the given name
                in the <a title="connection">connected</a> <a>database</a> for the
                <a>mode</a> specified.
              </p>              
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of an existing 
                <a>object store</a></dd>
                <dt>optional unsigned short mode</dt>
                <dd>The <a>mode</a> used to access the <a>object store</a>. The default 
                for this is <a><code>IDBObjectStore</code></a>.<a class="idlType" href="#widl-IDBObjectStore-READ_WRITE"><code>READ_WRITE</code></a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If an <a>object store</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
              </dl>
            </dd>
            <dd>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-CONSTRAINT_ERR"><code>CONSTRAINT_ERR</code></a></dt>
                <dd>
                If an <a>index</a> with the same name, compared in a case-sensitive
                manner, already exists in the <a title="connection">connected</a> 
                <a>database</a>.
                </dd>
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void deleteObjectStore()</dt>
            <dd>
              <p>
                This method destroys an <a>object store</a> with the 
                given name as well as all <a title="index">indexes</a> that are 
                <a title="referenced">referencing</a> that <a>object store</a>.
              </p>
              
              <dl class="parameters">
                <dt>DOMString storeName</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>object store</a> with the given name, compared in a
                case-sensitive manner, does not already exist
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void setVersion()</dt>
            <dd>
              This method sets the <a>version</a> of the 
              <a title="connection">connected</a> <a>database</a>.
              <dl class="parameters">
                <dt>[TreatNullAs=EmptyString] DOMString      version</dt>
                <dd>The <a>version</a> to store in the <a>database</a></dd>
              </dl>
            </dd>
            <dt>IDBTransactionSync transaction()</dt>
            <dd>
              <p>
                This method, when called MUST execute the
                <a title="create a static transaction">steps for creating a transaction</a> in a asychronous
                fashion. If the <var>storeNames</var> argument is provided and non-empty then then use that
                list as the <var>names</var> argument. Otherwise use the full set of <a>object store</a>
                names for the <a>IDBDatabase</a> as <var>names</var> argument. The <var>mode<var> and
                <var>timeout</var> arguments are forwarded to the algorithm as-is. The <var>connection</var>
                argument is set to the <a>IDBDatabase</a> that the <code>transaction()</code> method was
                called on.
              </p>
              <p>
                The method returns a <a>IDBTransactionSync</a> object representing the <a>transaction</a>
                returned by the steps above</a>.
              </p>
              <dl class="parameters">
                <dt>optional DOMStringList storeNames</dt>
                <dd>The names of <a title="object store">object stores</a> and 
                <a title="index">indexes</a> in the <a>scope</a> of the new
                <a>transaction</a></dd>
                <dt>optional unsigned long timeout</dt>
                <dd>The interval in milliseconds which this operation is allowed to 
                take to reserve all the <a>database</a> objects identified in the new
                <a title="transaction">transaction's</a> <a>scope</a>. The default
                is user agent specific</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-TIMEOUT_ERR"><code>TIMEOUT_ERR</code></a></dt>
                <dd>
                If <a title="transaction start">starting</a> the transaction takes longer than the specified timeout.
                </dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The close() method has been called on this <a>IDBDatabase</a> instance.</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>One of the names provided in the <var>storeNames</var> argument doesn't exist in this <a>database</a>.</dd>
              </dl>
            </dd>
          </dl>  
        </section>
          
        <section class="section" id="object-store-sync">  
          <h4>Object Store</h4>
          <div class="example">       
            <p>
              In the following example, we set up an <a>object store</a> to use the 
              <a title="object store key path">key path</a> <em>id</em>. This
              <a>object store</a> is also designed to use a <a>key generator</a>.
            </p>
            <codeblock>var db = indexedDB.open('AddressBook', 'Address Book');
if (db.version !== '1') {
   var olddb = indexedDB.open('AddressBook', 'Address Book');
   olddb.createObjectStore('Contact', 'id', true);
   olddb.setVersion('1');
}</codeblock>
            <p>
              Using this <a>database</a>, we can store records in the <em>Contact</em>
              <a>object store</a>. 
            </p>
            <codeblock>var store = db.openObjectStore('Contact');

var lincoln = {name: 'Lincoln', number: '7012'};
var contact = store.put(lincoln);
// contact.id === 1</codeblock>
            <p>
              A stored value can be retrieved using the same key used by the
              first put operation.
            </p>
            <codeblock>var contact = store.get(1);
// contact.name === 'Lincoln'</codeblock>
            <p>
              A second put operation will overwrite the record stored by the first 
              put operation.
            </p>
            <codeblock>var abraham = {id: 1, name: 'Abraham', number: '2107'};
store.put(abraham);</codeblock>
            <p>
              Now when the object store is read with the same key, the result 
              is different compared to the object read earlier.
            </p>
            <codeblock>var contact = store.get(1);
// contact.id === 1 &amp;&amp; contact.name === 'Abraham';</codeblock>
            <p>
              Additionally, all the <a>records</a> of an <a>object store</a> 
              matching a certain <a>key range</a> can be retrieved in key order.
            </p>
            <codeblock>var range = new IDBKeyRange.bound(2, 4);
var cursor = store.openCursor(range);
// each value is a contact and each key is the id for that  
// contact whose id is between 2 and 4, both inclusive
cursor.continue();</codeblock>
          </div>
          
          <dl title="interface IDBObjectStoreSync" class="idl">
            <dt>const     unsigned short READ_WRITE    = 0</dt>
            <dd>Modification operations are allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>const     unsigned short READ_ONLY    = 1</dt>
            <dd>Modification operations are not allowed on the <a>object store</a>
            in this mode.</dd>
            <dt>readonly attribute unsigned short mode</dt>
            <dd>On getting, provide the <a>mode</a> for isolating access to data 
            inside this <a>object store</a>.
            </dd>
            <dt>readonly attribute DOMString      name</dt>
            <dd>          
              On getting, provide the <a title="object store name">name</a> of this
              object store.        
            </dd>
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="object store key path">key path</a>
              of this <a>object store</a>. If this attribute is <code>null</code>,
              the application MUST provide a key value for each modification operation.
            </dd>
            <dt>readonly attribute DOMStringList  indexNames</dt>
            <dd>
            On getting, provide a list of the names of <a title="index">indexes</a> on 
            objects in this <a>object store</a>.
            </dd>
            <dt>any put()</dt>
            <dd>
              Store the given value in this <a>object store</a> by following
              the <a>steps for storing a record into an object store</a>. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>This <a>object store</a> uses <a>out-of-line</a> keys and
                no <a>key generator</a> but the <var>key</var> parameter was not
                passed</dd>
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
              </dl>
            </dd>
            <dt>any add()</dt>
            <dd>
              Store the given value in this <a>object store</a> by following
              the <a>steps for storing a record into an object store</a> with the no-overwrite flag set. The
              returned object from this method is the key for the stored record.
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the record</dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the record</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>This <a>object store</a> uses <a>out-of-line</a> keys and
                no <a>key generator</a> but the <var>key</var> parameter was not
                passed</dd>
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
                <dt>CONSTRAINT_ERR</dt>
                <dd>A record
                exists in this <a>object store</a> for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>void delete()</dt>
            <dd>
              Remove the record from this <a>object store</a> by following
              the <a>steps for deleting a record from an object store</a>
              corresponding to the given key.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be deleted</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>object store</a> for the record 
              corresponding to the given key by following the
              <a>steps for retrieving a value from an object store</a>. The
              value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be deserialized by the internal
                structured cloning algorithm</dd>
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>object store</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>IDBIndexSync createIndex()</dt>
            <dd>
              <p>
                This method creates a and returns a new <a>index</a> with the
                given name in the <a title="connection">connected</a> <a>database</a>.
              </p>
              <dl class="parameters">
                <dt>DOMString      name</dt>
                <dd>The <a title="index name">name</a> of a new <a>index</a></dd>
                <dt>DOMString      keyPath</dt>
                <dd>The <a title="index key path">key path</a> used by the new
                <a>index</a></dd>
                <dt>optional boolean unique</dt>
                <dd>The <a>unique</a> flag for the new <a>index</a>. The default
                value of this parameter is false.</dd>
              </dl>
            <dt>IDBIndexSync index()</dt>
            <dd>
              Returns a <a>IDBIndexSync</a> representing a <a>index</a> that is part of the
              to this <a>object store</a>. Every call to this function on the same
              <a>IDBObjectStoreSync</a> instance and with the same <var>name</var> returns the same <a>IDBIndexSync</a> instance.
              However the retured <a>IDBIndexSync</a> instance is specific to this <a>IDBObjectStoreSync</a> instance. If this
              function is called on a different <a>IDBObjectStoreSync</a> instance, a different <a>IDBIndexSync</a> instance is
              returned. A result of this is that different <a>IDBTransactionSync</a>s use different <a>IDBIndexSync</a> instances
              to represent the same <a>index</a>.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>      
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>void deleteIndex()</dt>
            <dd>
              <p>
                This method destroys an <a>index</a> with the 
                given name. 
              </p>
              <dl class="parameters">
                <dt>DOMString indexName</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the <a>index</a> with the given name does not exist 
                in the <a title="connection">connected</a> <a>database</a>.      
                </dd>
              </dl>
            </dd>
            <dt>IDBCursorSync openCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this
              <a>object store</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>. 
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>object store</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>
          </dl>                
        </section>
        <section id="index-sync" class="section">  
          <h4>Index</h4>
          
          <div class="example">
            <p>
              An <a>index</a> can be created for retrieving records other than
              by using record keys. Continuing the earlier example, an auto-populated
              index could be maintained on the <em>name</em> property of objects
              in the <em>Contact</em> <a>object store</a>.
            </p>
            <codeblock>var db = indexedDB.<a>open</a>('AddressBook', 'Address Book');
if (db.version === '1') {
   var olddb = indexedDB.<a>open</a>('AddressBook', 'Address Book');
   olddb.<a>createObjectStore</a>('Contact', 'id', true);
   olddb.<a>createIndex</a>('ContactName', 'Contact', 'name', false);
   olddb.<a>setVersion</a>('2');
}</codeblock>
            <p>
              For example, the <em>id</em> of an object with the <em>name</em> 
              property value 'Lincoln' can be retrieved using the 
              <em>ContactName</em> <a>index</a>.
            </p>
            <codeblock>var index = db.<a>openIndex</a>('ContactName');
var id = index.<a>get</a>('Lincoln');
// id === 1</codeblock>              
            <p>
              Additionally, all the records of an <a>object store</a> matching
              a certain range index keys can be retrieved in key order. When
              objects are retrieved from the <em>Contact</em> <a>object store</a>, 
              they are arranged by the value of the <em>id</em> attribute. On the
              other hand, when objects are retrieved using the <em>ContactName</em>
              <a>index</a>, they are arranged by the value of the <em>name</em> 
              property. 
            </p>
            <codeblock>var range = new <a>IDBKeyRange</a>.<a>bound</a>('L', 'M');
var cursor = index.<a>openCursor</a>(range);
// each value is a contact and each key is the name for that  
// contact whose name's first letter is either L or M
cursor.continue();</codeblock>
            <p>
              If, on the other hand, we only want the names but not the <em>Contact</em>
              objects for a given range, then we can use a different mechanism for that.
            </p>
            <codeblock>var range = new <a>IDBKeyRange</a>.<a>bound</a>('L', 'M');
var cursor = index.<a>openObjectCursor</a>(range);
// each value is a contact and each key is the name for that  
// contact whose name's first letter is either L or M
cursor.continue();</codeblock>
          </div>
              
          <dl class="idl" title="interface IDBIndexSync">
            <dt>readonly attribute DOMString      name</dt>
            <dd>
              On getting, provide the <a title="index name">name</a> of this <a>index</a>.        
            </dd>
            <dt>readonly attribute DOMString      storeName</dt>
            <dd>
              On getting, provide the <a title="object store name">name</a> of this
              <a title="index">index's</a> <a>referenced</a> <a>object store</a>.
            </dd>
        
            <dt>readonly attribute DOMString      keyPath</dt>
            <dd>
              On getting, provide the <a title="index key path">key path</a> of this
              <a>index</a>. If this attribute is <code>null</code>,
              this <a>index</a> is not <a>auto-populated</a>.
            </dd>
            
            <dt>readonly attribute boolean unique</dt>
            <dd>
              On getting, provide the <a>unique</a> flag of this <a>index</a>.
            </dd>

            <dt>void openCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this 
              <a>index</a>'s <a>referenced</a> <a>object store</a> as arranged by
              this <a>index</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>.
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>index</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>

            <dt>void openKeyCursor()</dt>
            <dd>
              Create a <a>cursor</a> over the <a>records</a> of this 
              <a>index</a>. The <a>range</a> of this <a>cursor</a> matches 
              the <a>key range</a> specified as the <var>range</var> parameter, or
              if that parameter is not specified or <code>null</code>, then the 
              range includes all the <a>records</a>. 
              <dl class="parameters">
                <dt>optional IDBKeyRange    range</dt>
                <dd>The <a>key range</a> to use as the <a>cursor</a>'s <a>range</a></dd>
                <dt>optional unsigned short direction</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>No records exist in this <a>index</a> 
                for the requested <a>key range</a>.
                </dd>
              </dl>
            </dd>
            <dt>any get()</dt>
            <dd>
              Retrieve the value from this <a>index</a>'s <a>referenced</a>
              <a>object store</a> for the record corresponding to the given key
              by following the <a>steps for retrieving a referenced value from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
            <dt>any getKey()</dt>
            <dd>
              Retrieve the value from this <a>index</a> for the record 
              corresponding to the given key by following the 
              <a>steps for retrieving a value from an index</a>.
              The value returned from this method is the retrieved value.
              <dl class="parameters">
                <dt>any key</dt>
                <dd>Key identifying the record to be retrieved</dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_FOUND_ERR</dt>
                <dd>A record did not exist in this <a>index</a> 
                for the key <var>key</var> parameter.
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section class="section" id="cursor-sync">  
          <h4>Cursor</h4>
          <p>
            Using the synchronous API, an application can process all the records
            in the <a>cursor</a>'s <a>range</a>. No two values provided by the
            user agent to callbacks processing data in this <a>cursor</a> can be
            identical.
          </p>
          <div class="example">
            <p>
              By default, a <a>cursor</a> walks over objects starting at the
              first record and ending at the last record including
              all the duplicates encountered along the way. If the
              cursor callback returns true, then the iteration is 
              stopped.
            </p>
            <codeblock>var objects = ...
var cursor = objects.openCursor();
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
            
            <p>
              To start at the last record and end in the first record, the cursor 
              should be created with the direction parameter <a class="idlType" href="#widl-IDBCursor-PREV"><code>PREV</code></a>.
            </p>
            <codeblock>var objects = ...
var cursor = objects.openCursor(<a>IDBCursor</a>.<a>PREV</a>);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>

            <p>
              To start at a certain key and end in the last record, i.e.,
              for a lower-bounded cursor, while skipping duplicates,
              the cursor should be created with both the required 
              start key and the direction parameter. 
            </p>
            
            <codeblock>var objects = ...
var range = <a>IDBKeyRange</a>.leftBound(key);
objects.openCursor(range, <a>IDBCursor</a>.<a>NEXT_NO_DUPLICATE</a>);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
        
            <p>
              It is also possible to create a bounded cursor, i.e., with
              application-specified starting and ending points, the
              cursor should be created with both the required keys.
              If the range is inclusive of both keys, then additional
              flags are required. In the following example, all keys
              with values in the inclusive range (<code>start</code>, 
              <code>end</code>) are returned with all their duplicates,
              from the beginning of the range to its end.
            </p>
  
            <codeblock>var objects = ...
var range = <a>IDBKeyRange</a>.bound(start, end);
objects.openCursor(range);
// act on each object and continue the cursor to its end
cursor.continue();
</codeblock>
          </div>
          <dl title="interface IDBCursorSync" class="idl">
            <dt>const     unsigned short     NEXT = 0</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     NEXT_NO_DUPLICATE = 1</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically increasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>
            <dt>const     unsigned short     PREV = 2</dt>
            <dd>
              indicates that <a>cursor</a> should yield all records, including  
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys.
            </dd>
            <dt>const     unsigned short     PREV_NO_DUPLICATE = 3</dt>
            <dd>
              indicates that this <a>cursor</a> should yield all records, not including
              duplicates and its <a>direction</a> is monotonically decreasing 
              order of keys. For every key with duplicate values, only the first
              record is yielded.
            </dd>

            <dt>readonly attribute unsigned short     direction</dt>
            <dd>            
            On getting, provide the traversal <a>direction</a> of the <a>cursor</a>.
            </dd>
            <dt>readonly attribute any key</dt>
            <dd>The key for the record at the <a>cursor</a>'s <a>position</a>.</dd>
            <dt>attribute any value</dt>
            <dd>The value for the record at the <a>cursor</a>'s <a>position</a>.
              <dl class="setraises" title="IDBDatabaseException">
                <dt>DATA_ERR</dt>
                <dd>If the underlying <a>object store</a> uses <a>in-line keys</a>
                and the property at the <a title="object store key path">key path</a>
                does not match the key in this <a>cursor</a>'s <a>position</a>.
                <dt>SERIAL_ERR</dt>
                <dd>The data being stored could not be serialized by the internal
                structured cloning algorithm</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The underlying <a>index</a> or <a>object store</a> does not
                support updating the item because it is open in the 
                <a class="idlType" href="#widl-IDBObjectStore-READ_ONLY"><code>READ_ONLY</code></a> <a>mode</a>.</dd>
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>An index record cannot be changed because the underlying 
                <a>index</a> is <a>auto-populated</a>.</dd>
              </dl>
            </dd>

            <dt>boolean  continue()</dt>
            <dd>
              Advance the <a>cursor</a> to the next position along its <a>direction</a>
              to the item whose key matches the optional parameter. If no such
              parameter is provided, advance to the immediate next position. If
              the <a>cursor</a> has reached the end of its <a>range</a>, then this
              method returns false, otherwise it returns true.
              <dl class="parameters">
                <dt>optional any key</dt>
                <dd>The next key to position this <a>cursor</a> at</dd>
              </dl>
            </dd>
            
            <dt>void    delete()</dt>
            <dd>          
              <p>
                Delete the object at the <a>cursor</a>'s <a>position</a>. The cursor's
                position is not changed. Any attempts to retrieve the cursor's
                current value will return <code>null</code>.
              </p>
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>The underlying <a>index</a> or <a>object store</a> does not
                support updating the item because it is open in the 
                <a class="idlType" href="#widl-IDBObjectStore-READ_ONLY"><code>READ_ONLY</code></a> <a>mode</a>.</dd>
              </dl>
            </dd>
          </dl>
        </section>
        <section id="transaction-sync" class="section">
          <h4>Transaction</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            When an application <a title="create a transaction">creates</a> a 
            <a>transaction</a> synchronously, it blocks until the user agent is able
            to reserve the required <a>database</a> <a>objects</a>.
          </p>
          <dl class="idl" title="interface IDBTransactionSync">
            <dt>attribute boolean static</dt>
            <dd>If <code>true</code>, then this <a>transaction</a> is <a>static</a>
              and <code>false</code> otherwise.
            <dt>attribute IDBDatabaseSync db</dt>
            <dd>The <a>database</a> <a>connection</a> of which this <a>transaction</a>
              is a part</dd>
            <dt>IDBObjectStoreSync objectStore()</dt>
            <dd>
              Returns a <a>IDBObjectStoreSync</a> representing a <a>object store</a> that is part of the
              to the <a>scope</a> of this <a>transaction</a>. Every call to this function on the same
              <a>IDBTransactionSync</a> instance and with the same <var>name</var> returns the same <a>IDBObjectStoreSync</a> instance.
              However the retured <a>IDBObjectStoreSync</a> instance is specific to this <a>IDBTransactionSync</a>. If this
              function is called on a different <a>IDBTransactionSync</a>, a different <a>IDBObjectStoreSync</a> instance is returned.
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The requested <a>object store</a></dd>
              </dl>
              <dl class="exception" title="IDBDatabaseException">
                <dt><a class="idlType" href="#widl-IDBDatabaseException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></a></dt>
                <dd>
                If the requested <a>object store</a> is not in this 
                <a>transaction</a>'s <a>scope</a>.
                </dd>
              </dl>
            </dd>
            <dt>void abort()</dt>
            <dd>
              If this <a>transaction</a> is <a title="transaction finish">finished</a>, throw a NOT_ALLOWED_ERR
              exception. Otherwise this method <a title="transaction abort">aborts</a> the transaction by running the
              <a>steps to abort a transaction</a> with <var>code</var> set to ABORT_ERR.
              <dl class="exception" title="IDBDatabaseException">
                <dt>NOT_ALLOWED_ERR</dt>
                <dd>If this <a>transaction</a> has already been committed or aborted.</dd>
              </dl>
            </dd>
          </dl>
          <div class="note">
            Applications MUST not assume that committing the <a>transaction</a>
            produces an instantaneously durable result. The user agent
            MAY delay flushing data to durable storage until an appropriate
            time.
          </div>
                              
          <p>
            Once a <a>transaction</a> is aborted or committed, the <a>active</a> 
            <a>transaction</a> on this <a>database</a> <a>connection</a> is removed.
            A new <a>transaction</a> can be created to perform operations atomically.
          </p>
        </section> <!-- IDBTransaction -->
       </section>
      </section>
      <!-- end-content -->
     </section>
  </body>
</html>
