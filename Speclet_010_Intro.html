<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API</title>
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          //publishDate:          "2010-01-05",

          previousPublishDate:  "2011-12-06",
          previousMaturity:     "WD",

          edDraftURI:           "http://dev.w3.org/2006/webapi/WebSimpleDB/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Nikunj Mehta", url: "mailto:nikunj@o-micron.com",
                company: "Invited Expert" },
              { name: "Jonas Sicking", url: "mailto:jonas@sicking.cc",
                company: "Mozilla" },
              { name: "Eliot Graff", url: "mailto:eliotgra@microsoft.com",
                company: "Microsoft" },
              { name: "Andrei Popescu", url: "mailto:andreip@google.com",
                company: "Google" },
              { name: "Jeremy Orlow", url: "mailto:jorlow@google.com",
                company: "Google" },
              { name: "Joshua Bell", url: "mailto:jsbell@google.com",
                company: "Google" }
          ],

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",

          noIDLSectionTitle: true,
      };
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      .example .example .example-title {
          display: none
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>
    
    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>
    <!-- begin-content -->
    <section id='introduction' class='section informative'>
      <h2>Introduction</h2>

	
      <p>
        User agents need to store large numbers of objects locally in
        order to satisfy off-line data requirements of Web applications.
        [[WEBSTORAGE]] is useful for
        storing pairs of keys and their corresponding values. However, it does 
        not provide in-order retrieval of keys, efficient searching over
        values, or storage of duplicate values for a key. 
      </p>
      
      <p>
        This specification provides a concrete API to perform advanced key-value data management
        that is at the heart of most sophisticated query processors. It does
        so by using transactional databases to store keys and their 
        corresponding values (one or more per key), and providing a means
        of traversing keys in a deterministic order. This is often implemented
        through the use of persistent B-tree data structures that are considered
        efficient for insertion and deletion as well as in-order traversal of
        very large numbers of data records.
      </p>

      <aside class="example">
          <p>
              In the following example, the <!--asynchronous--> API is used to access a "library"
              database that holds books stored by their "isbn" attribute. Additionally,
              an index is maintained on the "title" attribute of the objects
              stored in the object store. This index can be used to look up books
              by title, and enforces a uniqueness constraint. Another index is
              maintained on the "author" attribute of the objects, and can be used
              to look up books by author.
          </p>
          <p>
              A connection to the database is opened. If the "library" database
              did not already exist, it is created and an event handler creates
              the object store and indexes. Finally, the opened connection is
              saved for use in subsequent examples.
          </p>
          <pre class="example highlight">
var request = indexedDB.open("library");

request.onupgradeneeded = function() {
  // The database did not previously exist, so create object stores and indexes.
  var db = request.result;
  var store = db.createObjectStore("books", {keyPath: "isbn"});
  var titleIndex = store.createIndex("by_title", "title", {unique: true});
  var authorIndex = store.createIndex("by_author", "author");

  // Populate with initial data.
  store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
  store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
  store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});
};

request.onsuccess = function() {
  db = request.result;
};
          </pre>

          <p>
              The following example populates the
              database using a transaction.
          </p>
          <pre class="example highlight">
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");

store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});

tx.oncomplete = function() {
  // All requests have succeeded and the transaction has committed.
};
          </pre>

          <p>
              The following example looks up a single book in the database
              by title using an index.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_title");

var request = index.get("Bedrock Nights");
request.onsuccess = function() {
  var matching = request.result;
  if (matching !== undefined) {
    // A match was found.
    report(matching.isbn, matching.title, matching.author);
  } else {
    // No match was found.
    report(null);
  }
};
        </pre>

          <p>
              The following example looks up all books
              in the database by author using an index and a cursor.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_author");

var request = index.openCursor(IDBKeyRange.only("Fred"));
request.onsuccess = function() {
  var cursor = request.result;
  if (cursor) {
    // Called for each matching record.
    report(cursor.value.isbn, cursor.value.title, cursor.value.author);
    cursor.continue();
  } else {
    // No more matching records.
    report(null);
  }
};
        </pre>

          <p>
              The following example shows how errors could be handled when
              a request fails.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");
var request = store.put({title: "Water Buffaloes", author: "Slate", isbn: 987654});
request.onerror = function() {
  // The uniqueness constraint of the "by_title" index failed.
  report(request.error);
  // Could call request.preventDefault() to prevent the transaction from aborting.
};
tx.onabort = function() {
  // Otherwise the transaction will automatically abort due the failed request.
  report(tx.error);
};
        </pre>

          <p>
              The database connection may be closed when it is no longer needed.
          </p>
        <pre class="example highlight">
db.close();
        </pre>

        <p>
            In the future, the database may have grown to contain other object
            stores and indexes. The following example shows one way to handle
            opening an older version of the database.
        </p>

          <pre class="example highlight">
var request = indexedDB.open("library", 3); // Request version 3.

request.onupgradeneeded = function(event) {
  var db = request.result;
  if (event.oldVersion &lt; 1) {
    // Version 1 is the first version of the database.
    var store = db.createObjectStore("books", {keyPath: "isbn"});
    var titleIndex = store.createIndex("by_title", "title", {unique: true});
    var authorIndex = store.createIndex("by_author", "author");
  }
  if (event.oldVersion &lt; 2) {
    // Version 2 introduces a new index of books by year.
    var bookStore = request.transaction.objectStore("books");
    var yearIndex = bookStore.createIndex("by_year", "year");
  }
  if (event.oldVersion &lt; 3) {
    // Version 3 introduces a new object store for magazines with two indexes.
    var magazines = db.createObjectStore("magazines");
    var publisherIndex = magazines.createIndex("by_publisher", "publisher");
    var frequencyIndex = magazines.createIndex("by_frequency", "frequency");
  }
};

request.onsuccess = function() {
  db = request.result; // db.version will be 3.
};
          </pre>

      </aside>

<!--
      <p class="issue">
        TODO: Add example using the sync API.
      </p>
-->

    </section>

    <section id='conformance' class='section'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt><dfn title="conforming user agent">Conforming user agent</dfn></dt>
        <dd>
          <p>
            A user agent MUST behave as described in this specification
            in order to be considered conformant.
          </p>
          
          <p>
            User agents MAY implement algorithms given in this
            specification in any way desired, so long as the end result is
            indistinguishable from the result that would be obtained by the
            specification's algorithms.
          </p>
          
          <p>
            A conforming Indexed Database API user agent MUST also be a
            <em>conforming implementation</em> of the IDL fragments
            of this specification, as described in the
            “Web IDL” specification. [[!WEBIDL]]
          </p>
          
          <p class="note">
            This specification uses both the terms "conforming user agent(s)" 
            and "user agent(s)" to refer to this product class.
          </p>
        </dd>
      </dl>        
      
      <section class="section" id="dependencies">
        <h3>Dependencies</h3>
        <p>
          This specification relies on several other underlying specifications. 
        </p>
        <dl>
          <dt>DOM-LEVEL-3-EVENTS</dt>
          <dd>The terms <dfn>default action</dfn> and <dfn>propagation path</dfn> are defined by the
            Document Object Model (DOM) Level 3 Events Specification [[!DOM-LEVEL-3-EVENTS]].
          </dd>
          <dt>HTML5</dt>
          <dd>The terms and algorithms <dfn id="document-base-url">document base URL</dfn>,
            <dfn id="event-handler-attributes">event handler attributes</dfn>, 
            <dfn id="event-handler-event-type">event handler event type</dfn>,
            <dfn title="Function"><code>Function</code></dfn>,
            <dfn>origin</dfn>, <dfn>same origin</dfn>, <dfn>structured clone</dfn>,
            <dfn>structured clone algorithm</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>, 
            and <dfn title="queue-a-task">queue a task</dfn> are defined by the HTML 5 
            specification [[!HTML5]].
          </dd>
          <dt>WebIDL</dt>
          <dd>Many of the interface definitions and all of the IDL in this spec depends on [[!WEBIDL]].</dd>
          <dt>WebWorkers</dt>
          <dd>The term <dfn title="worker"><a class="externalDFN"><code>Worker</code></a></dfn> is defined by
          the WebWorkers specification [[!WEBWORKERS]].</dd>
        </dl>
      </section>
    </section>
    <!-- end-content -->
    </section>
  </body>
</html>
